From 8e5b0e255bfbfc84e1628e2574ed372a73df3f0a Mon Sep 17 00:00:00 2001
From: Wenli Looi <wlooi@ucalgary.ca>
Date: Mon, 13 Nov 2023 04:45:53 +0000
Subject: [PATCH] ath9k: experimental support for QCN5502

---
 ...oup-some-ar9300-eeprom-functions-at-.patch |  134 +
 ...-add-_ah-parameter-to-certain-macros.patch | 3105 +++++++++++++++++
 ...hw-fall-back-to-OTP-ROM-when-platfor.patch |   48 +
 ...05-wifi-ath9k-add-QCN550x-device-IDs.patch |  110 +
 ...wifi-ath9k-basic-support-for-QCN550x.patch |  734 ++++
 .../007-wifi-ath9k-add-QCN550x-initvals.patch | 1708 +++++++++
 .../008-wifi-ath9k-implement-QCN550x-rx.patch |  159 +
 .../009-wifi-ath9k-implement-QCN550x-tx.patch |  162 +
 ...-add-abstractions-over-ar9300-eeprom.patch | 1156 ++++++
 .../011-wifi-ath9k-add-QCN550x-eeprom.patch   |  690 ++++
 .../ath9k/543-ath9k_entropy_from_adc.patch    |   10 +-
 .../ath9k/545-ath9k_ani_ws_detect.patch       |   26 +-
 12 files changed, 8024 insertions(+), 13 deletions(-)
 create mode 100644 package/feeds/base/mac80211/patches/ath9k/001-wifi-ath9k-group-some-ar9300-eeprom-functions-at-.patch
 create mode 100644 package/feeds/base/mac80211/patches/ath9k/003-wifi-ath9k-add-_ah-parameter-to-certain-macros.patch
 create mode 100644 package/feeds/base/mac80211/patches/ath9k/004-Revert-ath9k_hw-fall-back-to-OTP-ROM-when-platfor.patch
 create mode 100644 package/feeds/base/mac80211/patches/ath9k/005-wifi-ath9k-add-QCN550x-device-IDs.patch
 create mode 100644 package/feeds/base/mac80211/patches/ath9k/006-wifi-ath9k-basic-support-for-QCN550x.patch
 create mode 100644 package/feeds/base/mac80211/patches/ath9k/007-wifi-ath9k-add-QCN550x-initvals.patch
 create mode 100644 package/feeds/base/mac80211/patches/ath9k/008-wifi-ath9k-implement-QCN550x-rx.patch
 create mode 100644 package/feeds/base/mac80211/patches/ath9k/009-wifi-ath9k-implement-QCN550x-tx.patch
 create mode 100644 package/feeds/base/mac80211/patches/ath9k/010-wifi-ath9k-add-abstractions-over-ar9300-eeprom.patch
 create mode 100644 package/feeds/base/mac80211/patches/ath9k/011-wifi-ath9k-add-QCN550x-eeprom.patch

diff --git a/package/feeds/base/mac80211/patches/ath9k/001-wifi-ath9k-group-some-ar9300-eeprom-functions-at-.patch b/package/feeds/base/mac80211/patches/ath9k/001-wifi-ath9k-group-some-ar9300-eeprom-functions-at-.patch
new file mode 100644
index 0000000000..9cf6de9129
--- /dev/null
+++ b/package/feeds/base/mac80211/patches/ath9k/001-wifi-ath9k-group-some-ar9300-eeprom-functions-at-.patch
@@ -0,0 +1,134 @@
+From dc8557b809c897703f3c441c2ef79bc9d026b324 Mon Sep 17 00:00:00 2001
+From: Wenli Looi <wlooi@ucalgary.ca>
+Date: Mon, 18 Apr 2022 05:17:02 +0000
+Subject: [PATCH v3 01/11] wifi: ath9k: group some ar9300 eeprom functions at
+ the top
+
+These functions will be part of an abstraction layer that works with
+both AR9300 and QCN5502 EEPROM formats.
+
+This change does not appear to affect the final binary.
+
+Signed-off-by: Wenli Looi <wlooi@ucalgary.ca>
+---
+ .../net/wireless/ath/ath9k/ar9003_eeprom.c    | 90 +++++++++----------
+ 1 file changed, 45 insertions(+), 45 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+index 944f46cdf3..58dce556b0 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+@@ -2970,6 +2970,51 @@ static int interpolate(int x, int xa, int xb, int ya, int yb)
+ 	return ya + factor + plus;
+ }
+ 
++/* XXX: review hardware docs */
++static int ath9k_hw_ar9300_get_eeprom_ver(struct ath_hw *ah)
++{
++	return ah->eeprom.ar9300_eep.eepromVersion;
++}
++
++/* XXX: could be read from the eepromVersion, not sure yet */
++static int ath9k_hw_ar9300_get_eeprom_rev(struct ath_hw *ah)
++{
++	return 0;
++}
++
++static struct ar9300_modal_eep_header *ar9003_modal_header(struct ath_hw *ah,
++							   bool is2ghz)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++
++	if (is2ghz)
++		return &eep->modalHeader2G;
++	else
++		return &eep->modalHeader5G;
++}
++
++static u16 ar9003_hw_ant_ctrl_chain_get(struct ath_hw *ah, int chain,
++					bool is2ghz)
++{
++	__le16 val = ar9003_modal_header(ah, is2ghz)->antCtrlChain[chain];
++	return le16_to_cpu(val);
++}
++
++u32 ar9003_hw_ant_ctrl_common_get(struct ath_hw *ah, bool is2ghz)
++{
++	return le32_to_cpu(ar9003_modal_header(ah, is2ghz)->antCtrlCommon);
++}
++
++u32 ar9003_hw_ant_ctrl_common_2_get(struct ath_hw *ah, bool is2ghz)
++{
++	return le32_to_cpu(ar9003_modal_header(ah, is2ghz)->antCtrlCommon2);
++}
++
++static u16 ar9003_switch_com_spdt_get(struct ath_hw *ah, bool is2ghz)
++{
++	return le16_to_cpu(ar9003_modal_header(ah, is2ghz)->switchcomspdt);
++}
++
+ static u32 ath9k_hw_ar9300_get_eeprom(struct ath_hw *ah,
+ 				      enum eeprom_param param)
+ {
+@@ -3578,29 +3623,6 @@ static u32 ath9k_hw_ar9003_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,
+ }
+ #endif
+ 
+-/* XXX: review hardware docs */
+-static int ath9k_hw_ar9300_get_eeprom_ver(struct ath_hw *ah)
+-{
+-	return ah->eeprom.ar9300_eep.eepromVersion;
+-}
+-
+-/* XXX: could be read from the eepromVersion, not sure yet */
+-static int ath9k_hw_ar9300_get_eeprom_rev(struct ath_hw *ah)
+-{
+-	return 0;
+-}
+-
+-static struct ar9300_modal_eep_header *ar9003_modal_header(struct ath_hw *ah,
+-							   bool is2ghz)
+-{
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-
+-	if (is2ghz)
+-		return &eep->modalHeader2G;
+-	else
+-		return &eep->modalHeader5G;
+-}
+-
+ static void ar9003_hw_xpa_bias_level_apply(struct ath_hw *ah, bool is2ghz)
+ {
+ 	int bias = ar9003_modal_header(ah, is2ghz)->xpaBiasLvl;
+@@ -3620,28 +3642,6 @@ static void ar9003_hw_xpa_bias_level_apply(struct ath_hw *ah, bool is2ghz)
+ 	}
+ }
+ 
+-static u16 ar9003_switch_com_spdt_get(struct ath_hw *ah, bool is2ghz)
+-{
+-	return le16_to_cpu(ar9003_modal_header(ah, is2ghz)->switchcomspdt);
+-}
+-
+-u32 ar9003_hw_ant_ctrl_common_get(struct ath_hw *ah, bool is2ghz)
+-{
+-	return le32_to_cpu(ar9003_modal_header(ah, is2ghz)->antCtrlCommon);
+-}
+-
+-u32 ar9003_hw_ant_ctrl_common_2_get(struct ath_hw *ah, bool is2ghz)
+-{
+-	return le32_to_cpu(ar9003_modal_header(ah, is2ghz)->antCtrlCommon2);
+-}
+-
+-static u16 ar9003_hw_ant_ctrl_chain_get(struct ath_hw *ah, int chain,
+-					bool is2ghz)
+-{
+-	__le16 val = ar9003_modal_header(ah, is2ghz)->antCtrlChain[chain];
+-	return le16_to_cpu(val);
+-}
+-
+ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
+ {
+ 	struct ath_common *common = ath9k_hw_common(ah);
+-- 
+2.34.1
+
diff --git a/package/feeds/base/mac80211/patches/ath9k/003-wifi-ath9k-add-_ah-parameter-to-certain-macros.patch b/package/feeds/base/mac80211/patches/ath9k/003-wifi-ath9k-add-_ah-parameter-to-certain-macros.patch
new file mode 100644
index 0000000000..ade8e31563
--- /dev/null
+++ b/package/feeds/base/mac80211/patches/ath9k/003-wifi-ath9k-add-_ah-parameter-to-certain-macros.patch
@@ -0,0 +1,3105 @@
+From 4cd2497cd31184c4eff2ae9d07cecf80714eb716 Mon Sep 17 00:00:00 2001
+From: Wenli Looi <wlooi@ucalgary.ca>
+Date: Mon, 3 Apr 2023 08:13:25 +0000
+Subject: [PATCH v3 03/11] wifi: ath9k: add _ah parameter to certain macros
+
+These macros will have different values for QCN5502.
+
+This change does not appear to affect the final binary.
+
+Signed-off-by: Wenli Looi <wlooi@ucalgary.ca>
+---
+ drivers/net/wireless/ath/ath9k/ar9003_aic.c   |  52 +-
+ drivers/net/wireless/ath/ath9k/ar9003_calib.c |  94 +--
+ .../net/wireless/ath/ath9k/ar9003_eeprom.c    | 130 ++---
+ drivers/net/wireless/ath/ath9k/ar9003_mci.c   |   4 +-
+ drivers/net/wireless/ath/ath9k/ar9003_paprd.c | 116 ++--
+ drivers/net/wireless/ath/ath9k/ar9003_phy.c   | 322 +++++-----
+ drivers/net/wireless/ath/ath9k/ar9003_phy.h   | 550 +++++++++---------
+ drivers/net/wireless/ath/ath9k/ar9003_rtt.c   |  32 +-
+ drivers/net/wireless/ath/ath9k/reg.h          |   6 +-
+ drivers/net/wireless/ath/ath9k/reg_aic.h      |  40 +-
+ drivers/net/wireless/ath/ath9k/rng.c          |   4 +-
+ 11 files changed, 675 insertions(+), 675 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_aic.c b/drivers/net/wireless/ath/ath9k/ar9003_aic.c
+index d0f1e8bcc8..9ba55fea67 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_aic.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_aic.c
+@@ -108,8 +108,8 @@ static void ar9003_aic_gain_table(struct ath_hw *ah)
+ 	u32 aic_atten_word[19], i;
+ 
+ 	/* Config LNA gain difference */
+-	REG_WRITE(ah, AR_PHY_BT_COEX_4, 0x2c200a00);
+-	REG_WRITE(ah, AR_PHY_BT_COEX_5, 0x5c4e4438);
++	REG_WRITE(ah, AR_PHY_BT_COEX_4(ah), 0x2c200a00);
++	REG_WRITE(ah, AR_PHY_BT_COEX_5(ah), 0x5c4e4438);
+ 
+ 	/* Program gain table */
+ 	aic_atten_word[0] = (0x1 & 0xf) << 14 | (0x1f & 0x1f) << 9 | (0x0 & 0xf) << 5 |
+@@ -152,12 +152,12 @@ static void ar9003_aic_gain_table(struct ath_hw *ah)
+ 		(0x1 & 0x1f);  /* -37 dB: 4'd7, 5'd01, -36 dB: 4'd6, 5'd01 */
+ 
+ 	/* Write to Gain table with auto increment enabled. */
+-	REG_WRITE(ah, (AR_PHY_AIC_SRAM_ADDR_B0 + 0x3000),
++	REG_WRITE(ah, (AR_PHY_AIC_SRAM_ADDR_B0(ah) + 0x3000),
+ 		  (ATH_AIC_SRAM_AUTO_INCREMENT |
+ 		   ATH_AIC_SRAM_GAIN_TABLE_OFFSET));
+ 
+ 	for (i = 0; i < 19; i++) {
+-		REG_WRITE(ah, (AR_PHY_AIC_SRAM_DATA_B0 + 0x3000),
++		REG_WRITE(ah, (AR_PHY_AIC_SRAM_DATA_B0(ah) + 0x3000),
+ 			  aic_atten_word[i]);
+ 	}
+ }
+@@ -168,16 +168,16 @@ static u8 ar9003_aic_cal_start(struct ath_hw *ah, u8 min_valid_count)
+ 	int i;
+ 
+ 	/* Write to Gain table with auto increment enabled. */
+-	REG_WRITE(ah, (AR_PHY_AIC_SRAM_ADDR_B0 + 0x3000),
++	REG_WRITE(ah, (AR_PHY_AIC_SRAM_ADDR_B0(ah) + 0x3000),
+ 		  (ATH_AIC_SRAM_AUTO_INCREMENT |
+ 		   ATH_AIC_SRAM_CAL_OFFSET));
+ 
+ 	for (i = 0; i < ATH_AIC_MAX_BT_CHANNEL; i++) {
+-		REG_WRITE(ah, (AR_PHY_AIC_SRAM_DATA_B0 + 0x3000), 0);
++		REG_WRITE(ah, (AR_PHY_AIC_SRAM_DATA_B0(ah) + 0x3000), 0);
+ 		aic->aic_sram[i] = 0;
+ 	}
+ 
+-	REG_WRITE(ah, AR_PHY_AIC_CTRL_0_B0,
++	REG_WRITE(ah, AR_PHY_AIC_CTRL_0_B0(ah),
+ 		  (SM(0, AR_PHY_AIC_MON_ENABLE) |
+ 		   SM(127, AR_PHY_AIC_CAL_MAX_HOP_COUNT) |
+ 		   SM(min_valid_count, AR_PHY_AIC_CAL_MIN_VALID_COUNT) |
+@@ -187,14 +187,14 @@ static u8 ar9003_aic_cal_start(struct ath_hw *ah, u8 min_valid_count)
+ 		   SM(0x40, AR_PHY_AIC_BTTX_PWR_THR) |
+ 		   SM(0, AR_PHY_AIC_ENABLE)));
+ 
+-	REG_WRITE(ah, AR_PHY_AIC_CTRL_0_B1,
++	REG_WRITE(ah, AR_PHY_AIC_CTRL_0_B1(ah),
+ 		  (SM(0, AR_PHY_AIC_MON_ENABLE) |
+ 		   SM(1, AR_PHY_AIC_CAL_CH_VALID_RESET) |
+ 		   SM(0, AR_PHY_AIC_CAL_ENABLE) |
+ 		   SM(0x40, AR_PHY_AIC_BTTX_PWR_THR) |
+ 		   SM(0, AR_PHY_AIC_ENABLE)));
+ 
+-	REG_WRITE(ah, AR_PHY_AIC_CTRL_1_B0,
++	REG_WRITE(ah, AR_PHY_AIC_CTRL_1_B0(ah),
+ 		  (SM(8, AR_PHY_AIC_CAL_BT_REF_DELAY) |
+ 		   SM(0, AR_PHY_AIC_BT_IDLE_CFG) |
+ 		   SM(1, AR_PHY_AIC_STDBY_COND) |
+@@ -203,11 +203,11 @@ static u8 ar9003_aic_cal_start(struct ath_hw *ah, u8 min_valid_count)
+ 		   SM(15, AR_PHY_AIC_RSSI_MAX) |
+ 		   SM(0, AR_PHY_AIC_RSSI_MIN)));
+ 
+-	REG_WRITE(ah, AR_PHY_AIC_CTRL_1_B1,
++	REG_WRITE(ah, AR_PHY_AIC_CTRL_1_B1(ah),
+ 		  (SM(15, AR_PHY_AIC_RSSI_MAX) |
+ 		   SM(0, AR_PHY_AIC_RSSI_MIN)));
+ 
+-	REG_WRITE(ah, AR_PHY_AIC_CTRL_2_B0,
++	REG_WRITE(ah, AR_PHY_AIC_CTRL_2_B0(ah),
+ 		  (SM(44, AR_PHY_AIC_RADIO_DELAY) |
+ 		   SM(8, AR_PHY_AIC_CAL_STEP_SIZE_CORR) |
+ 		   SM(12, AR_PHY_AIC_CAL_ROT_IDX_CORR) |
+@@ -217,7 +217,7 @@ static u8 ar9003_aic_cal_start(struct ath_hw *ah, u8 min_valid_count)
+ 		   SM(0, AR_PHY_AIC_CAL_SYNTH_AFTER_BTRX) |
+ 		   SM(200, AR_PHY_AIC_CAL_SYNTH_SETTLING)));
+ 
+-	REG_WRITE(ah, AR_PHY_AIC_CTRL_3_B0,
++	REG_WRITE(ah, AR_PHY_AIC_CTRL_3_B0(ah),
+ 		  (SM(2, AR_PHY_AIC_MON_MAX_HOP_COUNT) |
+ 		   SM(1, AR_PHY_AIC_MON_MIN_STALE_COUNT) |
+ 		   SM(1, AR_PHY_AIC_MON_PWR_EST_LONG) |
+@@ -227,14 +227,14 @@ static u8 ar9003_aic_cal_start(struct ath_hw *ah, u8 min_valid_count)
+ 		   SM(1, AR_PHY_AIC_CAL_PERF_CHECK_FACTOR) |
+ 		   SM(1, AR_PHY_AIC_CAL_PWR_EST_LONG)));
+ 
+-	REG_WRITE(ah, AR_PHY_AIC_CTRL_4_B0,
++	REG_WRITE(ah, AR_PHY_AIC_CTRL_4_B0(ah),
+ 		  (SM(2, AR_PHY_AIC_CAL_ROT_ATT_DB_EST_ISO) |
+ 		   SM(3, AR_PHY_AIC_CAL_COM_ATT_DB_EST_ISO) |
+ 		   SM(0, AR_PHY_AIC_CAL_ISO_EST_INIT_SETTING) |
+ 		   SM(2, AR_PHY_AIC_CAL_COM_ATT_DB_BACKOFF) |
+ 		   SM(1, AR_PHY_AIC_CAL_COM_ATT_DB_FIXED)));
+ 
+-	REG_WRITE(ah, AR_PHY_AIC_CTRL_4_B1,
++	REG_WRITE(ah, AR_PHY_AIC_CTRL_4_B1(ah),
+ 		  (SM(2, AR_PHY_AIC_CAL_ROT_ATT_DB_EST_ISO) |
+ 		   SM(3, AR_PHY_AIC_CAL_COM_ATT_DB_EST_ISO) |
+ 		   SM(0, AR_PHY_AIC_CAL_ISO_EST_INIT_SETTING) |
+@@ -251,9 +251,9 @@ static u8 ar9003_aic_cal_start(struct ath_hw *ah, u8 min_valid_count)
+ 	aic->aic_cal_start_time = REG_READ(ah, AR_TSF_L32);
+ 
+ 	/* Start calibration */
+-	REG_CLR_BIT(ah, AR_PHY_AIC_CTRL_0_B1, AR_PHY_AIC_CAL_ENABLE);
+-	REG_SET_BIT(ah, AR_PHY_AIC_CTRL_0_B1, AR_PHY_AIC_CAL_CH_VALID_RESET);
+-	REG_SET_BIT(ah, AR_PHY_AIC_CTRL_0_B1, AR_PHY_AIC_CAL_ENABLE);
++	REG_CLR_BIT(ah, AR_PHY_AIC_CTRL_0_B1(ah), AR_PHY_AIC_CAL_ENABLE);
++	REG_SET_BIT(ah, AR_PHY_AIC_CTRL_0_B1(ah), AR_PHY_AIC_CAL_CH_VALID_RESET);
++	REG_SET_BIT(ah, AR_PHY_AIC_CTRL_0_B1(ah), AR_PHY_AIC_CAL_ENABLE);
+ 
+ 	aic->aic_caled_chan = 0;
+ 	aic->aic_cal_state = AIC_CAL_STATE_STARTED;
+@@ -465,7 +465,7 @@ static u8 ar9003_aic_cal_continue(struct ath_hw *ah, bool cal_once)
+ 
+ 	if (cal_once) {
+ 		for (i = 0; i < 10000; i++) {
+-			if ((REG_READ(ah, AR_PHY_AIC_CTRL_0_B1) &
++			if ((REG_READ(ah, AR_PHY_AIC_CTRL_0_B1(ah)) &
+ 			     AR_PHY_AIC_CAL_ENABLE) == 0)
+ 				break;
+ 
+@@ -477,19 +477,19 @@ static u8 ar9003_aic_cal_continue(struct ath_hw *ah, bool cal_once)
+ 	 * Use AR_PHY_AIC_CAL_ENABLE bit instead of AR_PHY_AIC_CAL_DONE.
+ 	 * Sometimes CAL_DONE bit is not asserted.
+ 	 */
+-	if ((REG_READ(ah, AR_PHY_AIC_CTRL_0_B1) &
++	if ((REG_READ(ah, AR_PHY_AIC_CTRL_0_B1(ah)) &
+ 	     AR_PHY_AIC_CAL_ENABLE) != 0) {
+ 		ath_dbg(common, MCI, "AIC cal is not done after 40ms");
+ 		goto exit;
+ 	}
+ 
+-	REG_WRITE(ah, AR_PHY_AIC_SRAM_ADDR_B1,
++	REG_WRITE(ah, AR_PHY_AIC_SRAM_ADDR_B1(ah),
+ 		  (ATH_AIC_SRAM_CAL_OFFSET | ATH_AIC_SRAM_AUTO_INCREMENT));
+ 
+ 	for (i = 0; i < ATH_AIC_MAX_BT_CHANNEL; i++) {
+ 		u32 value;
+ 
+-		value = REG_READ(ah, AR_PHY_AIC_SRAM_DATA_B1);
++		value = REG_READ(ah, AR_PHY_AIC_SRAM_DATA_B1(ah));
+ 
+ 		if (value & 0x01) {
+ 			if (aic->aic_sram[i] == 0)
+@@ -506,10 +506,10 @@ static u8 ar9003_aic_cal_continue(struct ath_hw *ah, bool cal_once)
+ 		ar9003_aic_cal_done(ah);
+ 	} else {
+ 		/* Start calibration */
+-		REG_CLR_BIT(ah, AR_PHY_AIC_CTRL_0_B1, AR_PHY_AIC_CAL_ENABLE);
+-		REG_SET_BIT(ah, AR_PHY_AIC_CTRL_0_B1,
++		REG_CLR_BIT(ah, AR_PHY_AIC_CTRL_0_B1(ah), AR_PHY_AIC_CAL_ENABLE);
++		REG_SET_BIT(ah, AR_PHY_AIC_CTRL_0_B1(ah),
+ 			    AR_PHY_AIC_CAL_CH_VALID_RESET);
+-		REG_SET_BIT(ah, AR_PHY_AIC_CTRL_0_B1, AR_PHY_AIC_CAL_ENABLE);
++		REG_SET_BIT(ah, AR_PHY_AIC_CTRL_0_B1(ah), AR_PHY_AIC_CAL_ENABLE);
+ 	}
+ exit:
+ 	return aic->aic_cal_state;
+@@ -548,10 +548,10 @@ u8 ar9003_aic_start_normal(struct ath_hw *ah)
+ 
+ 	ar9003_aic_gain_table(ah);
+ 
+-	REG_WRITE(ah, AR_PHY_AIC_SRAM_ADDR_B1, ATH_AIC_SRAM_AUTO_INCREMENT);
++	REG_WRITE(ah, AR_PHY_AIC_SRAM_ADDR_B1(ah), ATH_AIC_SRAM_AUTO_INCREMENT);
+ 
+ 	for (i = 0; i < ATH_AIC_MAX_BT_CHANNEL; i++) {
+-		REG_WRITE(ah, AR_PHY_AIC_SRAM_DATA_B1, aic->aic_sram[i]);
++		REG_WRITE(ah, AR_PHY_AIC_SRAM_DATA_B1(ah), aic->aic_sram[i]);
+ 	}
+ 
+ 	/* FIXME: Replace these with proper register names */
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_calib.c b/drivers/net/wireless/ath/ath9k/ar9003_calib.c
+index 2224cb74b1..6d1f1242e6 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_calib.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_calib.c
+@@ -47,16 +47,16 @@ static void ar9003_hw_setup_calibration(struct ath_hw *ah,
+ 		 * Start calibration with
+ 		 * 2^(INIT_IQCAL_LOG_COUNT_MAX+1) samples
+ 		 */
+-		REG_RMW_FIELD(ah, AR_PHY_TIMING4,
++		REG_RMW_FIELD(ah, AR_PHY_TIMING4(ah),
+ 			      AR_PHY_TIMING4_IQCAL_LOG_COUNT_MAX,
+ 			      currCal->calData->calCountMax);
+-		REG_WRITE(ah, AR_PHY_CALMODE, AR_PHY_CALMODE_IQ);
++		REG_WRITE(ah, AR_PHY_CALMODE(ah), AR_PHY_CALMODE_IQ);
+ 
+ 		ath_dbg(common, CALIBRATE,
+ 			"starting IQ Mismatch Calibration\n");
+ 
+ 		/* Kick-off cal */
+-		REG_SET_BIT(ah, AR_PHY_TIMING4, AR_PHY_TIMING4_DO_CAL);
++		REG_SET_BIT(ah, AR_PHY_TIMING4(ah), AR_PHY_TIMING4_DO_CAL);
+ 		break;
+ 	default:
+ 		ath_err(common, "Invalid calibration type\n");
+@@ -80,7 +80,7 @@ static bool ar9003_hw_per_calibration(struct ath_hw *ah,
+ 	/* Calibration in progress. */
+ 	if (currCal->calState == CAL_RUNNING) {
+ 		/* Check to see if it has finished. */
+-		if (REG_READ(ah, AR_PHY_TIMING4) & AR_PHY_TIMING4_DO_CAL)
++		if (REG_READ(ah, AR_PHY_TIMING4(ah)) & AR_PHY_TIMING4_DO_CAL)
+ 			return false;
+ 
+ 		/*
+@@ -180,11 +180,11 @@ static void ar9003_hw_iqcal_collect(struct ath_hw *ah)
+ 	for (i = 0; i < AR9300_MAX_CHAINS; i++) {
+ 		if (ah->txchainmask & BIT(i)) {
+ 			ah->totalPowerMeasI[i] +=
+-				REG_READ(ah, AR_PHY_CAL_MEAS_0(i));
++				REG_READ(ah, AR_PHY_CAL_MEAS_0(ah, i));
+ 			ah->totalPowerMeasQ[i] +=
+-				REG_READ(ah, AR_PHY_CAL_MEAS_1(i));
++				REG_READ(ah, AR_PHY_CAL_MEAS_1(ah, i));
+ 			ah->totalIqCorrMeas[i] +=
+-				(int32_t) REG_READ(ah, AR_PHY_CAL_MEAS_2(i));
++				(int32_t) REG_READ(ah, AR_PHY_CAL_MEAS_2(ah, i));
+ 			ath_dbg(ath9k_hw_common(ah), CALIBRATE,
+ 				"%d: Chn %d pmi=0x%08x;pmq=0x%08x;iqcm=0x%08x;\n",
+ 				ah->cal_samples, i, ah->totalPowerMeasI[i],
+@@ -202,9 +202,9 @@ static void ar9003_hw_iqcalibrate(struct ath_hw *ah, u8 numChains)
+ 	int32_t qCoff, iCoff;
+ 	int iqCorrNeg, i;
+ 	static const u_int32_t offset_array[3] = {
+-		AR_PHY_RX_IQCAL_CORR_B0,
+-		AR_PHY_RX_IQCAL_CORR_B1,
+-		AR_PHY_RX_IQCAL_CORR_B2,
++		AR_PHY_RX_IQCAL_CORR_B0(ah),
++		AR_PHY_RX_IQCAL_CORR_B1(ah),
++		AR_PHY_RX_IQCAL_CORR_B2(ah),
+ 	};
+ 
+ 	for (i = 0; i < numChains; i++) {
+@@ -297,13 +297,13 @@ static void ar9003_hw_iqcalibrate(struct ath_hw *ah, u8 numChains)
+ 		}
+ 	}
+ 
+-	REG_SET_BIT(ah, AR_PHY_RX_IQCAL_CORR_B0,
++	REG_SET_BIT(ah, AR_PHY_RX_IQCAL_CORR_B0(ah),
+ 		    AR_PHY_RX_IQCAL_CORR_IQCORR_ENABLE);
+ 	ath_dbg(common, CALIBRATE,
+ 		"IQ Cal and Correction (offset 0x%04x) enabled (bit position 0x%08x). New Value 0x%08x\n",
+-		(unsigned) (AR_PHY_RX_IQCAL_CORR_B0),
++		(unsigned) (AR_PHY_RX_IQCAL_CORR_B0(ah)),
+ 		AR_PHY_RX_IQCAL_CORR_IQCORR_ENABLE,
+-		REG_READ(ah, AR_PHY_RX_IQCAL_CORR_B0));
++		REG_READ(ah, AR_PHY_RX_IQCAL_CORR_B0(ah)));
+ }
+ 
+ static const struct ath9k_percal_data iq_cal_single_sample = {
+@@ -369,7 +369,7 @@ static bool ar9003_hw_dynamic_osdac_selection(struct ath_hw *ah,
+ 	 */
+ 	REG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah),
+ 		    AR_PHY_AGC_CONTROL_OFFSET_CAL);
+-	REG_CLR_BIT(ah, AR_PHY_CL_CAL_CTL,
++	REG_CLR_BIT(ah, AR_PHY_CL_CAL_CTL(ah),
+ 		    AR_PHY_CL_CAL_ENABLE);
+ 	REG_CLR_BIT(ah, AR_PHY_AGC_CONTROL(ah),
+ 		    AR_PHY_AGC_CONTROL_FLTR_CAL);
+@@ -385,7 +385,7 @@ static bool ar9003_hw_dynamic_osdac_selection(struct ath_hw *ah,
+ 		osdac_ch1 = (REG_READ(ah, AR_PHY_65NM_CH1_BB1) >> 30) & 0x3;
+ 		osdac_ch2 = (REG_READ(ah, AR_PHY_65NM_CH2_BB1) >> 30) & 0x3;
+ 
+-		REG_SET_BIT(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
++		REG_SET_BIT(ah, AR_PHY_ACTIVE(ah), AR_PHY_ACTIVE_EN);
+ 
+ 		REG_WRITE(ah, AR_PHY_AGC_CONTROL(ah),
+ 			  REG_READ(ah, AR_PHY_AGC_CONTROL(ah)) | AR_PHY_AGC_CONTROL_CAL);
+@@ -399,7 +399,7 @@ static bool ar9003_hw_dynamic_osdac_selection(struct ath_hw *ah,
+ 			return false;
+ 		}
+ 
+-		REG_CLR_BIT(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
++		REG_CLR_BIT(ah, AR_PHY_ACTIVE(ah), AR_PHY_ACTIVE_EN);
+ 
+ 		/*
+ 		 * High gain.
+@@ -533,7 +533,7 @@ static bool ar9003_hw_dynamic_osdac_selection(struct ath_hw *ah,
+ 
+ 	REG_CLR_BIT(ah, AR_PHY_AGC_CONTROL(ah),
+ 		    AR_PHY_AGC_CONTROL_OFFSET_CAL);
+-	REG_SET_BIT(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
++	REG_SET_BIT(ah, AR_PHY_ACTIVE(ah), AR_PHY_ACTIVE_EN);
+ 
+ 	/*
+ 	 * We don't need to check txiqcal_done here since it is always
+@@ -901,11 +901,11 @@ static void ar9003_hw_tx_iq_cal_outlier_detection(struct ath_hw *ah,
+ 		if (!AR_SREV_9485(ah)) {
+ 			tx_corr_coeff[i * 2][1] =
+ 			tx_corr_coeff[(i * 2) + 1][1] =
+-					AR_PHY_TX_IQCAL_CORR_COEFF_B1(i);
++					AR_PHY_TX_IQCAL_CORR_COEFF_B1(ah, i);
+ 
+ 			tx_corr_coeff[i * 2][2] =
+ 			tx_corr_coeff[(i * 2) + 1][2] =
+-					AR_PHY_TX_IQCAL_CORR_COEFF_B2(i);
++					AR_PHY_TX_IQCAL_CORR_COEFF_B2(ah, i);
+ 		}
+ 	}
+ 
+@@ -962,9 +962,9 @@ static void ar9003_hw_tx_iq_cal_outlier_detection(struct ath_hw *ah,
+ 			caldata->num_measures[i] = nmeasurement;
+ 	}
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_TX_IQCAL_CONTROL_3,
++	REG_RMW_FIELD(ah, AR_PHY_TX_IQCAL_CONTROL_3(ah),
+ 		      AR_PHY_TX_IQCAL_CONTROL_3_IQCORR_EN, 0x1);
+-	REG_RMW_FIELD(ah, AR_PHY_RX_IQCAL_CORR_B0,
++	REG_RMW_FIELD(ah, AR_PHY_RX_IQCAL_CORR_B0(ah),
+ 		      AR_PHY_RX_IQCAL_CORR_B0_LOOPBACK_IQCORR_EN, 0x1);
+ 
+ 	if (caldata) {
+@@ -982,10 +982,10 @@ static bool ar9003_hw_tx_iq_cal_run(struct ath_hw *ah)
+ 	struct ath_common *common = ath9k_hw_common(ah);
+ 	u8 tx_gain_forced;
+ 
+-	tx_gain_forced = REG_READ_FIELD(ah, AR_PHY_TX_FORCED_GAIN,
++	tx_gain_forced = REG_READ_FIELD(ah, AR_PHY_TX_FORCED_GAIN(ah),
+ 					AR_PHY_TXGAIN_FORCE);
+ 	if (tx_gain_forced)
+-		REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN,
++		REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN(ah),
+ 			      AR_PHY_TXGAIN_FORCE, 0);
+ 
+ 	REG_RMW_FIELD(ah, AR_PHY_TX_IQCAL_START(ah),
+@@ -1057,13 +1057,13 @@ static void ar9003_hw_tx_iq_cal_post_proc(struct ath_hw *ah,
+ 	struct ath_common *common = ath9k_hw_common(ah);
+ 	const u32 txiqcal_status[AR9300_MAX_CHAINS] = {
+ 		AR_PHY_TX_IQCAL_STATUS_B0(ah),
+-		AR_PHY_TX_IQCAL_STATUS_B1,
+-		AR_PHY_TX_IQCAL_STATUS_B2,
++		AR_PHY_TX_IQCAL_STATUS_B1(ah),
++		AR_PHY_TX_IQCAL_STATUS_B2(ah),
+ 	};
+ 	const u_int32_t chan_info_tab[] = {
+-		AR_PHY_CHAN_INFO_TAB_0,
+-		AR_PHY_CHAN_INFO_TAB_1,
+-		AR_PHY_CHAN_INFO_TAB_2,
++		AR_PHY_CHAN_INFO_TAB_0(ah),
++		AR_PHY_CHAN_INFO_TAB_1(ah),
++		AR_PHY_CHAN_INFO_TAB_2(ah),
+ 	};
+ 	static struct coeff coeff;
+ 	s32 iq_res[6];
+@@ -1165,11 +1165,11 @@ static void ar9003_hw_tx_iq_cal_reload(struct ath_hw *ah)
+ 		if (!AR_SREV_9485(ah)) {
+ 			tx_corr_coeff[i * 2][1] =
+ 			tx_corr_coeff[(i * 2) + 1][1] =
+-					AR_PHY_TX_IQCAL_CORR_COEFF_B1(i);
++					AR_PHY_TX_IQCAL_CORR_COEFF_B1(ah, i);
+ 
+ 			tx_corr_coeff[i * 2][2] =
+ 			tx_corr_coeff[(i * 2) + 1][2] =
+-					AR_PHY_TX_IQCAL_CORR_COEFF_B2(i);
++					AR_PHY_TX_IQCAL_CORR_COEFF_B2(ah, i);
+ 		}
+ 	}
+ 
+@@ -1189,9 +1189,9 @@ static void ar9003_hw_tx_iq_cal_reload(struct ath_hw *ah)
+ 		}
+ 	}
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_TX_IQCAL_CONTROL_3,
++	REG_RMW_FIELD(ah, AR_PHY_TX_IQCAL_CONTROL_3(ah),
+ 		      AR_PHY_TX_IQCAL_CONTROL_3_IQCORR_EN, 0x1);
+-	REG_RMW_FIELD(ah, AR_PHY_RX_IQCAL_CORR_B0,
++	REG_RMW_FIELD(ah, AR_PHY_RX_IQCAL_CORR_B0(ah),
+ 		      AR_PHY_RX_IQCAL_CORR_B0_LOOPBACK_IQCORR_EN, 0x1);
+ }
+ 
+@@ -1336,9 +1336,9 @@ static void ar9003_hw_do_pcoem_manual_peak_cal(struct ath_hw *ah,
+ 
+ static void ar9003_hw_cl_cal_post_proc(struct ath_hw *ah, bool is_reusable)
+ {
+-	u32 cl_idx[AR9300_MAX_CHAINS] = { AR_PHY_CL_TAB_0,
+-					  AR_PHY_CL_TAB_1,
+-					  AR_PHY_CL_TAB_2 };
++	u32 cl_idx[AR9300_MAX_CHAINS] = { AR_PHY_CL_TAB_0(ah),
++					  AR_PHY_CL_TAB_1(ah),
++					  AR_PHY_CL_TAB_2(ah) };
+ 	struct ath9k_hw_cal_data *caldata = ah->caldata;
+ 	bool txclcal_done = false;
+ 	int i, j;
+@@ -1438,10 +1438,10 @@ static bool ar9003_hw_init_cal_pcoem(struct ath_hw *ah,
+ 
+ 	if (ah->enabled_cals & TX_CL_CAL) {
+ 		if (caldata && test_bit(TXCLCAL_DONE, &caldata->cal_flags))
+-			REG_CLR_BIT(ah, AR_PHY_CL_CAL_CTL,
++			REG_CLR_BIT(ah, AR_PHY_CL_CAL_CTL(ah),
+ 				    AR_PHY_CL_CAL_ENABLE);
+ 		else {
+-			REG_SET_BIT(ah, AR_PHY_CL_CAL_CTL,
++			REG_SET_BIT(ah, AR_PHY_CL_CAL_CTL(ah),
+ 				    AR_PHY_CL_CAL_ENABLE);
+ 			run_agc_cal = true;
+ 		}
+@@ -1474,13 +1474,13 @@ static bool ar9003_hw_init_cal_pcoem(struct ath_hw *ah,
+ 	if (ath9k_hw_mci_is_enabled(ah) && IS_CHAN_2GHZ(chan) && run_agc_cal)
+ 		ar9003_mci_init_cal_req(ah, &is_reusable);
+ 
+-	if (REG_READ(ah, AR_PHY_CL_CAL_CTL) & AR_PHY_CL_CAL_ENABLE) {
+-		rx_delay = REG_READ(ah, AR_PHY_RX_DELAY);
++	if (REG_READ(ah, AR_PHY_CL_CAL_CTL(ah)) & AR_PHY_CL_CAL_ENABLE) {
++		rx_delay = REG_READ(ah, AR_PHY_RX_DELAY(ah));
+ 		/* Disable BB_active */
+-		REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_DIS);
++		REG_WRITE(ah, AR_PHY_ACTIVE(ah), AR_PHY_ACTIVE_DIS);
+ 		udelay(5);
+-		REG_WRITE(ah, AR_PHY_RX_DELAY, AR_PHY_RX_DELAY_DELAY);
+-		REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
++		REG_WRITE(ah, AR_PHY_RX_DELAY(ah), AR_PHY_RX_DELAY_DELAY);
++		REG_WRITE(ah, AR_PHY_ACTIVE(ah), AR_PHY_ACTIVE_EN);
+ 	}
+ 
+ 	if (run_agc_cal || !(ah->ah_flags & AH_FASTCC)) {
+@@ -1497,8 +1497,8 @@ static bool ar9003_hw_init_cal_pcoem(struct ath_hw *ah,
+ 		ar9003_hw_do_pcoem_manual_peak_cal(ah, chan, run_rtt_cal);
+ 	}
+ 
+-	if (REG_READ(ah, AR_PHY_CL_CAL_CTL) & AR_PHY_CL_CAL_ENABLE) {
+-		REG_WRITE(ah, AR_PHY_RX_DELAY, rx_delay);
++	if (REG_READ(ah, AR_PHY_CL_CAL_CTL(ah)) & AR_PHY_CL_CAL_ENABLE) {
++		REG_WRITE(ah, AR_PHY_RX_DELAY(ah), rx_delay);
+ 		udelay(5);
+ 	}
+ 
+@@ -1588,7 +1588,7 @@ static bool ar9003_hw_init_cal_soc(struct ath_hw *ah,
+ 	ar9003_hw_set_chain_masks(ah, ah->caps.rx_chainmask, ah->caps.tx_chainmask);
+ 
+ 	if (ah->enabled_cals & TX_CL_CAL) {
+-		REG_SET_BIT(ah, AR_PHY_CL_CAL_CTL, AR_PHY_CL_CAL_ENABLE);
++		REG_SET_BIT(ah, AR_PHY_CL_CAL_CTL(ah), AR_PHY_CL_CAL_ENABLE);
+ 		run_agc_cal = true;
+ 	}
+ 
+@@ -1622,9 +1622,9 @@ static bool ar9003_hw_init_cal_soc(struct ath_hw *ah,
+ 	 */
+ 	if (sep_iq_cal) {
+ 		txiqcal_done = ar9003_hw_tx_iq_cal_run(ah);
+-		REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_DIS);
++		REG_WRITE(ah, AR_PHY_ACTIVE(ah), AR_PHY_ACTIVE_DIS);
+ 		udelay(5);
+-		REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
++		REG_WRITE(ah, AR_PHY_ACTIVE(ah), AR_PHY_ACTIVE_EN);
+ 	}
+ 
+ 	if (AR_SREV_9550(ah) && IS_CHAN_2GHZ(chan)) {
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+index 58dce556b0..3dab290d8a 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+@@ -3649,9 +3649,9 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
+ 	int chain;
+ 	u32 regval, value, gpio;
+ 	static const u32 switch_chain_reg[AR9300_MAX_CHAINS] = {
+-			AR_PHY_SWITCH_CHAIN_0,
+-			AR_PHY_SWITCH_CHAIN_1,
+-			AR_PHY_SWITCH_CHAIN_2,
++			AR_PHY_SWITCH_CHAIN_0(ah),
++			AR_PHY_SWITCH_CHAIN_1(ah),
++			AR_PHY_SWITCH_CHAIN_2(ah),
+ 	};
+ 
+ 	if (AR_SREV_9485(ah) && (ar9003_hw_get_rx_gain_idx(ah) == 0)) {
+@@ -3667,13 +3667,13 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
+ 	value = ar9003_hw_ant_ctrl_common_get(ah, is2ghz);
+ 
+ 	if (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {
+-		REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM,
++		REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM(ah),
+ 				AR_SWITCH_TABLE_COM_AR9462_ALL, value);
+ 	} else if (AR_SREV_9550(ah) || AR_SREV_9531(ah) || AR_SREV_9561(ah)) {
+-		REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM,
++		REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM(ah),
+ 				AR_SWITCH_TABLE_COM_AR9550_ALL, value);
+ 	} else
+-		REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM,
++		REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM(ah),
+ 			      AR_SWITCH_TABLE_COM_ALL, value);
+ 
+ 
+@@ -3703,7 +3703,7 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
+ 		value |= ah->config.ant_ctrl_comm2g_switch_enable;
+ 
+ 	}
+-	REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM_2, AR_SWITCH_TABLE_COM2_ALL, value);
++	REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM_2(ah), AR_SWITCH_TABLE_COM2_ALL, value);
+ 
+ 	if ((AR_SREV_9462(ah)) && (ah->rxchainmask == 0x2)) {
+ 		value = ar9003_hw_ant_ctrl_chain_get(ah, 1, is2ghz);
+@@ -3727,7 +3727,7 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
+ 		 * main_lnaconf, alt_lnaconf, main_tb, alt_tb
+ 		 * are the fields present
+ 		 */
+-		regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL);
++		regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL(ah));
+ 		regval &= (~AR_ANT_DIV_CTRL_ALL);
+ 		regval |= (value & 0x3f) << AR_ANT_DIV_CTRL_ALL_S;
+ 		/* enable_lnadiv */
+@@ -3741,7 +3741,7 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
+ 			if (common->bt_ant_diversity) {
+ 				regval |= (1 << AR_PHY_ANT_SW_RX_PROT_S);
+ 
+-				REG_SET_BIT(ah, AR_PHY_RESTART,
++				REG_SET_BIT(ah, AR_PHY_RESTART(ah),
+ 					    AR_PHY_RESTART_ENABLE_DIV_M2FLAG);
+ 
+ 				/* Force WLAN LNA diversity ON */
+@@ -3751,7 +3751,7 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
+ 				regval &= ~(1 << AR_PHY_ANT_DIV_LNADIV_S);
+ 				regval &= ~(1 << AR_PHY_ANT_SW_RX_PROT_S);
+ 
+-				REG_CLR_BIT(ah, AR_PHY_MC_GAIN_CTRL,
++				REG_CLR_BIT(ah, AR_PHY_MC_GAIN_CTRL(ah),
+ 					    (1 << AR_PHY_ANT_SW_RX_PROT_S));
+ 
+ 				/* Force WLAN LNA diversity OFF */
+@@ -3760,10 +3760,10 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
+ 			}
+ 		}
+ 
+-		REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
++		REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL(ah), regval);
+ 
+ 		/* enable fast_div */
+-		regval = REG_READ(ah, AR_PHY_CCK_DETECT);
++		regval = REG_READ(ah, AR_PHY_CCK_DETECT(ah));
+ 		regval &= (~AR_FAST_DIV_ENABLE);
+ 		regval |= ((value >> 7) & 0x1) << AR_FAST_DIV_ENABLE_S;
+ 
+@@ -3771,10 +3771,10 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
+ 		    && common->bt_ant_diversity)
+ 			regval |= AR_FAST_DIV_ENABLE;
+ 
+-		REG_WRITE(ah, AR_PHY_CCK_DETECT, regval);
++		REG_WRITE(ah, AR_PHY_CCK_DETECT(ah), regval);
+ 
+ 		if (pCap->hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB) {
+-			regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL);
++			regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL(ah));
+ 			/*
+ 			 * clear bits 25-30 main_lnaconf, alt_lnaconf,
+ 			 * main_tb, alt_tb
+@@ -3788,7 +3788,7 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
+ 				   AR_PHY_ANT_DIV_MAIN_LNACONF_S);
+ 			regval |= (ATH_ANT_DIV_COMB_LNA2 <<
+ 				   AR_PHY_ANT_DIV_ALT_LNACONF_S);
+-			REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
++			REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL(ah), regval);
+ 		}
+ 	}
+ }
+@@ -3894,9 +3894,9 @@ static void ar9003_hw_atten_apply(struct ath_hw *ah, struct ath9k_channel *chan)
+ {
+ 	int i;
+ 	u16 value;
+-	unsigned long ext_atten_reg[3] = {AR_PHY_EXT_ATTEN_CTL_0,
+-					  AR_PHY_EXT_ATTEN_CTL_1,
+-					  AR_PHY_EXT_ATTEN_CTL_2,
++	unsigned long ext_atten_reg[3] = {AR_PHY_EXT_ATTEN_CTL_0(ah),
++					  AR_PHY_EXT_ATTEN_CTL_1(ah),
++					  AR_PHY_EXT_ATTEN_CTL_2(ah),
+ 					 };
+ 
+ 	if ((AR_SREV_9462(ah)) && (ah->rxchainmask == 0x2)) {
+@@ -3925,7 +3925,7 @@ static void ar9003_hw_atten_apply(struct ath_hw *ah, struct ath9k_channel *chan)
+ 				value = ar9003_hw_atten_chain_get_margin(ah, i, chan);
+ 
+ 			if (ah->config.alt_mingainidx)
+-				REG_RMW_FIELD(ah, AR_PHY_EXT_ATTEN_CTL_0,
++				REG_RMW_FIELD(ah, AR_PHY_EXT_ATTEN_CTL_0(ah),
+ 					      AR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN,
+ 					      value);
+ 
+@@ -4081,7 +4081,7 @@ static void ar9003_hw_quick_drop_apply(struct ath_hw *ah, u16 freq)
+ 			t[2] = eep->base_ext1.quick_drop_high;
+ 			quick_drop = ar9003_hw_power_interpolate(freq, f, t, 3);
+ 		}
+-		REG_RMW_FIELD(ah, AR_PHY_AGC, AR_PHY_AGC_QUICK_DROP, quick_drop);
++		REG_RMW_FIELD(ah, AR_PHY_AGC(ah), AR_PHY_AGC_QUICK_DROP, quick_drop);
+ 	}
+ }
+ 
+@@ -4091,9 +4091,9 @@ static void ar9003_hw_txend_to_xpa_off_apply(struct ath_hw *ah, bool is2ghz)
+ 
+ 	value = ar9003_modal_header(ah, is2ghz)->txEndToXpaOff;
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL,
++	REG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL(ah),
+ 		      AR_PHY_XPA_TIMING_CTL_TX_END_XPAB_OFF, value);
+-	REG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL,
++	REG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL(ah),
+ 		      AR_PHY_XPA_TIMING_CTL_TX_END_XPAA_OFF, value);
+ }
+ 
+@@ -4114,10 +4114,10 @@ static void ar9003_hw_xpa_timing_control_apply(struct ath_hw *ah, bool is2ghz)
+ 
+ 	xpa_ctl = ar9003_modal_header(ah, is2ghz)->txFrameToXpaOn;
+ 	if (is2ghz)
+-		REG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL,
++		REG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL(ah),
+ 			      AR_PHY_XPA_TIMING_CTL_FRAME_XPAB_ON, xpa_ctl);
+ 	else
+-		REG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL,
++		REG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL(ah),
+ 			      AR_PHY_XPA_TIMING_CTL_FRAME_XPAA_ON, xpa_ctl);
+ }
+ 
+@@ -4193,9 +4193,9 @@ static void ar9003_hw_thermo_cal_apply(struct ath_hw *ah)
+ 	ko = data & 0xff;
+ 	kg = (data >> 8) & 0xff;
+ 	if (ko || kg) {
+-		REG_RMW_FIELD(ah, AR_PHY_BB_THERM_ADC_3,
++		REG_RMW_FIELD(ah, AR_PHY_BB_THERM_ADC_3(ah),
+ 			      AR_PHY_BB_THERM_ADC_3_THERM_ADC_OFFSET, ko);
+-		REG_RMW_FIELD(ah, AR_PHY_BB_THERM_ADC_3,
++		REG_RMW_FIELD(ah, AR_PHY_BB_THERM_ADC_3(ah),
+ 			      AR_PHY_BB_THERM_ADC_3_THERM_ADC_SCALE_GAIN,
+ 			      kg + 256);
+ 	}
+@@ -4206,9 +4206,9 @@ static void ar9003_hw_apply_minccapwr_thresh(struct ath_hw *ah,
+ {
+ 	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+ 	const u_int32_t cca_ctrl[AR9300_MAX_CHAINS] = {
+-		AR_PHY_CCA_CTRL_0,
+-		AR_PHY_CCA_CTRL_1,
+-		AR_PHY_CCA_CTRL_2,
++		AR_PHY_CCA_CTRL_0(ah),
++		AR_PHY_CCA_CTRL_1(ah),
++		AR_PHY_CCA_CTRL_2(ah),
+ 	};
+ 	int chain;
+ 	u32 val;
+@@ -4476,19 +4476,19 @@ int ar9003_hw_tx_power_regwrite(struct ath_hw *ah, u8 * pPwrArray)
+ {
+ #define POW_SM(_r, _s)     (((_r) & 0x3f) << (_s))
+ 	/* make sure forced gain is not set */
+-	REG_WRITE(ah, AR_PHY_TX_FORCED_GAIN, 0);
++	REG_WRITE(ah, AR_PHY_TX_FORCED_GAIN(ah), 0);
+ 
+ 	/* Write the OFDM power per rate set */
+ 
+ 	/* 6 (LSB), 9, 12, 18 (MSB) */
+-	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(0),
++	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(ah, 0),
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_6_24], 24) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_6_24], 16) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_6_24], 8) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_6_24], 0));
+ 
+ 	/* 24 (LSB), 36, 48, 54 (MSB) */
+-	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(1),
++	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(ah, 1),
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_54], 24) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_48], 16) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_36], 8) |
+@@ -4497,14 +4497,14 @@ int ar9003_hw_tx_power_regwrite(struct ath_hw *ah, u8 * pPwrArray)
+ 	/* Write the CCK power per rate set */
+ 
+ 	/* 1L (LSB), reserved, 2L, 2S (MSB) */
+-	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(2),
++	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(ah, 2),
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_1L_5L], 24) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_1L_5L], 16) |
+ 		  /* POW_SM(txPowerTimes2,  8) | this is reserved for AR9003 */
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_1L_5L], 0));
+ 
+ 	/* 5.5L (LSB), 5.5S, 11L, 11S (MSB) */
+-	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(3),
++	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(ah, 3),
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_11S], 24) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_11L], 16) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_5S], 8) |
+@@ -4514,7 +4514,7 @@ int ar9003_hw_tx_power_regwrite(struct ath_hw *ah, u8 * pPwrArray)
+         /* Write the power for duplicated frames - HT40 */
+ 
+         /* dup40_cck (LSB), dup40_ofdm, ext20_cck, ext20_ofdm (MSB) */
+-	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(8),
++	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(ah, 8),
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_6_24], 24) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_1L_5L], 16) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_LEGACY_6_24],  8) |
+@@ -4524,7 +4524,7 @@ int ar9003_hw_tx_power_regwrite(struct ath_hw *ah, u8 * pPwrArray)
+ 	/* Write the HT20 power per rate set */
+ 
+ 	/* 0/8/16 (LSB), 1-3/9-11/17-19, 4, 5 (MSB) */
+-	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(4),
++	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(ah, 4),
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT20_5], 24) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT20_4], 16) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT20_1_3_9_11_17_19], 8) |
+@@ -4532,7 +4532,7 @@ int ar9003_hw_tx_power_regwrite(struct ath_hw *ah, u8 * pPwrArray)
+ 	    );
+ 
+ 	/* 6 (LSB), 7, 12, 13 (MSB) */
+-	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(5),
++	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(ah, 5),
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT20_13], 24) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT20_12], 16) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT20_7], 8) |
+@@ -4540,7 +4540,7 @@ int ar9003_hw_tx_power_regwrite(struct ath_hw *ah, u8 * pPwrArray)
+ 	    );
+ 
+ 	/* 14 (LSB), 15, 20, 21 */
+-	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(9),
++	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(ah, 9),
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT20_21], 24) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT20_20], 16) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT20_15], 8) |
+@@ -4550,7 +4550,7 @@ int ar9003_hw_tx_power_regwrite(struct ath_hw *ah, u8 * pPwrArray)
+ 	/* Mixed HT20 and HT40 rates */
+ 
+ 	/* HT20 22 (LSB), HT20 23, HT40 22, HT40 23 (MSB) */
+-	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(10),
++	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(ah, 10),
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT40_23], 24) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT40_22], 16) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT20_23], 8) |
+@@ -4562,7 +4562,7 @@ int ar9003_hw_tx_power_regwrite(struct ath_hw *ah, u8 * pPwrArray)
+ 	 * correct PAR difference between HT40 and HT20/LEGACY
+ 	 * 0/8/16 (LSB), 1-3/9-11/17-19, 4, 5 (MSB)
+ 	 */
+-	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(6),
++	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(ah, 6),
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT40_5], 24) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT40_4], 16) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT40_1_3_9_11_17_19], 8) |
+@@ -4570,7 +4570,7 @@ int ar9003_hw_tx_power_regwrite(struct ath_hw *ah, u8 * pPwrArray)
+ 	    );
+ 
+ 	/* 6 (LSB), 7, 12, 13 (MSB) */
+-	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(7),
++	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(ah, 7),
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT40_13], 24) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT40_12], 16) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT40_7], 8) |
+@@ -4578,7 +4578,7 @@ int ar9003_hw_tx_power_regwrite(struct ath_hw *ah, u8 * pPwrArray)
+ 	    );
+ 
+ 	/* 14 (LSB), 15, 20, 21 */
+-	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(11),
++	REG_WRITE(ah, AR_PHY_POWER_TX_RATE(ah, 11),
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT40_21], 24) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT40_20], 16) |
+ 		  POW_SM(pPwrArray[ALL_TARGET_HT40_15], 8) |
+@@ -4809,28 +4809,28 @@ static void ar9003_hw_power_control_override(struct ath_hw *ah,
+ 	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+ 	int f[8], t[8], t1[3], t2[3], i;
+ 
+-	REG_RMW(ah, AR_PHY_TPC_11_B0,
++	REG_RMW(ah, AR_PHY_TPC_11_B0(ah),
+ 		(correction[0] << AR_PHY_TPC_OLPC_GAIN_DELTA_S),
+ 		AR_PHY_TPC_OLPC_GAIN_DELTA);
+ 	if (ah->caps.tx_chainmask & BIT(1))
+-		REG_RMW(ah, AR_PHY_TPC_11_B1,
++		REG_RMW(ah, AR_PHY_TPC_11_B1(ah),
+ 			(correction[1] << AR_PHY_TPC_OLPC_GAIN_DELTA_S),
+ 			AR_PHY_TPC_OLPC_GAIN_DELTA);
+ 	if (ah->caps.tx_chainmask & BIT(2))
+-		REG_RMW(ah, AR_PHY_TPC_11_B2,
++		REG_RMW(ah, AR_PHY_TPC_11_B2(ah),
+ 			(correction[2] << AR_PHY_TPC_OLPC_GAIN_DELTA_S),
+ 			AR_PHY_TPC_OLPC_GAIN_DELTA);
+ 
+ 	/* enable open loop power control on chip */
+-	REG_RMW(ah, AR_PHY_TPC_6_B0,
++	REG_RMW(ah, AR_PHY_TPC_6_B0(ah),
+ 		(3 << AR_PHY_TPC_6_ERROR_EST_MODE_S),
+ 		AR_PHY_TPC_6_ERROR_EST_MODE);
+ 	if (ah->caps.tx_chainmask & BIT(1))
+-		REG_RMW(ah, AR_PHY_TPC_6_B1,
++		REG_RMW(ah, AR_PHY_TPC_6_B1(ah),
+ 			(3 << AR_PHY_TPC_6_ERROR_EST_MODE_S),
+ 			AR_PHY_TPC_6_ERROR_EST_MODE);
+ 	if (ah->caps.tx_chainmask & BIT(2))
+-		REG_RMW(ah, AR_PHY_TPC_6_B2,
++		REG_RMW(ah, AR_PHY_TPC_6_B2(ah),
+ 			(3 << AR_PHY_TPC_6_ERROR_EST_MODE_S),
+ 			AR_PHY_TPC_6_ERROR_EST_MODE);
+ 
+@@ -4899,28 +4899,28 @@ static void ar9003_hw_power_control_override(struct ath_hw *ah,
+ 		if (eep->baseEepHeader.featureEnable & 0x1) {
+ 			if (frequency < 4000) {
+ 				if (txmask & BIT(0))
+-					REG_RMW_FIELD(ah, AR_PHY_TPC_19,
++					REG_RMW_FIELD(ah, AR_PHY_TPC_19(ah),
+ 						      AR_PHY_TPC_19_ALPHA_THERM,
+ 						      eep->base_ext2.tempSlopeLow);
+ 				if (txmask & BIT(1))
+-					REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1,
++					REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1(ah),
+ 						      AR_PHY_TPC_19_ALPHA_THERM,
+ 						      temp_slope);
+ 				if (txmask & BIT(2))
+-					REG_RMW_FIELD(ah, AR_PHY_TPC_19_B2,
++					REG_RMW_FIELD(ah, AR_PHY_TPC_19_B2(ah),
+ 						      AR_PHY_TPC_19_ALPHA_THERM,
+ 						      eep->base_ext2.tempSlopeHigh);
+ 			} else {
+ 				if (txmask & BIT(0))
+-					REG_RMW_FIELD(ah, AR_PHY_TPC_19,
++					REG_RMW_FIELD(ah, AR_PHY_TPC_19(ah),
+ 						      AR_PHY_TPC_19_ALPHA_THERM,
+ 						      temp_slope);
+ 				if (txmask & BIT(1))
+-					REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1,
++					REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1(ah),
+ 						      AR_PHY_TPC_19_ALPHA_THERM,
+ 						      temp_slope1);
+ 				if (txmask & BIT(2))
+-					REG_RMW_FIELD(ah, AR_PHY_TPC_19_B2,
++					REG_RMW_FIELD(ah, AR_PHY_TPC_19_B2(ah),
+ 						      AR_PHY_TPC_19_ALPHA_THERM,
+ 						      temp_slope2);
+ 			}
+@@ -4930,26 +4930,26 @@ static void ar9003_hw_power_control_override(struct ath_hw *ah,
+ 			 * set all registers to 0.
+ 			 */
+ 			if (txmask & BIT(0))
+-				REG_RMW_FIELD(ah, AR_PHY_TPC_19,
++				REG_RMW_FIELD(ah, AR_PHY_TPC_19(ah),
+ 					      AR_PHY_TPC_19_ALPHA_THERM, 0);
+ 			if (txmask & BIT(1))
+-				REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1,
++				REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1(ah),
+ 					      AR_PHY_TPC_19_ALPHA_THERM, 0);
+ 			if (txmask & BIT(2))
+-				REG_RMW_FIELD(ah, AR_PHY_TPC_19_B2,
++				REG_RMW_FIELD(ah, AR_PHY_TPC_19_B2(ah),
+ 					      AR_PHY_TPC_19_ALPHA_THERM, 0);
+ 		}
+ 	} else {
+-		REG_RMW_FIELD(ah, AR_PHY_TPC_19,
++		REG_RMW_FIELD(ah, AR_PHY_TPC_19(ah),
+ 			      AR_PHY_TPC_19_ALPHA_THERM, temp_slope);
+ 	}
+ 
+ 	if (AR_SREV_9462_20_OR_LATER(ah))
+-		REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1,
++		REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1(ah),
+ 			      AR_PHY_TPC_19_B1_ALPHA_THERM, temp_slope);
+ 
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_TPC_18, AR_PHY_TPC_18_THERM_CAL_VALUE,
++	REG_RMW_FIELD(ah, AR_PHY_TPC_18(ah), AR_PHY_TPC_18_THERM_CAL_VALUE,
+ 		      temperature[0]);
+ }
+ 
+@@ -5540,19 +5540,19 @@ static void ath9k_hw_ar9300_set_txpower(struct ath_hw *ah,
+ 		ar9003_hw_init_rate_txpower(ah, targetPowerValT2_tpc, chan);
+ 
+ 		/* Enable TPC */
+-		REG_WRITE(ah, AR_PHY_PWRTX_MAX,
++		REG_WRITE(ah, AR_PHY_PWRTX_MAX(ah),
+ 			  AR_PHY_POWER_TX_RATE_MAX_TPC_ENABLE);
+ 		/* Disable per chain power reduction */
+-		val = REG_READ(ah, AR_PHY_POWER_TX_SUB);
++		val = REG_READ(ah, AR_PHY_POWER_TX_SUB(ah));
+ 		if (AR_SREV_9340(ah))
+-			REG_WRITE(ah, AR_PHY_POWER_TX_SUB,
++			REG_WRITE(ah, AR_PHY_POWER_TX_SUB(ah),
+ 				  val & 0xFFFFFFC0);
+ 		else
+-			REG_WRITE(ah, AR_PHY_POWER_TX_SUB,
++			REG_WRITE(ah, AR_PHY_POWER_TX_SUB(ah),
+ 				  val & 0xFFFFF000);
+ 	} else {
+ 		/* Disable TPC */
+-		REG_WRITE(ah, AR_PHY_PWRTX_MAX, 0);
++		REG_WRITE(ah, AR_PHY_PWRTX_MAX(ah), 0);
+ 	}
+ }
+ 
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_mci.c b/drivers/net/wireless/ath/ath9k/ar9003_mci.c
+index 2b9c07961c..fdde6fb979 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_mci.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_mci.c
+@@ -762,7 +762,7 @@ int ar9003_mci_end_reset(struct ath_hw *ah, struct ath9k_channel *chan,
+ 
+ 	mci_hw->bt_state = MCI_BT_AWAKE;
+ 
+-	REG_CLR_BIT(ah, AR_PHY_TIMING4,
++	REG_CLR_BIT(ah, AR_PHY_TIMING4(ah),
+ 		    1 << AR_PHY_TIMING_CONTROL4_DO_GAIN_DC_IQ_CAL_SHIFT);
+ 
+ 	if (caldata) {
+@@ -774,7 +774,7 @@ int ar9003_mci_end_reset(struct ath_hw *ah, struct ath9k_channel *chan,
+ 	if (!ath9k_hw_init_cal(ah, chan))
+ 		return -EIO;
+ 
+-	REG_SET_BIT(ah, AR_PHY_TIMING4,
++	REG_SET_BIT(ah, AR_PHY_TIMING4(ah),
+ 		    1 << AR_PHY_TIMING_CONTROL4_DO_GAIN_DC_IQ_CAL_SHIFT);
+ 
+ exit:
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_paprd.c b/drivers/net/wireless/ath/ath9k/ar9003_paprd.c
+index 83d993fff6..28192df046 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_paprd.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_paprd.c
+@@ -57,13 +57,13 @@ void ar9003_paprd_enable(struct ath_hw *ah, bool val)
+ 		ath9k_hw_apply_txpower(ah, chan, false);
+ 	}
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_PAPRD_CTRL0_B0,
++	REG_RMW_FIELD(ah, AR_PHY_PAPRD_CTRL0_B0(ah),
+ 		      AR_PHY_PAPRD_CTRL0_PAPRD_ENABLE, !!val);
+ 	if (ah->caps.tx_chainmask & BIT(1))
+-		REG_RMW_FIELD(ah, AR_PHY_PAPRD_CTRL0_B1,
++		REG_RMW_FIELD(ah, AR_PHY_PAPRD_CTRL0_B1(ah),
+ 			      AR_PHY_PAPRD_CTRL0_PAPRD_ENABLE, !!val);
+ 	if (ah->caps.tx_chainmask & BIT(2))
+-		REG_RMW_FIELD(ah, AR_PHY_PAPRD_CTRL0_B2,
++		REG_RMW_FIELD(ah, AR_PHY_PAPRD_CTRL0_B2(ah),
+ 			      AR_PHY_PAPRD_CTRL0_PAPRD_ENABLE, !!val);
+ }
+ EXPORT_SYMBOL(ar9003_paprd_enable);
+@@ -81,7 +81,7 @@ static int ar9003_get_training_power_2g(struct ath_hw *ah)
+ 	} else if (AR_SREV_9485(ah)) {
+ 		power = 25;
+ 	} else {
+-		power = REG_READ_FIELD(ah, AR_PHY_POWERTX_RATE5,
++		power = REG_READ_FIELD(ah, AR_PHY_POWERTX_RATE5(ah),
+ 				       AR_PHY_POWERTX_RATE5_POWERTXHT20_0);
+ 
+ 		delta = abs((int) ah->paprd_target_power - (int) power);
+@@ -104,10 +104,10 @@ static int ar9003_get_training_power_5g(struct ath_hw *ah)
+ 	scale = ar9003_get_paprd_scale_factor(ah, chan);
+ 
+ 	if (IS_CHAN_HT40(chan))
+-		power = REG_READ_FIELD(ah, AR_PHY_POWERTX_RATE8,
++		power = REG_READ_FIELD(ah, AR_PHY_POWERTX_RATE8(ah),
+ 			AR_PHY_POWERTX_RATE8_POWERTXHT40_5);
+ 	else
+-		power = REG_READ_FIELD(ah, AR_PHY_POWERTX_RATE6,
++		power = REG_READ_FIELD(ah, AR_PHY_POWERTX_RATE6(ah),
+ 			AR_PHY_POWERTX_RATE6_POWERTXHT20_5);
+ 
+ 	power += scale;
+@@ -139,14 +139,14 @@ static int ar9003_paprd_setup_single_table(struct ath_hw *ah)
+ {
+ 	struct ath_common *common = ath9k_hw_common(ah);
+ 	static const u32 ctrl0[3] = {
+-		AR_PHY_PAPRD_CTRL0_B0,
+-		AR_PHY_PAPRD_CTRL0_B1,
+-		AR_PHY_PAPRD_CTRL0_B2
++		AR_PHY_PAPRD_CTRL0_B0(ah),
++		AR_PHY_PAPRD_CTRL0_B1(ah),
++		AR_PHY_PAPRD_CTRL0_B2(ah)
+ 	};
+ 	static const u32 ctrl1[3] = {
+-		AR_PHY_PAPRD_CTRL1_B0,
+-		AR_PHY_PAPRD_CTRL1_B1,
+-		AR_PHY_PAPRD_CTRL1_B2
++		AR_PHY_PAPRD_CTRL1_B0(ah),
++		AR_PHY_PAPRD_CTRL1_B1(ah),
++		AR_PHY_PAPRD_CTRL1_B2(ah)
+ 	};
+ 	int training_power;
+ 	int i, val;
+@@ -170,11 +170,11 @@ static int ar9003_paprd_setup_single_table(struct ath_hw *ah)
+ 	if (AR_SREV_9330(ah))
+ 		am2pm_mask = 0;
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_PAPRD_AM2AM, AR_PHY_PAPRD_AM2AM_MASK,
++	REG_RMW_FIELD(ah, AR_PHY_PAPRD_AM2AM(ah), AR_PHY_PAPRD_AM2AM_MASK,
+ 		      ah->paprd_ratemask);
+-	REG_RMW_FIELD(ah, AR_PHY_PAPRD_AM2PM, AR_PHY_PAPRD_AM2PM_MASK,
++	REG_RMW_FIELD(ah, AR_PHY_PAPRD_AM2PM(ah), AR_PHY_PAPRD_AM2PM_MASK,
+ 		      am2pm_mask);
+-	REG_RMW_FIELD(ah, AR_PHY_PAPRD_HT40, AR_PHY_PAPRD_HT40_MASK,
++	REG_RMW_FIELD(ah, AR_PHY_PAPRD_HT40(ah), AR_PHY_PAPRD_HT40_MASK,
+ 		      ah->paprd_ratemask_ht40);
+ 
+ 	ath_dbg(common, CALIBRATE, "PAPRD HT20 mask: 0x%x, HT40 mask: 0x%x\n",
+@@ -269,21 +269,21 @@ static int ar9003_paprd_setup_single_table(struct ath_hw *ah)
+ 	REG_RMW_FIELD(ah, AR_PHY_PAPRD_TRAINER_CNTL4(ah),
+ 		      AR_PHY_PAPRD_TRAINER_CNTL4_CF_PAPRD_NUM_TRAIN_SAMPLES,
+ 		      100);
+-	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_0_B0,
++	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_0_B0(ah),
+ 		      AR_PHY_PAPRD_PRE_POST_SCALING, 261376);
+-	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_1_B0,
++	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_1_B0(ah),
+ 		      AR_PHY_PAPRD_PRE_POST_SCALING, 248079);
+-	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_2_B0,
++	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_2_B0(ah),
+ 		      AR_PHY_PAPRD_PRE_POST_SCALING, 233759);
+-	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_3_B0,
++	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_3_B0(ah),
+ 		      AR_PHY_PAPRD_PRE_POST_SCALING, 220464);
+-	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_4_B0,
++	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_4_B0(ah),
+ 		      AR_PHY_PAPRD_PRE_POST_SCALING, 208194);
+-	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_5_B0,
++	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_5_B0(ah),
+ 		      AR_PHY_PAPRD_PRE_POST_SCALING, 196949);
+-	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_6_B0,
++	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_6_B0(ah),
+ 		      AR_PHY_PAPRD_PRE_POST_SCALING, 185706);
+-	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_7_B0,
++	REG_RMW_FIELD(ah, AR_PHY_PAPRD_PRE_POST_SCALE_7_B0(ah),
+ 		      AR_PHY_PAPRD_PRE_POST_SCALING, 175487);
+ 	return 0;
+ }
+@@ -292,7 +292,7 @@ static void ar9003_paprd_get_gain_table(struct ath_hw *ah)
+ {
+ 	u32 *entry = ah->paprd_gain_table_entries;
+ 	u8 *index = ah->paprd_gain_table_index;
+-	u32 reg = AR_PHY_TXGAIN_TABLE;
++	u32 reg = AR_PHY_TXGAIN_TABLE(ah);
+ 	int i;
+ 
+ 	for (i = 0; i < PAPRD_GAIN_TABLE_ENTRIES; i++) {
+@@ -315,33 +315,33 @@ static unsigned int ar9003_get_desired_gain(struct ath_hw *ah, int chain,
+ 
+ 	REG_CLR_BIT(ah, AR_PHY_PAPRD_TRAINER_STAT1(ah),
+ 		    AR_PHY_PAPRD_TRAINER_STAT1_PAPRD_TRAIN_DONE);
+-	desired_scale = REG_READ_FIELD(ah, AR_PHY_TPC_12,
++	desired_scale = REG_READ_FIELD(ah, AR_PHY_TPC_12(ah),
+ 				       AR_PHY_TPC_12_DESIRED_SCALE_HT40_5);
+-	alpha_therm = REG_READ_FIELD(ah, AR_PHY_TPC_19,
++	alpha_therm = REG_READ_FIELD(ah, AR_PHY_TPC_19(ah),
+ 				     AR_PHY_TPC_19_ALPHA_THERM);
+-	alpha_volt = REG_READ_FIELD(ah, AR_PHY_TPC_19,
++	alpha_volt = REG_READ_FIELD(ah, AR_PHY_TPC_19(ah),
+ 				    AR_PHY_TPC_19_ALPHA_VOLT);
+-	therm_cal_value = REG_READ_FIELD(ah, AR_PHY_TPC_18,
++	therm_cal_value = REG_READ_FIELD(ah, AR_PHY_TPC_18(ah),
+ 					 AR_PHY_TPC_18_THERM_CAL_VALUE);
+-	volt_cal_value = REG_READ_FIELD(ah, AR_PHY_TPC_18,
++	volt_cal_value = REG_READ_FIELD(ah, AR_PHY_TPC_18(ah),
+ 					AR_PHY_TPC_18_VOLT_CAL_VALUE);
+-	therm_value = REG_READ_FIELD(ah, AR_PHY_BB_THERM_ADC_4,
++	therm_value = REG_READ_FIELD(ah, AR_PHY_BB_THERM_ADC_4(ah),
+ 				     AR_PHY_BB_THERM_ADC_4_LATEST_THERM_VALUE);
+-	volt_value = REG_READ_FIELD(ah, AR_PHY_BB_THERM_ADC_4,
++	volt_value = REG_READ_FIELD(ah, AR_PHY_BB_THERM_ADC_4(ah),
+ 				    AR_PHY_BB_THERM_ADC_4_LATEST_VOLT_VALUE);
+ 
+ 	switch (chain) {
+ 	case 0:
+-		reg_olpc = AR_PHY_TPC_11_B0;
+-		reg_cl_gain = AR_PHY_CL_TAB_0;
++		reg_olpc = AR_PHY_TPC_11_B0(ah);
++		reg_cl_gain = AR_PHY_CL_TAB_0(ah);
+ 		break;
+ 	case 1:
+-		reg_olpc = AR_PHY_TPC_11_B1;
+-		reg_cl_gain = AR_PHY_CL_TAB_1;
++		reg_olpc = AR_PHY_TPC_11_B1(ah);
++		reg_cl_gain = AR_PHY_CL_TAB_1(ah);
+ 		break;
+ 	case 2:
+-		reg_olpc = AR_PHY_TPC_11_B2;
+-		reg_cl_gain = AR_PHY_CL_TAB_2;
++		reg_olpc = AR_PHY_TPC_11_B2(ah);
++		reg_cl_gain = AR_PHY_CL_TAB_2(ah);
+ 		break;
+ 	default:
+ 		ath_dbg(ath9k_hw_common(ah), CALIBRATE,
+@@ -382,26 +382,26 @@ static void ar9003_tx_force_gain(struct ath_hw *ah, unsigned int gain_index)
+ 	padrvgnC = (selected_gain_entry >> 17) & 0xf;
+ 	padrvgnD = (selected_gain_entry >> 21) & 0x3;
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN,
++	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN(ah),
+ 		      AR_PHY_TX_FORCED_GAIN_FORCED_TXBB1DBGAIN, txbb1dbgain);
+-	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN,
++	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN(ah),
+ 		      AR_PHY_TX_FORCED_GAIN_FORCED_TXBB6DBGAIN, txbb6dbgain);
+-	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN,
++	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN(ah),
+ 		      AR_PHY_TX_FORCED_GAIN_FORCED_TXMXRGAIN, txmxrgain);
+-	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN,
++	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN(ah),
+ 		      AR_PHY_TX_FORCED_GAIN_FORCED_PADRVGNA, padrvgnA);
+-	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN,
++	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN(ah),
+ 		      AR_PHY_TX_FORCED_GAIN_FORCED_PADRVGNB, padrvgnB);
+-	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN,
++	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN(ah),
+ 		      AR_PHY_TX_FORCED_GAIN_FORCED_PADRVGNC, padrvgnC);
+-	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN,
++	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN(ah),
+ 		      AR_PHY_TX_FORCED_GAIN_FORCED_PADRVGND, padrvgnD);
+-	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN,
++	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN(ah),
+ 		      AR_PHY_TX_FORCED_GAIN_FORCED_ENABLE_PAL, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN,
++	REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN(ah),
+ 		      AR_PHY_TX_FORCED_GAIN_FORCE_TX_GAIN, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_TPC_1, AR_PHY_TPC_1_FORCED_DAC_GAIN, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_TPC_1, AR_PHY_TPC_1_FORCE_DAC_GAIN, 0);
++	REG_RMW_FIELD(ah, AR_PHY_TPC_1(ah), AR_PHY_TPC_1_FORCED_DAC_GAIN, 0);
++	REG_RMW_FIELD(ah, AR_PHY_TPC_1(ah), AR_PHY_TPC_1_FORCE_DAC_GAIN, 0);
+ }
+ 
+ static inline int find_expn(int num)
+@@ -759,11 +759,11 @@ void ar9003_paprd_populate_single_table(struct ath_hw *ah,
+ 	int i;
+ 
+ 	if (chain == 0)
+-		reg = AR_PHY_PAPRD_MEM_TAB_B0;
++		reg = AR_PHY_PAPRD_MEM_TAB_B0(ah);
+ 	else if (chain == 1)
+-		reg = AR_PHY_PAPRD_MEM_TAB_B1;
++		reg = AR_PHY_PAPRD_MEM_TAB_B1(ah);
+ 	else if (chain == 2)
+-		reg = AR_PHY_PAPRD_MEM_TAB_B2;
++		reg = AR_PHY_PAPRD_MEM_TAB_B2(ah);
+ 
+ 	for (i = 0; i < PAPRD_TABLE_SZ; i++) {
+ 		REG_WRITE(ah, reg, paprd_table_val[i]);
+@@ -771,26 +771,26 @@ void ar9003_paprd_populate_single_table(struct ath_hw *ah,
+ 	}
+ 
+ 	if (chain == 0)
+-		reg = AR_PHY_PA_GAIN123_B0;
++		reg = AR_PHY_PA_GAIN123_B0(ah);
+ 	else if (chain == 1)
+-		reg = AR_PHY_PA_GAIN123_B1;
++		reg = AR_PHY_PA_GAIN123_B1(ah);
+ 	else
+-		reg = AR_PHY_PA_GAIN123_B2;
++		reg = AR_PHY_PA_GAIN123_B2(ah);
+ 
+ 	REG_RMW_FIELD(ah, reg, AR_PHY_PA_GAIN123_PA_GAIN1, small_signal_gain);
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_PAPRD_CTRL1_B0,
++	REG_RMW_FIELD(ah, AR_PHY_PAPRD_CTRL1_B0(ah),
+ 		      AR_PHY_PAPRD_CTRL1_PAPRD_POWER_AT_AM2AM_CAL,
+ 		      training_power);
+ 
+ 	if (ah->caps.tx_chainmask & BIT(1))
+-		REG_RMW_FIELD(ah, AR_PHY_PAPRD_CTRL1_B1,
++		REG_RMW_FIELD(ah, AR_PHY_PAPRD_CTRL1_B1(ah),
+ 			      AR_PHY_PAPRD_CTRL1_PAPRD_POWER_AT_AM2AM_CAL,
+ 			      training_power);
+ 
+ 	if (ah->caps.tx_chainmask & BIT(2))
+ 		/* val AR_PHY_PAPRD_CTRL1_PAPRD_POWER_AT_AM2AM_CAL correct? */
+-		REG_RMW_FIELD(ah, AR_PHY_PAPRD_CTRL1_B2,
++		REG_RMW_FIELD(ah, AR_PHY_PAPRD_CTRL1_B2(ah),
+ 			      AR_PHY_PAPRD_CTRL1_PAPRD_POWER_AT_AM2AM_CAL,
+ 			      training_power);
+ }
+@@ -935,7 +935,7 @@ int ar9003_paprd_create_curve(struct ath_hw *ah,
+ 	REG_CLR_BIT(ah, AR_PHY_CHAN_INFO_MEMORY(ah),
+ 		    AR_PHY_CHAN_INFO_MEMORY_CHANINFOMEM_S2_READ);
+ 
+-	reg = AR_PHY_CHAN_INFO_TAB_0;
++	reg = AR_PHY_CHAN_INFO_TAB_0(ah);
+ 	for (i = 0; i < 48; i++)
+ 		data_L[i] = REG_READ(ah, reg + (i << 2));
+ 
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_phy.c b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
+index a29c11f944..7944d12f2e 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
+@@ -203,7 +203,7 @@ static int ar9003_hw_set_channel(struct ath_hw *ah, struct ath9k_channel *chan)
+ 	loadSynthChannel = 0;
+ 
+ 	reg32 = (bMode << 29);
+-	REG_WRITE(ah, AR_PHY_SYNTH_CONTROL, reg32);
++	REG_WRITE(ah, AR_PHY_SYNTH_CONTROL(ah), reg32);
+ 
+ 	/* Enable Long shift Select for Synthesizer */
+ 	REG_RMW_FIELD(ah, AR_PHY_65NM_CH0_SYNTH4,
+@@ -256,7 +256,7 @@ static void ar9003_hw_spur_mitigate_mrc_cck(struct ath_hw *ah,
+ 		max_spur_cnts = 5;
+ 		if (IS_CHAN_HT40(chan)) {
+ 			range = 19;
+-			if (REG_READ_FIELD(ah, AR_PHY_GEN_CTRL,
++			if (REG_READ_FIELD(ah, AR_PHY_GEN_CTRL(ah),
+ 					   AR_PHY_GC_DYN2040_PRI_CH) == 0)
+ 				synth_freq = chan->channel + 10;
+ 			else
+@@ -298,15 +298,15 @@ static void ar9003_hw_spur_mitigate_mrc_cck(struct ath_hw *ah,
+ 
+ 			REG_RMW_FIELD(ah, AR_PHY_AGC_CONTROL(ah),
+ 				      AR_PHY_AGC_CONTROL_YCOK_MAX, 0x7);
+-			REG_RMW_FIELD(ah, AR_PHY_CCK_SPUR_MIT,
++			REG_RMW_FIELD(ah, AR_PHY_CCK_SPUR_MIT(ah),
+ 				      AR_PHY_CCK_SPUR_MIT_SPUR_RSSI_THR, 0x7f);
+-			REG_RMW_FIELD(ah, AR_PHY_CCK_SPUR_MIT,
++			REG_RMW_FIELD(ah, AR_PHY_CCK_SPUR_MIT(ah),
+ 				      AR_PHY_CCK_SPUR_MIT_SPUR_FILTER_TYPE,
+ 				      0x2);
+-			REG_RMW_FIELD(ah, AR_PHY_CCK_SPUR_MIT,
++			REG_RMW_FIELD(ah, AR_PHY_CCK_SPUR_MIT(ah),
+ 				      AR_PHY_CCK_SPUR_MIT_USE_CCK_SPUR_MIT,
+ 				      0x1);
+-			REG_RMW_FIELD(ah, AR_PHY_CCK_SPUR_MIT,
++			REG_RMW_FIELD(ah, AR_PHY_CCK_SPUR_MIT(ah),
+ 				      AR_PHY_CCK_SPUR_MIT_CCK_SPUR_FREQ,
+ 				      cck_spur_freq);
+ 
+@@ -316,53 +316,53 @@ static void ar9003_hw_spur_mitigate_mrc_cck(struct ath_hw *ah,
+ 
+ 	REG_RMW_FIELD(ah, AR_PHY_AGC_CONTROL(ah),
+ 		      AR_PHY_AGC_CONTROL_YCOK_MAX, 0x5);
+-	REG_RMW_FIELD(ah, AR_PHY_CCK_SPUR_MIT,
++	REG_RMW_FIELD(ah, AR_PHY_CCK_SPUR_MIT(ah),
+ 		      AR_PHY_CCK_SPUR_MIT_USE_CCK_SPUR_MIT, 0x0);
+-	REG_RMW_FIELD(ah, AR_PHY_CCK_SPUR_MIT,
++	REG_RMW_FIELD(ah, AR_PHY_CCK_SPUR_MIT(ah),
+ 		      AR_PHY_CCK_SPUR_MIT_CCK_SPUR_FREQ, 0x0);
+ }
+ 
+ /* Clean all spur register fields */
+ static void ar9003_hw_spur_ofdm_clear(struct ath_hw *ah)
+ {
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING4,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING4(ah),
+ 		      AR_PHY_TIMING4_ENABLE_SPUR_FILTER, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING11,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING11(ah),
+ 		      AR_PHY_TIMING11_SPUR_FREQ_SD, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING11,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING11(ah),
+ 		      AR_PHY_TIMING11_SPUR_DELTA_PHASE, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
++	REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT(ah),
+ 		      AR_PHY_SFCORR_EXT_SPUR_SUBCHANNEL_SD, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING11,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING11(ah),
+ 		      AR_PHY_TIMING11_USE_SPUR_FILTER_IN_AGC, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING11,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING11(ah),
+ 		      AR_PHY_TIMING11_USE_SPUR_FILTER_IN_SELFCOR, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING4,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING4(ah),
+ 		      AR_PHY_TIMING4_ENABLE_SPUR_RSSI, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG,
++	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG(ah),
+ 		      AR_PHY_SPUR_REG_EN_VIT_SPUR_RSSI, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG,
++	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG(ah),
+ 		      AR_PHY_SPUR_REG_ENABLE_NF_RSSI_SPUR_MIT, 0);
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG,
++	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG(ah),
+ 		      AR_PHY_SPUR_REG_ENABLE_MASK_PPM, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING4,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING4(ah),
+ 		      AR_PHY_TIMING4_ENABLE_PILOT_MASK, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING4,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING4(ah),
+ 		      AR_PHY_TIMING4_ENABLE_CHAN_MASK, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_PILOT_SPUR_MASK,
++	REG_RMW_FIELD(ah, AR_PHY_PILOT_SPUR_MASK(ah),
+ 		      AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_IDX_A, 0);
+ 	REG_RMW_FIELD(ah, AR_PHY_SPUR_MASK_A(ah),
+ 		      AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_IDX_A, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_CHAN_SPUR_MASK,
++	REG_RMW_FIELD(ah, AR_PHY_CHAN_SPUR_MASK(ah),
+ 		      AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_IDX_A, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_PILOT_SPUR_MASK,
++	REG_RMW_FIELD(ah, AR_PHY_PILOT_SPUR_MASK(ah),
+ 		      AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_A, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_CHAN_SPUR_MASK,
++	REG_RMW_FIELD(ah, AR_PHY_CHAN_SPUR_MASK(ah),
+ 		      AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_A, 0);
+ 	REG_RMW_FIELD(ah, AR_PHY_SPUR_MASK_A(ah),
+ 		      AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_A, 0);
+-	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG,
++	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG(ah),
+ 		      AR_PHY_SPUR_REG_MASK_RATE_CNTL, 0);
+ }
+ 
+@@ -377,32 +377,32 @@ static void ar9003_hw_spur_ofdm(struct ath_hw *ah,
+ 	int mask_index = 0;
+ 
+ 	/* OFDM Spur mitigation */
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING4,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING4(ah),
+ 		 AR_PHY_TIMING4_ENABLE_SPUR_FILTER, 0x1);
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING11,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING11(ah),
+ 		      AR_PHY_TIMING11_SPUR_FREQ_SD, spur_freq_sd);
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING11,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING11(ah),
+ 		      AR_PHY_TIMING11_SPUR_DELTA_PHASE, spur_delta_phase);
+-	REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
++	REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT(ah),
+ 		      AR_PHY_SFCORR_EXT_SPUR_SUBCHANNEL_SD, spur_subchannel_sd);
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING11,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING11(ah),
+ 		      AR_PHY_TIMING11_USE_SPUR_FILTER_IN_AGC, 0x1);
+ 
+ 	if (!(AR_SREV_9565(ah) && range == 10 && synth_freq == 2437))
+-		REG_RMW_FIELD(ah, AR_PHY_TIMING11,
++		REG_RMW_FIELD(ah, AR_PHY_TIMING11(ah),
+ 			      AR_PHY_TIMING11_USE_SPUR_FILTER_IN_SELFCOR, 0x1);
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING4,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING4(ah),
+ 		      AR_PHY_TIMING4_ENABLE_SPUR_RSSI, 0x1);
+-	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG,
++	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG(ah),
+ 		      AR_PHY_SPUR_REG_SPUR_RSSI_THRESH, 34);
+-	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG,
++	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG(ah),
+ 		      AR_PHY_SPUR_REG_EN_VIT_SPUR_RSSI, 1);
+ 
+ 	if (!AR_SREV_9340(ah) &&
+-	    REG_READ_FIELD(ah, AR_PHY_MODE,
++	    REG_READ_FIELD(ah, AR_PHY_MODE(ah),
+ 			   AR_PHY_MODE_DYNAMIC) == 0x1)
+-		REG_RMW_FIELD(ah, AR_PHY_SPUR_REG,
++		REG_RMW_FIELD(ah, AR_PHY_SPUR_REG(ah),
+ 			      AR_PHY_SPUR_REG_ENABLE_NF_RSSI_SPUR_MIT, 1);
+ 
+ 	mask_index = (freq_offset << 4) / 5;
+@@ -411,25 +411,25 @@ static void ar9003_hw_spur_ofdm(struct ath_hw *ah,
+ 
+ 	mask_index = mask_index & 0x7f;
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG,
++	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG(ah),
+ 		      AR_PHY_SPUR_REG_ENABLE_MASK_PPM, 0x1);
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING4,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING4(ah),
+ 		      AR_PHY_TIMING4_ENABLE_PILOT_MASK, 0x1);
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING4,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING4(ah),
+ 		      AR_PHY_TIMING4_ENABLE_CHAN_MASK, 0x1);
+-	REG_RMW_FIELD(ah, AR_PHY_PILOT_SPUR_MASK,
++	REG_RMW_FIELD(ah, AR_PHY_PILOT_SPUR_MASK(ah),
+ 		      AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_IDX_A, mask_index);
+ 	REG_RMW_FIELD(ah, AR_PHY_SPUR_MASK_A(ah),
+ 		      AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_IDX_A, mask_index);
+-	REG_RMW_FIELD(ah, AR_PHY_CHAN_SPUR_MASK,
++	REG_RMW_FIELD(ah, AR_PHY_CHAN_SPUR_MASK(ah),
+ 		      AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_IDX_A, mask_index);
+-	REG_RMW_FIELD(ah, AR_PHY_PILOT_SPUR_MASK,
++	REG_RMW_FIELD(ah, AR_PHY_PILOT_SPUR_MASK(ah),
+ 		      AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_A, 0xc);
+-	REG_RMW_FIELD(ah, AR_PHY_CHAN_SPUR_MASK,
++	REG_RMW_FIELD(ah, AR_PHY_CHAN_SPUR_MASK(ah),
+ 		      AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_A, 0xc);
+ 	REG_RMW_FIELD(ah, AR_PHY_SPUR_MASK_A(ah),
+ 		      AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_A, 0xa0);
+-	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG,
++	REG_RMW_FIELD(ah, AR_PHY_SPUR_REG(ah),
+ 		      AR_PHY_SPUR_REG_MASK_RATE_CNTL, 0xff);
+ }
+ 
+@@ -444,7 +444,7 @@ static void ar9003_hw_spur_ofdm_9565(struct ath_hw *ah,
+ 
+ 	mask_index = mask_index & 0x7f;
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_PILOT_SPUR_MASK,
++	REG_RMW_FIELD(ah, AR_PHY_PILOT_SPUR_MASK(ah),
+ 		      AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_IDX_B,
+ 		      mask_index);
+ 
+@@ -453,12 +453,12 @@ static void ar9003_hw_spur_ofdm_9565(struct ath_hw *ah,
+ 		      AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_IDX_A,
+ 		      mask_index);
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_CHAN_SPUR_MASK,
++	REG_RMW_FIELD(ah, AR_PHY_CHAN_SPUR_MASK(ah),
+ 		      AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_IDX_B,
+ 		      mask_index);
+-	REG_RMW_FIELD(ah, AR_PHY_PILOT_SPUR_MASK,
++	REG_RMW_FIELD(ah, AR_PHY_PILOT_SPUR_MASK(ah),
+ 		      AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_B, 0xe);
+-	REG_RMW_FIELD(ah, AR_PHY_CHAN_SPUR_MASK,
++	REG_RMW_FIELD(ah, AR_PHY_CHAN_SPUR_MASK(ah),
+ 		      AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_B, 0xe);
+ 
+ 	/* A == B */
+@@ -478,7 +478,7 @@ static void ar9003_hw_spur_ofdm_work(struct ath_hw *ah,
+ 
+ 	if (IS_CHAN_HT40(chan)) {
+ 		if (freq_offset < 0) {
+-			if (REG_READ_FIELD(ah, AR_PHY_GEN_CTRL,
++			if (REG_READ_FIELD(ah, AR_PHY_GEN_CTRL(ah),
+ 					   AR_PHY_GC_DYN2040_PRI_CH) == 0x0)
+ 				spur_subchannel_sd = 1;
+ 			else
+@@ -487,7 +487,7 @@ static void ar9003_hw_spur_ofdm_work(struct ath_hw *ah,
+ 			spur_freq_sd = ((freq_offset + 10) << 9) / 11;
+ 
+ 		} else {
+-			if (REG_READ_FIELD(ah, AR_PHY_GEN_CTRL,
++			if (REG_READ_FIELD(ah, AR_PHY_GEN_CTRL(ah),
+ 			    AR_PHY_GC_DYN2040_PRI_CH) == 0x0)
+ 				spur_subchannel_sd = 0;
+ 			else
+@@ -531,7 +531,7 @@ static void ar9003_hw_spur_mitigate_ofdm(struct ath_hw *ah,
+ 
+ 	if (IS_CHAN_HT40(chan)) {
+ 		range = 19;
+-		if (REG_READ_FIELD(ah, AR_PHY_GEN_CTRL,
++		if (REG_READ_FIELD(ah, AR_PHY_GEN_CTRL(ah),
+ 				   AR_PHY_GC_DYN2040_PRI_CH) == 0x0)
+ 			synth_freq = chan->channel - 10;
+ 		else
+@@ -614,7 +614,7 @@ static void ar9003_hw_set_channel_regs(struct ath_hw *ah,
+ 	u32 enableDacFifo = 0;
+ 
+ 	enableDacFifo =
+-		(REG_READ(ah, AR_PHY_GEN_CTRL) & AR_PHY_GC_ENABLE_DAC_FIFO);
++		(REG_READ(ah, AR_PHY_GEN_CTRL(ah)) & AR_PHY_GC_ENABLE_DAC_FIFO);
+ 
+ 	/* Enable 11n HT, 20 MHz */
+ 	phymode = AR_PHY_GC_HT_EN | AR_PHY_GC_SHORT_GI_40 | enableDacFifo;
+@@ -632,11 +632,11 @@ static void ar9003_hw_set_channel_regs(struct ath_hw *ah,
+ 	}
+ 
+ 	/* make sure we preserve INI settings */
+-	phymode |= REG_READ(ah, AR_PHY_GEN_CTRL);
++	phymode |= REG_READ(ah, AR_PHY_GEN_CTRL(ah));
+ 	/* turn off Green Field detection for STA for now */
+ 	phymode &= ~AR_PHY_GC_GF_DETECT_EN;
+ 
+-	REG_WRITE(ah, AR_PHY_GEN_CTRL, phymode);
++	REG_WRITE(ah, AR_PHY_GEN_CTRL(ah), phymode);
+ 
+ 	/* Configure MAC for 20/40 operation */
+ 	ath9k_hw_set11nmac2040(ah, chan);
+@@ -657,21 +657,21 @@ static void ar9003_hw_init_bb(struct ath_hw *ah,
+ 	 * via AR_PHY_ACTIVE_EN).  Read the phy active delay register.
+ 	 * Value is in 100ns increments.
+ 	 */
+-	synthDelay = REG_READ(ah, AR_PHY_RX_DELAY) & AR_PHY_RX_DELAY_DELAY;
++	synthDelay = REG_READ(ah, AR_PHY_RX_DELAY(ah)) & AR_PHY_RX_DELAY_DELAY;
+ 
+ 	/* Activate the PHY (includes baseband activate + synthesizer on) */
+-	REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
++	REG_WRITE(ah, AR_PHY_ACTIVE(ah), AR_PHY_ACTIVE_EN);
+ 	ath9k_hw_synth_delay(ah, chan, synthDelay);
+ }
+ 
+ void ar9003_hw_set_chain_masks(struct ath_hw *ah, u8 rx, u8 tx)
+ {
+ 	if (ah->caps.tx_chainmask == 5 || ah->caps.rx_chainmask == 5)
+-		REG_SET_BIT(ah, AR_PHY_ANALOG_SWAP,
++		REG_SET_BIT(ah, AR_PHY_ANALOG_SWAP(ah),
+ 			    AR_PHY_SWAP_ALT_CHAIN);
+ 
+-	REG_WRITE(ah, AR_PHY_RX_CHAINMASK, rx);
+-	REG_WRITE(ah, AR_PHY_CAL_CHAINMASK, rx);
++	REG_WRITE(ah, AR_PHY_RX_CHAINMASK(ah), rx);
++	REG_WRITE(ah, AR_PHY_CAL_CHAINMASK(ah), rx);
+ 
+ 	if ((ah->caps.hw_caps & ATH9K_HW_CAP_APM) && (tx == 0x7))
+ 		tx = 3;
+@@ -718,7 +718,7 @@ static void ar9003_hw_override_ini(struct ath_hw *ah)
+ 
+ 	}
+ 
+-	if (REG_READ(ah, AR_PHY_CL_CAL_CTL) & AR_PHY_CL_CAL_ENABLE)
++	if (REG_READ(ah, AR_PHY_CL_CAL_CTL(ah)) & AR_PHY_CL_CAL_ENABLE)
+ 		ah->enabled_cals |= TX_CL_CAL;
+ 	else
+ 		ah->enabled_cals &= ~TX_CL_CAL;
+@@ -954,7 +954,7 @@ static int ar9003_hw_process_ini(struct ath_hw *ah,
+ 		ar9003_hw_prog_ini(ah, &ah->iniCckfirJapan2484, 1);
+ 
+ 		if (AR_SREV_9531(ah))
+-			REG_RMW_FIELD(ah, AR_PHY_FCAL_2_0,
++			REG_RMW_FIELD(ah, AR_PHY_FCAL_2_0(ah),
+ 				      AR_PHY_FLC_PWR_THRESH, 0);
+ 	}
+ 
+@@ -984,15 +984,15 @@ static void ar9003_hw_set_rfmode(struct ath_hw *ah,
+ 		rfMode |= (AR_PHY_MODE_DYNAMIC | AR_PHY_MODE_DYN_CCK_DISABLE);
+ 
+ 	if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan))
+-		REG_RMW_FIELD(ah, AR_PHY_FRAME_CTL,
++		REG_RMW_FIELD(ah, AR_PHY_FRAME_CTL(ah),
+ 			      AR_PHY_FRAME_CTL_CF_OVERLAP_WINDOW, 3);
+ 
+-	REG_WRITE(ah, AR_PHY_MODE, rfMode);
++	REG_WRITE(ah, AR_PHY_MODE(ah), rfMode);
+ }
+ 
+ static void ar9003_hw_mark_phy_inactive(struct ath_hw *ah)
+ {
+-	REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_DIS);
++	REG_WRITE(ah, AR_PHY_ACTIVE(ah), AR_PHY_ACTIVE_DIS);
+ }
+ 
+ static void ar9003_hw_set_delta_slope(struct ath_hw *ah,
+@@ -1021,9 +1021,9 @@ static void ar9003_hw_set_delta_slope(struct ath_hw *ah,
+ 	ath9k_hw_get_delta_slope_vals(ah, coef_scaled, &ds_coef_man,
+ 				      &ds_coef_exp);
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING3,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING3(ah),
+ 		      AR_PHY_TIMING3_DSC_MAN, ds_coef_man);
+-	REG_RMW_FIELD(ah, AR_PHY_TIMING3,
++	REG_RMW_FIELD(ah, AR_PHY_TIMING3(ah),
+ 		      AR_PHY_TIMING3_DSC_EXP, ds_coef_exp);
+ 
+ 	/*
+@@ -1036,16 +1036,16 @@ static void ar9003_hw_set_delta_slope(struct ath_hw *ah,
+ 				      &ds_coef_exp);
+ 
+ 	/* for short gi */
+-	REG_RMW_FIELD(ah, AR_PHY_SGI_DELTA,
++	REG_RMW_FIELD(ah, AR_PHY_SGI_DELTA(ah),
+ 		      AR_PHY_SGI_DSC_MAN, ds_coef_man);
+-	REG_RMW_FIELD(ah, AR_PHY_SGI_DELTA,
++	REG_RMW_FIELD(ah, AR_PHY_SGI_DELTA(ah),
+ 		      AR_PHY_SGI_DSC_EXP, ds_coef_exp);
+ }
+ 
+ static bool ar9003_hw_rfbus_req(struct ath_hw *ah)
+ {
+-	REG_WRITE(ah, AR_PHY_RFBUS_REQ, AR_PHY_RFBUS_REQ_EN);
+-	return ath9k_hw_wait(ah, AR_PHY_RFBUS_GRANT, AR_PHY_RFBUS_GRANT_EN,
++	REG_WRITE(ah, AR_PHY_RFBUS_REQ(ah), AR_PHY_RFBUS_REQ_EN);
++	return ath9k_hw_wait(ah, AR_PHY_RFBUS_GRANT(ah), AR_PHY_RFBUS_GRANT_EN,
+ 			     AR_PHY_RFBUS_GRANT_EN, AH_WAIT_TIMEOUT);
+ }
+ 
+@@ -1055,11 +1055,11 @@ static bool ar9003_hw_rfbus_req(struct ath_hw *ah)
+  */
+ static void ar9003_hw_rfbus_done(struct ath_hw *ah)
+ {
+-	u32 synthDelay = REG_READ(ah, AR_PHY_RX_DELAY) & AR_PHY_RX_DELAY_DELAY;
++	u32 synthDelay = REG_READ(ah, AR_PHY_RX_DELAY(ah)) & AR_PHY_RX_DELAY_DELAY;
+ 
+ 	ath9k_hw_synth_delay(ah, ah->curchan, synthDelay);
+ 
+-	REG_WRITE(ah, AR_PHY_RFBUS_REQ, 0);
++	REG_WRITE(ah, AR_PHY_RFBUS_REQ(ah), 0);
+ }
+ 
+ static bool ar9003_hw_ani_control(struct ath_hw *ah,
+@@ -1110,42 +1110,42 @@ static bool ar9003_hw_ani_control(struct ath_hw *ah,
+ 		m2ThreshExt = on ?
+ 			aniState->iniDef.m2ThreshExt : m2ThreshExt_off;
+ 
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
++		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW(ah),
+ 			      AR_PHY_SFCORR_LOW_M1_THRESH_LOW,
+ 			      m1ThreshLow);
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
++		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW(ah),
+ 			      AR_PHY_SFCORR_LOW_M2_THRESH_LOW,
+ 			      m2ThreshLow);
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
++		REG_RMW_FIELD(ah, AR_PHY_SFCORR(ah),
+ 			      AR_PHY_SFCORR_M1_THRESH,
+ 			      m1Thresh);
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
++		REG_RMW_FIELD(ah, AR_PHY_SFCORR(ah),
+ 			      AR_PHY_SFCORR_M2_THRESH,
+ 			      m2Thresh);
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
++		REG_RMW_FIELD(ah, AR_PHY_SFCORR(ah),
+ 			      AR_PHY_SFCORR_M2COUNT_THR,
+ 			      m2CountThr);
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
++		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW(ah),
+ 			      AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW,
+ 			      m2CountThrLow);
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
++		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT(ah),
+ 			      AR_PHY_SFCORR_EXT_M1_THRESH_LOW,
+ 			      m1ThreshLowExt);
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
++		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT(ah),
+ 			      AR_PHY_SFCORR_EXT_M2_THRESH_LOW,
+ 			      m2ThreshLowExt);
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
++		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT(ah),
+ 			      AR_PHY_SFCORR_EXT_M1_THRESH,
+ 			      m1ThreshExt);
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
++		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT(ah),
+ 			      AR_PHY_SFCORR_EXT_M2_THRESH,
+ 			      m2ThreshExt);
+ skip_ws_det:
+ 		if (on)
+-			REG_SET_BIT(ah, AR_PHY_SFCORR_LOW,
++			REG_SET_BIT(ah, AR_PHY_SFCORR_LOW(ah),
+ 				    AR_PHY_SFCORR_LOW_USE_SELF_CORR_LOW);
+ 		else
+-			REG_CLR_BIT(ah, AR_PHY_SFCORR_LOW,
++			REG_CLR_BIT(ah, AR_PHY_SFCORR_LOW(ah),
+ 				    AR_PHY_SFCORR_LOW_USE_SELF_CORR_LOW);
+ 
+ 		if (on != aniState->ofdmWeakSigDetect) {
+@@ -1184,7 +1184,7 @@ static bool ar9003_hw_ani_control(struct ath_hw *ah,
+ 			value = ATH9K_SIG_FIRSTEP_SETTING_MIN;
+ 		if (value > ATH9K_SIG_FIRSTEP_SETTING_MAX)
+ 			value = ATH9K_SIG_FIRSTEP_SETTING_MAX;
+-		REG_RMW_FIELD(ah, AR_PHY_FIND_SIG,
++		REG_RMW_FIELD(ah, AR_PHY_FIND_SIG(ah),
+ 			      AR_PHY_FIND_SIG_FIRSTEP,
+ 			      value);
+ 		/*
+@@ -1200,7 +1200,7 @@ static bool ar9003_hw_ani_control(struct ath_hw *ah,
+ 		if (value2 > ATH9K_SIG_FIRSTEP_SETTING_MAX)
+ 			value2 = ATH9K_SIG_FIRSTEP_SETTING_MAX;
+ 
+-		REG_RMW_FIELD(ah, AR_PHY_FIND_SIG_LOW,
++		REG_RMW_FIELD(ah, AR_PHY_FIND_SIG_LOW(ah),
+ 			      AR_PHY_FIND_SIG_LOW_FIRSTEP_LOW, value2);
+ 
+ 		if (level != aniState->firstepLevel) {
+@@ -1248,12 +1248,12 @@ static bool ar9003_hw_ani_control(struct ath_hw *ah,
+ 			value = ATH9K_SIG_SPUR_IMM_SETTING_MIN;
+ 		if (value > ATH9K_SIG_SPUR_IMM_SETTING_MAX)
+ 			value = ATH9K_SIG_SPUR_IMM_SETTING_MAX;
+-		REG_RMW_FIELD(ah, AR_PHY_TIMING5,
++		REG_RMW_FIELD(ah, AR_PHY_TIMING5(ah),
+ 			      AR_PHY_TIMING5_CYCPWR_THR1,
+ 			      value);
+ 
+ 		/*
+-		 * set AR_PHY_EXT_CCA for extension channel
++		 * set AR_PHY_EXT_CCA(ah) for extension channel
+ 		 * make register setting relative to default
+ 		 * from INI file & cap value
+ 		 */
+@@ -1264,7 +1264,7 @@ static bool ar9003_hw_ani_control(struct ath_hw *ah,
+ 			value2 = ATH9K_SIG_SPUR_IMM_SETTING_MIN;
+ 		if (value2 > ATH9K_SIG_SPUR_IMM_SETTING_MAX)
+ 			value2 = ATH9K_SIG_SPUR_IMM_SETTING_MAX;
+-		REG_RMW_FIELD(ah, AR_PHY_EXT_CCA,
++		REG_RMW_FIELD(ah, AR_PHY_EXT_CCA(ah),
+ 			      AR_PHY_EXT_CYCPWR_THR1, value2);
+ 
+ 		if (level != aniState->spurImmunityLevel) {
+@@ -1302,9 +1302,9 @@ static bool ar9003_hw_ani_control(struct ath_hw *ah,
+ 		if (ah->caps.rx_chainmask == 1)
+ 			break;
+ 
+-		REG_RMW_FIELD(ah, AR_PHY_MRC_CCK_CTRL,
++		REG_RMW_FIELD(ah, AR_PHY_MRC_CCK_CTRL(ah),
+ 			      AR_PHY_MRC_CCK_ENABLE, is_on);
+-		REG_RMW_FIELD(ah, AR_PHY_MRC_CCK_CTRL,
++		REG_RMW_FIELD(ah, AR_PHY_MRC_CCK_CTRL(ah),
+ 			      AR_PHY_MRC_CCK_MUX_REG, is_on);
+ 		if (is_on != aniState->mrcCCK) {
+ 			ath_dbg(common, ANI, "** ch %d: MRC CCK: %s=>%s\n",
+@@ -1406,32 +1406,32 @@ static void ar9003_hw_ani_cache_ini_regs(struct ath_hw *ah)
+ 		ah->opmode,
+ 		chan->channel);
+ 
+-	val = REG_READ(ah, AR_PHY_SFCORR);
++	val = REG_READ(ah, AR_PHY_SFCORR(ah));
+ 	iniDef->m1Thresh = MS(val, AR_PHY_SFCORR_M1_THRESH);
+ 	iniDef->m2Thresh = MS(val, AR_PHY_SFCORR_M2_THRESH);
+ 	iniDef->m2CountThr = MS(val, AR_PHY_SFCORR_M2COUNT_THR);
+ 
+-	val = REG_READ(ah, AR_PHY_SFCORR_LOW);
++	val = REG_READ(ah, AR_PHY_SFCORR_LOW(ah));
+ 	iniDef->m1ThreshLow = MS(val, AR_PHY_SFCORR_LOW_M1_THRESH_LOW);
+ 	iniDef->m2ThreshLow = MS(val, AR_PHY_SFCORR_LOW_M2_THRESH_LOW);
+ 	iniDef->m2CountThrLow = MS(val, AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW);
+ 
+-	val = REG_READ(ah, AR_PHY_SFCORR_EXT);
++	val = REG_READ(ah, AR_PHY_SFCORR_EXT(ah));
+ 	iniDef->m1ThreshExt = MS(val, AR_PHY_SFCORR_EXT_M1_THRESH);
+ 	iniDef->m2ThreshExt = MS(val, AR_PHY_SFCORR_EXT_M2_THRESH);
+ 	iniDef->m1ThreshLowExt = MS(val, AR_PHY_SFCORR_EXT_M1_THRESH_LOW);
+ 	iniDef->m2ThreshLowExt = MS(val, AR_PHY_SFCORR_EXT_M2_THRESH_LOW);
+ 	iniDef->firstep = REG_READ_FIELD(ah,
+-					 AR_PHY_FIND_SIG,
++					 AR_PHY_FIND_SIG(ah),
+ 					 AR_PHY_FIND_SIG_FIRSTEP);
+ 	iniDef->firstepLow = REG_READ_FIELD(ah,
+-					    AR_PHY_FIND_SIG_LOW,
++					    AR_PHY_FIND_SIG_LOW(ah),
+ 					    AR_PHY_FIND_SIG_LOW_FIRSTEP_LOW);
+ 	iniDef->cycpwrThr1 = REG_READ_FIELD(ah,
+-					    AR_PHY_TIMING5,
++					    AR_PHY_TIMING5(ah),
+ 					    AR_PHY_TIMING5_CYCPWR_THR1);
+ 	iniDef->cycpwrThr1Ext = REG_READ_FIELD(ah,
+-					       AR_PHY_EXT_CCA,
++					       AR_PHY_EXT_CCA(ah),
+ 					       AR_PHY_EXT_CYCPWR_THR1);
+ 
+ 	/* these levels just got reset to defaults by the INI */
+@@ -1448,7 +1448,7 @@ static void ar9003_hw_set_radar_params(struct ath_hw *ah,
+ 	u32 radar_0 = 0, radar_1;
+ 
+ 	if (!conf) {
+-		REG_CLR_BIT(ah, AR_PHY_RADAR_0, AR_PHY_RADAR_0_ENA);
++		REG_CLR_BIT(ah, AR_PHY_RADAR_0(ah), AR_PHY_RADAR_0_ENA);
+ 		return;
+ 	}
+ 
+@@ -1459,7 +1459,7 @@ static void ar9003_hw_set_radar_params(struct ath_hw *ah,
+ 	radar_0 |= SM(conf->pulse_rssi, AR_PHY_RADAR_0_PRSSI);
+ 	radar_0 |= SM(conf->pulse_inband, AR_PHY_RADAR_0_INBAND);
+ 
+-	radar_1 = REG_READ(ah, AR_PHY_RADAR_1);
++	radar_1 = REG_READ(ah, AR_PHY_RADAR_1(ah));
+ 	radar_1 &= ~(AR_PHY_RADAR_1_MAXLEN | AR_PHY_RADAR_1_RELSTEP_THRESH |
+ 		     AR_PHY_RADAR_1_RELPWR_THRESH);
+ 	radar_1 |= AR_PHY_RADAR_1_MAX_RRSSI;
+@@ -1468,12 +1468,12 @@ static void ar9003_hw_set_radar_params(struct ath_hw *ah,
+ 	radar_1 |= SM(conf->pulse_inband_step, AR_PHY_RADAR_1_RELSTEP_THRESH);
+ 	radar_1 |= SM(conf->radar_inband, AR_PHY_RADAR_1_RELPWR_THRESH);
+ 
+-	REG_WRITE(ah, AR_PHY_RADAR_0, radar_0);
+-	REG_WRITE(ah, AR_PHY_RADAR_1, radar_1);
++	REG_WRITE(ah, AR_PHY_RADAR_0(ah), radar_0);
++	REG_WRITE(ah, AR_PHY_RADAR_1(ah), radar_1);
+ 	if (conf->ext_channel)
+-		REG_SET_BIT(ah, AR_PHY_RADAR_EXT, AR_PHY_RADAR_EXT_ENA);
++		REG_SET_BIT(ah, AR_PHY_RADAR_EXT(ah), AR_PHY_RADAR_EXT_ENA);
+ 	else
+-		REG_CLR_BIT(ah, AR_PHY_RADAR_EXT, AR_PHY_RADAR_EXT_ENA);
++		REG_CLR_BIT(ah, AR_PHY_RADAR_EXT(ah), AR_PHY_RADAR_EXT_ENA);
+ 
+ 	if (AR_SREV_9300(ah) || AR_SREV_9340(ah) || AR_SREV_9580(ah)) {
+ 		REG_WRITE_ARRAY(&ah->ini_dfs,
+@@ -1500,7 +1500,7 @@ static void ar9003_hw_antdiv_comb_conf_get(struct ath_hw *ah,
+ {
+ 	u32 regval;
+ 
+-	regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL);
++	regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL(ah));
+ 	antconf->main_lna_conf = (regval & AR_PHY_ANT_DIV_MAIN_LNACONF) >>
+ 				  AR_PHY_ANT_DIV_MAIN_LNACONF_S;
+ 	antconf->alt_lna_conf = (regval & AR_PHY_ANT_DIV_ALT_LNACONF) >>
+@@ -1532,7 +1532,7 @@ static void ar9003_hw_antdiv_comb_conf_set(struct ath_hw *ah,
+ {
+ 	u32 regval;
+ 
+-	regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL);
++	regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL(ah));
+ 	regval &= ~(AR_PHY_ANT_DIV_MAIN_LNACONF |
+ 		    AR_PHY_ANT_DIV_ALT_LNACONF |
+ 		    AR_PHY_ANT_FAST_DIV_BIAS |
+@@ -1549,7 +1549,7 @@ static void ar9003_hw_antdiv_comb_conf_set(struct ath_hw *ah,
+ 	regval |= ((antconf->alt_gaintb << AR_PHY_ANT_DIV_ALT_GAINTB_S)
+ 		   & AR_PHY_ANT_DIV_ALT_GAINTB);
+ 
+-	REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
++	REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL(ah), regval);
+ }
+ 
+ #ifdef CPTCFG_ATH9K_BTCOEX_SUPPORT
+@@ -1570,7 +1570,7 @@ static void ar9003_hw_set_bt_ant_diversity(struct ath_hw *ah, bool enable)
+ 			regval &= ~AR_SWITCH_TABLE_COM2_ALL;
+ 			regval |= ah->config.ant_ctrl_comm2g_switch_enable;
+ 		}
+-		REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM_2,
++		REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM_2(ah),
+ 			      AR_SWITCH_TABLE_COM2_ALL, regval);
+ 	}
+ 
+@@ -1580,36 +1580,36 @@ static void ar9003_hw_set_bt_ant_diversity(struct ath_hw *ah, bool enable)
+ 	 * Set MAIN/ALT LNA conf.
+ 	 * Set MAIN/ALT gain_tb.
+ 	 */
+-	regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL);
++	regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL(ah));
+ 	regval &= (~AR_ANT_DIV_CTRL_ALL);
+ 	regval |= (ant_div_ctl1 & 0x3f) << AR_ANT_DIV_CTRL_ALL_S;
+-	REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
++	REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL(ah), regval);
+ 
+ 	if (AR_SREV_9485_11_OR_LATER(ah)) {
+ 		/*
+ 		 * Enable LNA diversity.
+ 		 */
+-		regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL);
++		regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL(ah));
+ 		regval &= ~AR_PHY_ANT_DIV_LNADIV;
+ 		regval |= ((ant_div_ctl1 >> 6) & 0x1) << AR_PHY_ANT_DIV_LNADIV_S;
+ 		if (enable)
+ 			regval |= AR_ANT_DIV_ENABLE;
+ 
+-		REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
++		REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL(ah), regval);
+ 
+ 		/*
+ 		 * Enable fast antenna diversity.
+ 		 */
+-		regval = REG_READ(ah, AR_PHY_CCK_DETECT);
++		regval = REG_READ(ah, AR_PHY_CCK_DETECT(ah));
+ 		regval &= ~AR_FAST_DIV_ENABLE;
+ 		regval |= ((ant_div_ctl1 >> 7) & 0x1) << AR_FAST_DIV_ENABLE_S;
+ 		if (enable)
+ 			regval |= AR_FAST_DIV_ENABLE;
+ 
+-		REG_WRITE(ah, AR_PHY_CCK_DETECT, regval);
++		REG_WRITE(ah, AR_PHY_CCK_DETECT(ah), regval);
+ 
+ 		if (pCap->hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB) {
+-			regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL);
++			regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL(ah));
+ 			regval &= (~(AR_PHY_ANT_DIV_MAIN_LNACONF |
+ 				     AR_PHY_ANT_DIV_ALT_LNACONF |
+ 				     AR_PHY_ANT_DIV_ALT_GAINTB |
+@@ -1622,33 +1622,33 @@ static void ar9003_hw_set_bt_ant_diversity(struct ath_hw *ah, bool enable)
+ 				   AR_PHY_ANT_DIV_MAIN_LNACONF_S);
+ 			regval |= (ATH_ANT_DIV_COMB_LNA2 <<
+ 				   AR_PHY_ANT_DIV_ALT_LNACONF_S);
+-			REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
++			REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL(ah), regval);
+ 		}
+ 	} else if (AR_SREV_9565(ah)) {
+ 		if (enable) {
+-			REG_SET_BIT(ah, AR_PHY_MC_GAIN_CTRL,
++			REG_SET_BIT(ah, AR_PHY_MC_GAIN_CTRL(ah),
+ 				    AR_ANT_DIV_ENABLE);
+-			REG_SET_BIT(ah, AR_PHY_MC_GAIN_CTRL,
++			REG_SET_BIT(ah, AR_PHY_MC_GAIN_CTRL(ah),
+ 				    (1 << AR_PHY_ANT_SW_RX_PROT_S));
+-			REG_SET_BIT(ah, AR_PHY_CCK_DETECT,
++			REG_SET_BIT(ah, AR_PHY_CCK_DETECT(ah),
+ 				    AR_FAST_DIV_ENABLE);
+-			REG_SET_BIT(ah, AR_PHY_RESTART,
++			REG_SET_BIT(ah, AR_PHY_RESTART(ah),
+ 				    AR_PHY_RESTART_ENABLE_DIV_M2FLAG);
+ 			REG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV,
+ 				    AR_BTCOEX_WL_LNADIV_FORCE_ON);
+ 		} else {
+-			REG_CLR_BIT(ah, AR_PHY_MC_GAIN_CTRL,
++			REG_CLR_BIT(ah, AR_PHY_MC_GAIN_CTRL(ah),
+ 				    AR_ANT_DIV_ENABLE);
+-			REG_CLR_BIT(ah, AR_PHY_MC_GAIN_CTRL,
++			REG_CLR_BIT(ah, AR_PHY_MC_GAIN_CTRL(ah),
+ 				    (1 << AR_PHY_ANT_SW_RX_PROT_S));
+-			REG_CLR_BIT(ah, AR_PHY_CCK_DETECT,
++			REG_CLR_BIT(ah, AR_PHY_CCK_DETECT(ah),
+ 				    AR_FAST_DIV_ENABLE);
+-			REG_CLR_BIT(ah, AR_PHY_RESTART,
++			REG_CLR_BIT(ah, AR_PHY_RESTART(ah),
+ 				    AR_PHY_RESTART_ENABLE_DIV_M2FLAG);
+ 			REG_CLR_BIT(ah, AR_BTCOEX_WL_LNADIV,
+ 				    AR_BTCOEX_WL_LNADIV_FORCE_ON);
+ 
+-			regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL);
++			regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL(ah));
+ 			regval &= ~(AR_PHY_ANT_DIV_MAIN_LNACONF |
+ 				    AR_PHY_ANT_DIV_ALT_LNACONF |
+ 				    AR_PHY_ANT_DIV_MAIN_GAINTB |
+@@ -1657,7 +1657,7 @@ static void ar9003_hw_set_bt_ant_diversity(struct ath_hw *ah, bool enable)
+ 				   AR_PHY_ANT_DIV_MAIN_LNACONF_S);
+ 			regval |= (ATH_ANT_DIV_COMB_LNA2 <<
+ 				   AR_PHY_ANT_DIV_ALT_LNACONF_S);
+-			REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
++			REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL(ah), regval);
+ 		}
+ 	}
+ }
+@@ -1736,13 +1736,13 @@ static void ar9003_hw_spectral_scan_config(struct ath_hw *ah,
+ 	u8 count;
+ 
+ 	if (!param->enabled) {
+-		REG_CLR_BIT(ah, AR_PHY_SPECTRAL_SCAN,
++		REG_CLR_BIT(ah, AR_PHY_SPECTRAL_SCAN(ah),
+ 			    AR_PHY_SPECTRAL_SCAN_ENABLE);
+ 		return;
+ 	}
+ 
+-	REG_SET_BIT(ah, AR_PHY_RADAR_0, AR_PHY_RADAR_0_FFT_ENA);
+-	REG_SET_BIT(ah, AR_PHY_SPECTRAL_SCAN, AR_PHY_SPECTRAL_SCAN_ENABLE);
++	REG_SET_BIT(ah, AR_PHY_RADAR_0(ah), AR_PHY_RADAR_0_FFT_ENA);
++	REG_SET_BIT(ah, AR_PHY_SPECTRAL_SCAN(ah), AR_PHY_SPECTRAL_SCAN_ENABLE);
+ 
+ 	/* on AR93xx and newer, count = 0 will make the chip send
+ 	 * spectral samples endlessly. Check if this really was intended,
+@@ -1755,17 +1755,17 @@ static void ar9003_hw_spectral_scan_config(struct ath_hw *ah,
+ 		count = 1;
+ 
+ 	if (param->short_repeat)
+-		REG_SET_BIT(ah, AR_PHY_SPECTRAL_SCAN,
++		REG_SET_BIT(ah, AR_PHY_SPECTRAL_SCAN(ah),
+ 			    AR_PHY_SPECTRAL_SCAN_SHORT_REPEAT);
+ 	else
+-		REG_CLR_BIT(ah, AR_PHY_SPECTRAL_SCAN,
++		REG_CLR_BIT(ah, AR_PHY_SPECTRAL_SCAN(ah),
+ 			    AR_PHY_SPECTRAL_SCAN_SHORT_REPEAT);
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_SPECTRAL_SCAN,
++	REG_RMW_FIELD(ah, AR_PHY_SPECTRAL_SCAN(ah),
+ 		      AR_PHY_SPECTRAL_SCAN_COUNT, count);
+-	REG_RMW_FIELD(ah, AR_PHY_SPECTRAL_SCAN,
++	REG_RMW_FIELD(ah, AR_PHY_SPECTRAL_SCAN(ah),
+ 		      AR_PHY_SPECTRAL_SCAN_PERIOD, param->period);
+-	REG_RMW_FIELD(ah, AR_PHY_SPECTRAL_SCAN,
++	REG_RMW_FIELD(ah, AR_PHY_SPECTRAL_SCAN(ah),
+ 		      AR_PHY_SPECTRAL_SCAN_FFT_PERIOD, param->fft_period);
+ 
+ 	return;
+@@ -1773,10 +1773,10 @@ static void ar9003_hw_spectral_scan_config(struct ath_hw *ah,
+ 
+ static void ar9003_hw_spectral_scan_trigger(struct ath_hw *ah)
+ {
+-	REG_SET_BIT(ah, AR_PHY_SPECTRAL_SCAN,
++	REG_SET_BIT(ah, AR_PHY_SPECTRAL_SCAN(ah),
+ 		    AR_PHY_SPECTRAL_SCAN_ENABLE);
+ 	/* Activate spectral scan */
+-	REG_SET_BIT(ah, AR_PHY_SPECTRAL_SCAN,
++	REG_SET_BIT(ah, AR_PHY_SPECTRAL_SCAN(ah),
+ 		    AR_PHY_SPECTRAL_SCAN_ACTIVE);
+ }
+ 
+@@ -1785,7 +1785,7 @@ static void ar9003_hw_spectral_scan_wait(struct ath_hw *ah)
+ 	struct ath_common *common = ath9k_hw_common(ah);
+ 
+ 	/* Poll for spectral scan complete */
+-	if (!ath9k_hw_wait(ah, AR_PHY_SPECTRAL_SCAN,
++	if (!ath9k_hw_wait(ah, AR_PHY_SPECTRAL_SCAN(ah),
+ 			   AR_PHY_SPECTRAL_SCAN_ACTIVE,
+ 			   0, AH_WAIT_TIMEOUT)) {
+ 		ath_err(common, "spectral scan wait failed\n");
+@@ -1923,12 +1923,12 @@ void ar9003_hw_attach_phy_ops(struct ath_hw *ah)
+ 	struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
+ 	struct ath_hw_ops *ops = ath9k_hw_ops(ah);
+ 	static const u32 ar9300_cca_regs[6] = {
+-		AR_PHY_CCA_0,
+-		AR_PHY_CCA_1,
+-		AR_PHY_CCA_2,
+-		AR_PHY_EXT_CCA,
+-		AR_PHY_EXT_CCA_1,
+-		AR_PHY_EXT_CCA_2,
++		AR_PHY_CCA_0(ah),
++		AR_PHY_CCA_1(ah),
++		AR_PHY_CCA_2(ah),
++		AR_PHY_EXT_CCA(ah),
++		AR_PHY_EXT_CCA_1(ah),
++		AR_PHY_EXT_CCA_2(ah),
+ 	};
+ 
+ 	priv_ops->rf_set_freq = ar9003_hw_set_channel;
+@@ -2004,15 +2004,15 @@ bool ar9003_hw_bb_watchdog_check(struct ath_hw *ah)
+ 
+ 	switch(ah->bb_watchdog_last_status) {
+ 	case 0x04000539:
+-		val = REG_READ(ah, AR_PHY_RADAR_0);
++		val = REG_READ(ah, AR_PHY_RADAR_0(ah));
+ 		val &= (~AR_PHY_RADAR_0_FIRPWR);
+ 		val |= SM(0x7f, AR_PHY_RADAR_0_FIRPWR);
+-		REG_WRITE(ah, AR_PHY_RADAR_0, val);
++		REG_WRITE(ah, AR_PHY_RADAR_0(ah), val);
+ 		udelay(1);
+-		val = REG_READ(ah, AR_PHY_RADAR_0);
++		val = REG_READ(ah, AR_PHY_RADAR_0(ah));
+ 		val &= ~AR_PHY_RADAR_0_FIRPWR;
+ 		val |= SM(AR9300_DFS_FIRPWR, AR_PHY_RADAR_0_FIRPWR);
+-		REG_WRITE(ah, AR_PHY_RADAR_0, val);
++		REG_WRITE(ah, AR_PHY_RADAR_0(ah), val);
+ 
+ 		return false;
+ 	case 0x1300000a:
+@@ -2043,14 +2043,14 @@ void ar9003_hw_bb_watchdog_config(struct ath_hw *ah)
+ 
+ 	if (!idle_tmo_ms) {
+ 		/* disable IRQ, disable chip-reset for BB panic */
+-		REG_WRITE(ah, AR_PHY_WATCHDOG_CTL_2,
+-			  REG_READ(ah, AR_PHY_WATCHDOG_CTL_2) &
++		REG_WRITE(ah, AR_PHY_WATCHDOG_CTL_2(ah),
++			  REG_READ(ah, AR_PHY_WATCHDOG_CTL_2(ah)) &
+ 			  ~(AR_PHY_WATCHDOG_RST_ENABLE |
+ 			    AR_PHY_WATCHDOG_IRQ_ENABLE));
+ 
+ 		/* disable watchdog in non-IDLE mode, disable in IDLE mode */
+-		REG_WRITE(ah, AR_PHY_WATCHDOG_CTL_1,
+-			  REG_READ(ah, AR_PHY_WATCHDOG_CTL_1) &
++		REG_WRITE(ah, AR_PHY_WATCHDOG_CTL_1(ah),
++			  REG_READ(ah, AR_PHY_WATCHDOG_CTL_1(ah)) &
+ 			  ~(AR_PHY_WATCHDOG_NON_IDLE_ENABLE |
+ 			    AR_PHY_WATCHDOG_IDLE_ENABLE));
+ 
+@@ -2059,8 +2059,8 @@ void ar9003_hw_bb_watchdog_config(struct ath_hw *ah)
+ 	}
+ 
+ 	/* enable IRQ, disable chip-reset for BB watchdog */
+-	val = REG_READ(ah, AR_PHY_WATCHDOG_CTL_2) & AR_PHY_WATCHDOG_CNTL2_MASK;
+-	REG_WRITE(ah, AR_PHY_WATCHDOG_CTL_2,
++	val = REG_READ(ah, AR_PHY_WATCHDOG_CTL_2(ah)) & AR_PHY_WATCHDOG_CNTL2_MASK;
++	REG_WRITE(ah, AR_PHY_WATCHDOG_CTL_2(ah),
+ 		  (val | AR_PHY_WATCHDOG_IRQ_ENABLE) &
+ 		  ~AR_PHY_WATCHDOG_RST_ENABLE);
+ 
+@@ -2085,7 +2085,7 @@ void ar9003_hw_bb_watchdog_config(struct ath_hw *ah)
+ 	 * enable watchdog in non-IDLE mode, disable in IDLE mode,
+ 	 * set idle time-out.
+ 	 */
+-	REG_WRITE(ah, AR_PHY_WATCHDOG_CTL_1,
++	REG_WRITE(ah, AR_PHY_WATCHDOG_CTL_1(ah),
+ 		  AR_PHY_WATCHDOG_NON_IDLE_ENABLE |
+ 		  AR_PHY_WATCHDOG_IDLE_MASK |
+ 		  (AR_PHY_WATCHDOG_NON_IDLE_MASK & (idle_count << 2)));
+@@ -2100,13 +2100,13 @@ void ar9003_hw_bb_watchdog_read(struct ath_hw *ah)
+ 	 * we want to avoid printing in ISR context so we save the
+ 	 * watchdog status to be printed later in bottom half context.
+ 	 */
+-	ah->bb_watchdog_last_status = REG_READ(ah, AR_PHY_WATCHDOG_STATUS);
++	ah->bb_watchdog_last_status = REG_READ(ah, AR_PHY_WATCHDOG_STATUS(ah));
+ 
+ 	/*
+ 	 * the watchdog timer should reset on status read but to be sure
+ 	 * sure we write 0 to the watchdog status bit.
+ 	 */
+-	REG_WRITE(ah, AR_PHY_WATCHDOG_STATUS,
++	REG_WRITE(ah, AR_PHY_WATCHDOG_STATUS(ah),
+ 		  ah->bb_watchdog_last_status & ~AR_PHY_WATCHDOG_STATUS_CLR);
+ }
+ 
+@@ -2134,10 +2134,10 @@ void ar9003_hw_bb_watchdog_dbg_info(struct ath_hw *ah)
+ 		MS(status, AR_PHY_WATCHDOG_SRCH_SM));
+ 
+ 	ath_dbg(common, RESET, "** BB WD cntl: cntl1=0x%08x cntl2=0x%08x **\n",
+-		REG_READ(ah, AR_PHY_WATCHDOG_CTL_1),
+-		REG_READ(ah, AR_PHY_WATCHDOG_CTL_2));
++		REG_READ(ah, AR_PHY_WATCHDOG_CTL_1(ah)),
++		REG_READ(ah, AR_PHY_WATCHDOG_CTL_2(ah)));
+ 	ath_dbg(common, RESET, "** BB mode: BB_gen_controls=0x%08x **\n",
+-		REG_READ(ah, AR_PHY_GEN_CTRL));
++		REG_READ(ah, AR_PHY_GEN_CTRL(ah)));
+ 
+ #define PCT(_field) (common->cc_survey._field * 100 / common->cc_survey.cycles)
+ 	if (common->cc_survey.cycles)
+@@ -2163,9 +2163,9 @@ void ar9003_hw_disable_phy_restart(struct ath_hw *ah)
+ 
+ 	if ((result == 0xb) || ah->bb_hang_rx_ofdm) {
+ 		ah->bb_hang_rx_ofdm = true;
+-		val = REG_READ(ah, AR_PHY_RESTART);
++		val = REG_READ(ah, AR_PHY_RESTART(ah));
+ 		val &= ~AR_PHY_RESTART_ENA;
+-		REG_WRITE(ah, AR_PHY_RESTART, val);
++		REG_WRITE(ah, AR_PHY_RESTART(ah), val);
+ 	}
+ }
+ EXPORT_SYMBOL(ar9003_hw_disable_phy_restart);
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_phy.h b/drivers/net/wireless/ath/ath9k/ar9003_phy.h
+index ad72a30b67..ce7c398b8c 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.h
++++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.h
+@@ -20,18 +20,18 @@
+ /*
+  * Channel Register Map
+  */
+-#define AR_CHAN_BASE	0x9800
+-
+-#define AR_PHY_TIMING1      (AR_CHAN_BASE + 0x0)
+-#define AR_PHY_TIMING2      (AR_CHAN_BASE + 0x4)
+-#define AR_PHY_TIMING3      (AR_CHAN_BASE + 0x8)
+-#define AR_PHY_TIMING4      (AR_CHAN_BASE + 0xc)
+-#define AR_PHY_TIMING5      (AR_CHAN_BASE + 0x10)
+-#define AR_PHY_TIMING6      (AR_CHAN_BASE + 0x14)
+-#define AR_PHY_TIMING11     (AR_CHAN_BASE + 0x18)
+-#define AR_PHY_SPUR_REG     (AR_CHAN_BASE + 0x1c)
+-#define AR_PHY_RX_IQCAL_CORR_B0    (AR_CHAN_BASE + 0xdc)
+-#define AR_PHY_TX_IQCAL_CONTROL_3  (AR_CHAN_BASE + 0xb0)
++#define AR_CHAN_BASE(_ah)	0x9800
++
++#define AR_PHY_TIMING1(_ah)      (AR_CHAN_BASE(_ah) + 0x0)
++#define AR_PHY_TIMING2(_ah)      (AR_CHAN_BASE(_ah) + 0x4)
++#define AR_PHY_TIMING3(_ah)      (AR_CHAN_BASE(_ah) + 0x8)
++#define AR_PHY_TIMING4(_ah)      (AR_CHAN_BASE(_ah) + 0xc)
++#define AR_PHY_TIMING5(_ah)      (AR_CHAN_BASE(_ah) + 0x10)
++#define AR_PHY_TIMING6(_ah)      (AR_CHAN_BASE(_ah) + 0x14)
++#define AR_PHY_TIMING11(_ah)     (AR_CHAN_BASE(_ah) + 0x18)
++#define AR_PHY_SPUR_REG(_ah)     (AR_CHAN_BASE(_ah) + 0x1c)
++#define AR_PHY_RX_IQCAL_CORR_B0(_ah)    (AR_CHAN_BASE(_ah) + 0xdc)
++#define AR_PHY_TX_IQCAL_CONTROL_3(_ah)  (AR_CHAN_BASE(_ah) + 0xb0)
+ #define AR_PHY_TIMING_CONTROL4_DO_GAIN_DC_IQ_CAL_SHIFT 16
+ 
+ #define AR_PHY_TIMING11_SPUR_FREQ_SD    0x3FF00000
+@@ -64,38 +64,38 @@
+ #define AR_PHY_TX_IQCAL_CONTROL_3_IQCORR_EN   0x80000000
+ #define AR_PHY_TX_IQCAL_CONTROL_3_IQCORR_EN_S         31
+ 
+-#define AR_PHY_FIND_SIG_LOW  (AR_CHAN_BASE + 0x20)
++#define AR_PHY_FIND_SIG_LOW(_ah)  (AR_CHAN_BASE(_ah) + 0x20)
+ 
+-#define AR_PHY_SFCORR           (AR_CHAN_BASE + 0x24)
+-#define AR_PHY_SFCORR_LOW       (AR_CHAN_BASE + 0x28)
+-#define AR_PHY_SFCORR_EXT       (AR_CHAN_BASE + 0x2c)
++#define AR_PHY_SFCORR(_ah)           (AR_CHAN_BASE(_ah) + 0x24)
++#define AR_PHY_SFCORR_LOW(_ah)       (AR_CHAN_BASE(_ah) + 0x28)
++#define AR_PHY_SFCORR_EXT(_ah)       (AR_CHAN_BASE(_ah) + 0x2c)
+ 
+-#define AR_PHY_EXT_CCA              (AR_CHAN_BASE + 0x30)
+-#define AR_PHY_RADAR_0              (AR_CHAN_BASE + 0x34)
+-#define AR_PHY_RADAR_1              (AR_CHAN_BASE + 0x38)
+-#define AR_PHY_RADAR_EXT            (AR_CHAN_BASE + 0x3c)
+-#define AR_PHY_MULTICHAIN_CTRL      (AR_CHAN_BASE + 0x80)
+-#define AR_PHY_PERCHAIN_CSD         (AR_CHAN_BASE + 0x84)
++#define AR_PHY_EXT_CCA(_ah)              (AR_CHAN_BASE(_ah) + 0x30)
++#define AR_PHY_RADAR_0(_ah)              (AR_CHAN_BASE(_ah) + 0x34)
++#define AR_PHY_RADAR_1(_ah)              (AR_CHAN_BASE(_ah) + 0x38)
++#define AR_PHY_RADAR_EXT(_ah)            (AR_CHAN_BASE(_ah) + 0x3c)
++#define AR_PHY_MULTICHAIN_CTRL(_ah)      (AR_CHAN_BASE(_ah) + 0x80)
++#define AR_PHY_PERCHAIN_CSD(_ah)         (AR_CHAN_BASE(_ah) + 0x84)
+ 
+-#define AR_PHY_TX_PHASE_RAMP_0      (AR_CHAN_BASE + 0xd0)
+-#define AR_PHY_ADC_GAIN_DC_CORR_0   (AR_CHAN_BASE + 0xd4)
+-#define AR_PHY_IQ_ADC_MEAS_0_B0     (AR_CHAN_BASE + 0xc0)
+-#define AR_PHY_IQ_ADC_MEAS_1_B0     (AR_CHAN_BASE + 0xc4)
+-#define AR_PHY_IQ_ADC_MEAS_2_B0     (AR_CHAN_BASE + 0xc8)
+-#define AR_PHY_IQ_ADC_MEAS_3_B0     (AR_CHAN_BASE + 0xcc)
++#define AR_PHY_TX_PHASE_RAMP_0(_ah)      (AR_CHAN_BASE(_ah) + 0xd0)
++#define AR_PHY_ADC_GAIN_DC_CORR_0(_ah)   (AR_CHAN_BASE(_ah) + 0xd4)
++#define AR_PHY_IQ_ADC_MEAS_0_B0(_ah)     (AR_CHAN_BASE(_ah) + 0xc0)
++#define AR_PHY_IQ_ADC_MEAS_1_B0(_ah)     (AR_CHAN_BASE(_ah) + 0xc4)
++#define AR_PHY_IQ_ADC_MEAS_2_B0(_ah)     (AR_CHAN_BASE(_ah) + 0xc8)
++#define AR_PHY_IQ_ADC_MEAS_3_B0(_ah)     (AR_CHAN_BASE(_ah) + 0xcc)
+ 
+ /* The following registers changed position from AR9300 1.0 to AR9300 2.0 */
+-#define AR_PHY_TX_PHASE_RAMP_0_9300_10      (AR_CHAN_BASE + 0xd0 - 0x10)
+-#define AR_PHY_ADC_GAIN_DC_CORR_0_9300_10   (AR_CHAN_BASE + 0xd4 - 0x10)
+-#define AR_PHY_IQ_ADC_MEAS_0_B0_9300_10     (AR_CHAN_BASE + 0xc0 + 0x8)
+-#define AR_PHY_IQ_ADC_MEAS_1_B0_9300_10     (AR_CHAN_BASE + 0xc4 + 0x8)
+-#define AR_PHY_IQ_ADC_MEAS_2_B0_9300_10     (AR_CHAN_BASE + 0xc8 + 0x8)
+-#define AR_PHY_IQ_ADC_MEAS_3_B0_9300_10     (AR_CHAN_BASE + 0xcc + 0x8)
+-
+-#define AR_PHY_TX_CRC               (AR_CHAN_BASE + 0xa0)
+-#define AR_PHY_TST_DAC_CONST        (AR_CHAN_BASE + 0xa4)
+-#define AR_PHY_SPUR_REPORT_0        (AR_CHAN_BASE + 0xa8)
+-#define AR_PHY_CHAN_INFO_TAB_0      (AR_CHAN_BASE + 0x300)
++#define AR_PHY_TX_PHASE_RAMP_0_9300_10(_ah)      (AR_CHAN_BASE(_ah) + 0xd0 - 0x10)
++#define AR_PHY_ADC_GAIN_DC_CORR_0_9300_10(_ah)   (AR_CHAN_BASE(_ah) + 0xd4 - 0x10)
++#define AR_PHY_IQ_ADC_MEAS_0_B0_9300_10(_ah)     (AR_CHAN_BASE(_ah) + 0xc0 + 0x8)
++#define AR_PHY_IQ_ADC_MEAS_1_B0_9300_10(_ah)     (AR_CHAN_BASE(_ah) + 0xc4 + 0x8)
++#define AR_PHY_IQ_ADC_MEAS_2_B0_9300_10(_ah)     (AR_CHAN_BASE(_ah) + 0xc8 + 0x8)
++#define AR_PHY_IQ_ADC_MEAS_3_B0_9300_10(_ah)     (AR_CHAN_BASE(_ah) + 0xcc + 0x8)
++
++#define AR_PHY_TX_CRC(_ah)               (AR_CHAN_BASE(_ah) + 0xa0)
++#define AR_PHY_TST_DAC_CONST(_ah)        (AR_CHAN_BASE(_ah) + 0xa4)
++#define AR_PHY_SPUR_REPORT_0(_ah)        (AR_CHAN_BASE(_ah) + 0xa8)
++#define AR_PHY_CHAN_INFO_TAB_0(_ah)      (AR_CHAN_BASE(_ah) + 0x300)
+ 
+ /*
+  * Channel Field Definitions
+@@ -214,17 +214,17 @@
+ /*
+  * MRC Register Map
+  */
+-#define AR_MRC_BASE	0x9c00
+-
+-#define AR_PHY_TIMING_3A       (AR_MRC_BASE + 0x0)
+-#define AR_PHY_LDPC_CNTL1      (AR_MRC_BASE + 0x4)
+-#define AR_PHY_LDPC_CNTL2      (AR_MRC_BASE + 0x8)
+-#define AR_PHY_PILOT_SPUR_MASK (AR_MRC_BASE + 0xc)
+-#define AR_PHY_CHAN_SPUR_MASK  (AR_MRC_BASE + 0x10)
+-#define AR_PHY_SGI_DELTA       (AR_MRC_BASE + 0x14)
+-#define AR_PHY_ML_CNTL_1       (AR_MRC_BASE + 0x18)
+-#define AR_PHY_ML_CNTL_2       (AR_MRC_BASE + 0x1c)
+-#define AR_PHY_TST_ADC         (AR_MRC_BASE + 0x20)
++#define AR_MRC_BASE(_ah)	0x9c00
++
++#define AR_PHY_TIMING_3A(_ah)       (AR_MRC_BASE(_ah) + 0x0)
++#define AR_PHY_LDPC_CNTL1(_ah)      (AR_MRC_BASE(_ah) + 0x4)
++#define AR_PHY_LDPC_CNTL2(_ah)      (AR_MRC_BASE(_ah) + 0x8)
++#define AR_PHY_PILOT_SPUR_MASK(_ah) (AR_MRC_BASE(_ah) + 0xc)
++#define AR_PHY_CHAN_SPUR_MASK(_ah)  (AR_MRC_BASE(_ah) + 0x10)
++#define AR_PHY_SGI_DELTA(_ah)       (AR_MRC_BASE(_ah) + 0x14)
++#define AR_PHY_ML_CNTL_1(_ah)       (AR_MRC_BASE(_ah) + 0x18)
++#define AR_PHY_ML_CNTL_2(_ah)       (AR_MRC_BASE(_ah) + 0x1c)
++#define AR_PHY_TST_ADC(_ah)         (AR_MRC_BASE(_ah) + 0x20)
+ 
+ #define AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_IDX_A      0x00000FE0
+ #define AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_IDX_A_S    5
+@@ -255,28 +255,28 @@
+ /*
+  * BBB Register Map
+  */
+-#define AR_BBB_BASE	0x9d00
++#define AR_BBB_BASE(_ah)	0x9d00
+ 
+ /*
+  * AGC Register Map
+  */
+-#define AR_AGC_BASE	0x9e00
+-
+-#define AR_PHY_SETTLING         (AR_AGC_BASE + 0x0)
+-#define AR_PHY_FORCEMAX_GAINS_0 (AR_AGC_BASE + 0x4)
+-#define AR_PHY_GAINS_MINOFF0    (AR_AGC_BASE + 0x8)
+-#define AR_PHY_DESIRED_SZ       (AR_AGC_BASE + 0xc)
+-#define AR_PHY_FIND_SIG         (AR_AGC_BASE + 0x10)
+-#define AR_PHY_AGC              (AR_AGC_BASE + 0x14)
+-#define AR_PHY_EXT_ATTEN_CTL_0  (AR_AGC_BASE + 0x18)
+-#define AR_PHY_CCA_0            (AR_AGC_BASE + 0x1c)
+-#define AR_PHY_CCA_CTRL_0       (AR_AGC_BASE + 0x20)
+-#define AR_PHY_RESTART          (AR_AGC_BASE + 0x24)
++#define AR_AGC_BASE(_ah)	0x9e00
++
++#define AR_PHY_SETTLING(_ah)         (AR_AGC_BASE(_ah) + 0x0)
++#define AR_PHY_FORCEMAX_GAINS_0(_ah) (AR_AGC_BASE(_ah) + 0x4)
++#define AR_PHY_GAINS_MINOFF0(_ah)    (AR_AGC_BASE(_ah) + 0x8)
++#define AR_PHY_DESIRED_SZ(_ah)       (AR_AGC_BASE(_ah) + 0xc)
++#define AR_PHY_FIND_SIG(_ah)         (AR_AGC_BASE(_ah) + 0x10)
++#define AR_PHY_AGC(_ah)              (AR_AGC_BASE(_ah) + 0x14)
++#define AR_PHY_EXT_ATTEN_CTL_0(_ah)  (AR_AGC_BASE(_ah) + 0x18)
++#define AR_PHY_CCA_0(_ah)            (AR_AGC_BASE(_ah) + 0x1c)
++#define AR_PHY_CCA_CTRL_0(_ah)       (AR_AGC_BASE(_ah) + 0x20)
++#define AR_PHY_RESTART(_ah)          (AR_AGC_BASE(_ah) + 0x24)
+ 
+ /*
+  * Antenna Diversity  settings
+  */
+-#define AR_PHY_MC_GAIN_CTRL     (AR_AGC_BASE + 0x28)
++#define AR_PHY_MC_GAIN_CTRL(_ah)     (AR_AGC_BASE(_ah) + 0x28)
+ #define AR_ANT_DIV_CTRL_ALL	0x7e000000
+ #define AR_ANT_DIV_CTRL_ALL_S	25
+ #define AR_ANT_DIV_ENABLE	0x1000000
+@@ -298,25 +298,25 @@
+ #define AR_PHY_ANT_DIV_MAIN_GAINTB              0x40000000
+ #define AR_PHY_ANT_DIV_MAIN_GAINTB_S            30
+ 
+-#define AR_PHY_EXTCHN_PWRTHR1   (AR_AGC_BASE + 0x2c)
+-#define AR_PHY_EXT_CHN_WIN      (AR_AGC_BASE + 0x30)
+-#define AR_PHY_20_40_DET_THR    (AR_AGC_BASE + 0x34)
+-#define AR_PHY_RIFS_SRCH        (AR_AGC_BASE + 0x38)
+-#define AR_PHY_PEAK_DET_CTRL_1  (AR_AGC_BASE + 0x3c)
+-#define AR_PHY_PEAK_DET_CTRL_2  (AR_AGC_BASE + 0x40)
+-#define AR_PHY_RX_GAIN_BOUNDS_1 (AR_AGC_BASE + 0x44)
+-#define AR_PHY_RX_GAIN_BOUNDS_2 (AR_AGC_BASE + 0x48)
+-#define AR_PHY_RSSI_0           (AR_AGC_BASE + 0x180)
+-#define AR_PHY_SPUR_CCK_REP0    (AR_AGC_BASE + 0x184)
+-
+-#define AR_PHY_CCK_DETECT       (AR_AGC_BASE + 0x1c0)
++#define AR_PHY_EXTCHN_PWRTHR1(_ah)   (AR_AGC_BASE(_ah) + 0x2c)
++#define AR_PHY_EXT_CHN_WIN(_ah)      (AR_AGC_BASE(_ah) + 0x30)
++#define AR_PHY_20_40_DET_THR(_ah)    (AR_AGC_BASE(_ah) + 0x34)
++#define AR_PHY_RIFS_SRCH(_ah)        (AR_AGC_BASE(_ah) + 0x38)
++#define AR_PHY_PEAK_DET_CTRL_1(_ah)  (AR_AGC_BASE(_ah) + 0x3c)
++#define AR_PHY_PEAK_DET_CTRL_2(_ah)  (AR_AGC_BASE(_ah) + 0x40)
++#define AR_PHY_RX_GAIN_BOUNDS_1(_ah) (AR_AGC_BASE(_ah) + 0x44)
++#define AR_PHY_RX_GAIN_BOUNDS_2(_ah) (AR_AGC_BASE(_ah) + 0x48)
++#define AR_PHY_RSSI_0(_ah)           (AR_AGC_BASE(_ah) + 0x180)
++#define AR_PHY_SPUR_CCK_REP0(_ah)    (AR_AGC_BASE(_ah) + 0x184)
++
++#define AR_PHY_CCK_DETECT(_ah)       (AR_AGC_BASE(_ah) + 0x1c0)
+ #define AR_FAST_DIV_ENABLE	0x2000
+ #define AR_FAST_DIV_ENABLE_S	13
+ 
+-#define AR_PHY_DAG_CTRLCCK      (AR_AGC_BASE + 0x1c4)
+-#define AR_PHY_IQCORR_CTRL_CCK  (AR_AGC_BASE + 0x1c8)
++#define AR_PHY_DAG_CTRLCCK(_ah)      (AR_AGC_BASE(_ah) + 0x1c4)
++#define AR_PHY_IQCORR_CTRL_CCK(_ah)  (AR_AGC_BASE(_ah) + 0x1c8)
+ 
+-#define AR_PHY_CCK_SPUR_MIT     (AR_AGC_BASE + 0x1cc)
++#define AR_PHY_CCK_SPUR_MIT(_ah)     (AR_AGC_BASE(_ah) + 0x1cc)
+ #define AR_PHY_CCK_SPUR_MIT_SPUR_RSSI_THR                           0x000001fe
+ #define AR_PHY_CCK_SPUR_MIT_SPUR_RSSI_THR_S                                  1
+ #define AR_PHY_CCK_SPUR_MIT_SPUR_FILTER_TYPE                        0x60000000
+@@ -326,13 +326,13 @@
+ #define AR_PHY_CCK_SPUR_MIT_CCK_SPUR_FREQ                           0x1ffffe00
+ #define AR_PHY_CCK_SPUR_MIT_CCK_SPUR_FREQ_S                                  9
+ 
+-#define AR_PHY_MRC_CCK_CTRL         (AR_AGC_BASE + 0x1d0)
++#define AR_PHY_MRC_CCK_CTRL(_ah)         (AR_AGC_BASE(_ah) + 0x1d0)
+ #define AR_PHY_MRC_CCK_ENABLE       0x00000001
+ #define AR_PHY_MRC_CCK_ENABLE_S              0
+ #define AR_PHY_MRC_CCK_MUX_REG      0x00000002
+ #define AR_PHY_MRC_CCK_MUX_REG_S             1
+ 
+-#define AR_PHY_RX_OCGAIN        (AR_AGC_BASE + 0x200)
++#define AR_PHY_RX_OCGAIN(_ah)        (AR_AGC_BASE(_ah) + 0x200)
+ 
+ #define AR_PHY_CCA_NOM_VAL_9300_2GHZ          -110
+ #define AR_PHY_CCA_NOM_VAL_9300_5GHZ          -115
+@@ -448,44 +448,44 @@
+ /*
+  * SM Register Map
+  */
+-#define AR_SM_BASE	0xa200
+-
+-#define AR_PHY_D2_CHIP_ID        (AR_SM_BASE + 0x0)
+-#define AR_PHY_GEN_CTRL          (AR_SM_BASE + 0x4)
+-#define AR_PHY_MODE              (AR_SM_BASE + 0x8)
+-#define AR_PHY_ACTIVE            (AR_SM_BASE + 0xc)
+-#define AR_PHY_SPUR_MASK_A(_ah)  (AR_SM_BASE + (AR_SREV_9561(_ah) ? 0x18 : 0x20))
+-#define AR_PHY_SPUR_MASK_B(_ah)  (AR_SM_BASE + (AR_SREV_9561(_ah) ? 0x1c : 0x24))
+-#define AR_PHY_SPECTRAL_SCAN     (AR_SM_BASE + 0x28)
+-#define AR_PHY_RADAR_BW_FILTER   (AR_SM_BASE + 0x2c)
+-#define AR_PHY_SEARCH_START_DELAY (AR_SM_BASE + 0x30)
+-#define AR_PHY_MAX_RX_LEN        (AR_SM_BASE + 0x34)
+-#define AR_PHY_FRAME_CTL         (AR_SM_BASE + 0x38)
+-#define AR_PHY_RFBUS_REQ         (AR_SM_BASE + 0x3c)
+-#define AR_PHY_RFBUS_GRANT       (AR_SM_BASE + 0x40)
+-#define AR_PHY_RIFS              (AR_SM_BASE + 0x44)
+-#define AR_PHY_RX_CLR_DELAY      (AR_SM_BASE + 0x50)
+-#define AR_PHY_RX_DELAY          (AR_SM_BASE + 0x54)
+-
+-#define AR_PHY_XPA_TIMING_CTL    (AR_SM_BASE + 0x64)
+-#define AR_PHY_MISC_PA_CTL       (AR_SM_BASE + 0x80)
+-#define AR_PHY_SWITCH_CHAIN_0    (AR_SM_BASE + 0x84)
+-#define AR_PHY_SWITCH_COM        (AR_SM_BASE + 0x88)
+-#define AR_PHY_SWITCH_COM_2      (AR_SM_BASE + 0x8c)
+-#define AR_PHY_RX_CHAINMASK      (AR_SM_BASE + 0xa0)
+-#define AR_PHY_CAL_CHAINMASK     (AR_SM_BASE + 0xc0)
+-#define AR_PHY_CALMODE           (AR_SM_BASE + 0xc8)
+-#define AR_PHY_FCAL_1            (AR_SM_BASE + 0xcc)
+-#define AR_PHY_FCAL_2_0          (AR_SM_BASE + 0xd0)
+-#define AR_PHY_DFT_TONE_CTL_0    (AR_SM_BASE + 0xd4)
+-#define AR_PHY_CL_CAL_CTL        (AR_SM_BASE + 0xd8)
+-#define AR_PHY_CL_TAB_0          (AR_SM_BASE + 0x100)
+-#define AR_PHY_SYNTH_CONTROL     (AR_SM_BASE + 0x140)
+-#define AR_PHY_ADDAC_CLK_SEL     (AR_SM_BASE + 0x144)
+-#define AR_PHY_PLL_CTL           (AR_SM_BASE + 0x148)
+-#define AR_PHY_ANALOG_SWAP       (AR_SM_BASE + 0x14c)
+-#define AR_PHY_ADDAC_PARA_CTL    (AR_SM_BASE + 0x150)
+-#define AR_PHY_XPA_CFG           (AR_SM_BASE + 0x158)
++#define AR_SM_BASE(_ah)	0xa200
++
++#define AR_PHY_D2_CHIP_ID(_ah)        (AR_SM_BASE(_ah) + 0x0)
++#define AR_PHY_GEN_CTRL(_ah)          (AR_SM_BASE(_ah) + 0x4)
++#define AR_PHY_MODE(_ah)              (AR_SM_BASE(_ah) + 0x8)
++#define AR_PHY_ACTIVE(_ah)            (AR_SM_BASE(_ah) + 0xc)
++#define AR_PHY_SPUR_MASK_A(_ah)       (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x18 : 0x20))
++#define AR_PHY_SPUR_MASK_B(_ah)       (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x1c : 0x24))
++#define AR_PHY_SPECTRAL_SCAN(_ah)     (AR_SM_BASE(_ah) + 0x28)
++#define AR_PHY_RADAR_BW_FILTER(_ah)   (AR_SM_BASE(_ah) + 0x2c)
++#define AR_PHY_SEARCH_START_DELAY(_ah) (AR_SM_BASE(_ah) + 0x30)
++#define AR_PHY_MAX_RX_LEN(_ah)        (AR_SM_BASE(_ah) + 0x34)
++#define AR_PHY_FRAME_CTL(_ah)         (AR_SM_BASE(_ah) + 0x38)
++#define AR_PHY_RFBUS_REQ(_ah)         (AR_SM_BASE(_ah) + 0x3c)
++#define AR_PHY_RFBUS_GRANT(_ah)       (AR_SM_BASE(_ah) + 0x40)
++#define AR_PHY_RIFS(_ah)              (AR_SM_BASE(_ah) + 0x44)
++#define AR_PHY_RX_CLR_DELAY(_ah)      (AR_SM_BASE(_ah) + 0x50)
++#define AR_PHY_RX_DELAY(_ah)          (AR_SM_BASE(_ah) + 0x54)
++
++#define AR_PHY_XPA_TIMING_CTL(_ah)    (AR_SM_BASE(_ah) + 0x64)
++#define AR_PHY_MISC_PA_CTL(_ah)       (AR_SM_BASE(_ah) + 0x80)
++#define AR_PHY_SWITCH_CHAIN_0(_ah)    (AR_SM_BASE(_ah) + 0x84)
++#define AR_PHY_SWITCH_COM(_ah)        (AR_SM_BASE(_ah) + 0x88)
++#define AR_PHY_SWITCH_COM_2(_ah)      (AR_SM_BASE(_ah) + 0x8c)
++#define AR_PHY_RX_CHAINMASK(_ah)      (AR_SM_BASE(_ah) + 0xa0)
++#define AR_PHY_CAL_CHAINMASK(_ah)     (AR_SM_BASE(_ah) + 0xc0)
++#define AR_PHY_CALMODE(_ah)           (AR_SM_BASE(_ah) + 0xc8)
++#define AR_PHY_FCAL_1(_ah)            (AR_SM_BASE(_ah) + 0xcc)
++#define AR_PHY_FCAL_2_0(_ah)          (AR_SM_BASE(_ah) + 0xd0)
++#define AR_PHY_DFT_TONE_CTL_0(_ah)    (AR_SM_BASE(_ah) + 0xd4)
++#define AR_PHY_CL_CAL_CTL(_ah)        (AR_SM_BASE(_ah) + 0xd8)
++#define AR_PHY_CL_TAB_0(_ah)          (AR_SM_BASE(_ah) + 0x100)
++#define AR_PHY_SYNTH_CONTROL(_ah)     (AR_SM_BASE(_ah) + 0x140)
++#define AR_PHY_ADDAC_CLK_SEL(_ah)     (AR_SM_BASE(_ah) + 0x144)
++#define AR_PHY_PLL_CTL(_ah)           (AR_SM_BASE(_ah) + 0x148)
++#define AR_PHY_ANALOG_SWAP(_ah)       (AR_SM_BASE(_ah) + 0x14c)
++#define AR_PHY_ADDAC_PARA_CTL(_ah)    (AR_SM_BASE(_ah) + 0x150)
++#define AR_PHY_XPA_CFG(_ah)           (AR_SM_BASE(_ah) + 0x158)
+ 
+ #define AR_PHY_FLC_PWR_THRESH		7
+ #define AR_PHY_FLC_PWR_THRESH_S		0
+@@ -498,7 +498,7 @@
+ #define AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_A                       0x3FF
+ #define AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_A_S                     0
+ 
+-#define AR_PHY_TEST(_ah)         (AR_SM_BASE + (AR_SREV_9561(_ah) ? 0x15c : 0x160))
++#define AR_PHY_TEST(_ah)         (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x15c : 0x160))
+ 
+ #define AR_PHY_TEST_BBB_OBS_SEL       0x780000
+ #define AR_PHY_TEST_BBB_OBS_SEL_S     19
+@@ -509,7 +509,7 @@
+ #define AR_PHY_TEST_CHAIN_SEL      0xC0000000
+ #define AR_PHY_TEST_CHAIN_SEL_S    30
+ 
+-#define AR_PHY_TEST_CTL_STATUS(_ah) (AR_SM_BASE + (AR_SREV_9561(_ah) ? 0x160 : 0x164))
++#define AR_PHY_TEST_CTL_STATUS(_ah) (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x160 : 0x164))
+ #define AR_PHY_TEST_CTL_TSTDAC_EN         0x1
+ #define AR_PHY_TEST_CTL_TSTDAC_EN_S       0
+ #define AR_PHY_TEST_CTL_TX_OBS_SEL        0x1C
+@@ -524,69 +524,69 @@
+ #define AR_PHY_TEST_CTL_DEBUGPORT_SEL_S	  29
+ 
+ 
+-#define AR_PHY_TSTDAC(_ah)       (AR_SM_BASE + (AR_SREV_9561(_ah) ? 0x164 : 0x168))
++#define AR_PHY_TSTDAC(_ah)       (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x164 : 0x168))
+ 
+-#define AR_PHY_CHAN_STATUS(_ah)  (AR_SM_BASE + (AR_SREV_9561(_ah) ? 0x168 : 0x16c))
++#define AR_PHY_CHAN_STATUS(_ah)  (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x168 : 0x16c))
+ 
+-#define AR_PHY_CHAN_INFO_MEMORY(_ah) (AR_SM_BASE + (AR_SREV_9561(_ah) ? 0x16c : 0x170))
++#define AR_PHY_CHAN_INFO_MEMORY(_ah) (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x16c : 0x170))
+ #define AR_PHY_CHAN_INFO_MEMORY_CHANINFOMEM_S2_READ	0x00000008
+ #define AR_PHY_CHAN_INFO_MEMORY_CHANINFOMEM_S2_READ_S	3
+ 
+-#define AR_PHY_CHNINFO_NOISEPWR(_ah)  (AR_SM_BASE + (AR_SREV_9561(_ah) ? 0x170 : 0x174))
+-#define AR_PHY_CHNINFO_GAINDIFF(_ah)  (AR_SM_BASE + (AR_SREV_9561(_ah) ? 0x174 : 0x178))
+-#define AR_PHY_CHNINFO_FINETIM(_ah)   (AR_SM_BASE + (AR_SREV_9561(_ah) ? 0x178 : 0x17c))
+-#define AR_PHY_CHAN_INFO_GAIN_0(_ah)  (AR_SM_BASE + (AR_SREV_9561(_ah) ? 0x17c : 0x180))
+-#define AR_PHY_SCRAMBLER_SEED(_ah)    (AR_SM_BASE + (AR_SREV_9561(_ah) ? 0x184 : 0x190))
+-#define AR_PHY_CCK_TX_CTRL(_ah)       (AR_SM_BASE + (AR_SREV_9561(_ah) ? 0x188 : 0x194))
+-
+-#define AR_PHY_HEAVYCLIP_CTL(_ah) (AR_SM_BASE + (AR_SREV_9561(_ah) ? 0x198 : 0x1a4))
+-#define AR_PHY_HEAVYCLIP_20      (AR_SM_BASE + 0x1a8)
+-#define AR_PHY_HEAVYCLIP_40      (AR_SM_BASE + 0x1ac)
+-#define AR_PHY_HEAVYCLIP_1	 (AR_SM_BASE + 0x19c)
+-#define AR_PHY_HEAVYCLIP_2	 (AR_SM_BASE + 0x1a0)
+-#define AR_PHY_HEAVYCLIP_3	 (AR_SM_BASE + 0x1a4)
+-#define AR_PHY_HEAVYCLIP_4	 (AR_SM_BASE + 0x1a8)
+-#define AR_PHY_HEAVYCLIP_5	 (AR_SM_BASE + 0x1ac)
+-#define AR_PHY_ILLEGAL_TXRATE    (AR_SM_BASE + 0x1b0)
+-
+-#define AR_PHY_POWER_TX_RATE(_d) (AR_SM_BASE + 0x1c0 + ((_d) << 2))
+-
+-#define AR_PHY_PWRTX_MAX         (AR_SM_BASE + 0x1f0)
+-#define AR_PHY_POWER_TX_SUB      (AR_SM_BASE + 0x1f4)
+-
+-#define AR_PHY_TPC_1				(AR_SM_BASE + 0x1f8)
++#define AR_PHY_CHNINFO_NOISEPWR(_ah)  (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x170 : 0x174))
++#define AR_PHY_CHNINFO_GAINDIFF(_ah)  (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x174 : 0x178))
++#define AR_PHY_CHNINFO_FINETIM(_ah)   (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x178 : 0x17c))
++#define AR_PHY_CHAN_INFO_GAIN_0(_ah)  (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x17c : 0x180))
++#define AR_PHY_SCRAMBLER_SEED(_ah)    (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x184 : 0x190))
++#define AR_PHY_CCK_TX_CTRL(_ah)       (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x188 : 0x194))
++
++#define AR_PHY_HEAVYCLIP_CTL(_ah) (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x198 : 0x1a4))
++#define AR_PHY_HEAVYCLIP_20(_ah)      (AR_SM_BASE(_ah) + 0x1a8)
++#define AR_PHY_HEAVYCLIP_40(_ah)      (AR_SM_BASE(_ah) + 0x1ac)
++#define AR_PHY_HEAVYCLIP_1(_ah)	 (AR_SM_BASE(_ah) + 0x19c)
++#define AR_PHY_HEAVYCLIP_2(_ah)	 (AR_SM_BASE(_ah) + 0x1a0)
++#define AR_PHY_HEAVYCLIP_3(_ah)	 (AR_SM_BASE(_ah) + 0x1a4)
++#define AR_PHY_HEAVYCLIP_4(_ah)	 (AR_SM_BASE(_ah) + 0x1a8)
++#define AR_PHY_HEAVYCLIP_5(_ah)	 (AR_SM_BASE(_ah) + 0x1ac)
++#define AR_PHY_ILLEGAL_TXRATE(_ah)    (AR_SM_BASE(_ah) + 0x1b0)
++
++#define AR_PHY_POWER_TX_RATE(_ah, _d) (AR_SM_BASE(_ah) + 0x1c0 + ((_d) << 2))
++
++#define AR_PHY_PWRTX_MAX(_ah)         (AR_SM_BASE(_ah) + 0x1f0)
++#define AR_PHY_POWER_TX_SUB(_ah)      (AR_SM_BASE(_ah) + 0x1f4)
++
++#define AR_PHY_TPC_1(_ah)			(AR_SM_BASE(_ah) + 0x1f8)
+ #define AR_PHY_TPC_1_FORCED_DAC_GAIN		0x0000003e
+ #define AR_PHY_TPC_1_FORCED_DAC_GAIN_S		1
+ #define AR_PHY_TPC_1_FORCE_DAC_GAIN		0x00000001
+ #define AR_PHY_TPC_1_FORCE_DAC_GAIN_S		0
+ 
+-#define AR_PHY_TPC_4_B0				(AR_SM_BASE + 0x204)
+-#define AR_PHY_TPC_5_B0				(AR_SM_BASE + 0x208)
+-#define AR_PHY_TPC_6_B0				(AR_SM_BASE + 0x20c)
++#define AR_PHY_TPC_4_B0(_ah)			(AR_SM_BASE(_ah) + 0x204)
++#define AR_PHY_TPC_5_B0(_ah)			(AR_SM_BASE(_ah) + 0x208)
++#define AR_PHY_TPC_6_B0(_ah)			(AR_SM_BASE(_ah) + 0x20c)
+ 
+-#define AR_PHY_TPC_11_B0			(AR_SM_BASE + 0x220)
+-#define AR_PHY_TPC_11_B1			(AR_SM1_BASE + 0x220)
+-#define AR_PHY_TPC_11_B2			(AR_SM2_BASE + 0x220)
++#define AR_PHY_TPC_11_B0(_ah)			(AR_SM_BASE(_ah) + 0x220)
++#define AR_PHY_TPC_11_B1(_ah)			(AR_SM1_BASE(_ah) + 0x220)
++#define AR_PHY_TPC_11_B2(_ah)			(AR_SM2_BASE(_ah) + 0x220)
+ #define AR_PHY_TPC_11_OLPC_GAIN_DELTA		0x00ff0000
+ #define AR_PHY_TPC_11_OLPC_GAIN_DELTA_S		16
+ 
+-#define AR_PHY_TPC_12				(AR_SM_BASE + 0x224)
++#define AR_PHY_TPC_12(_ah)			(AR_SM_BASE(_ah) + 0x224)
+ #define AR_PHY_TPC_12_DESIRED_SCALE_HT40_5	0x3e000000
+ #define AR_PHY_TPC_12_DESIRED_SCALE_HT40_5_S	25
+ 
+-#define AR_PHY_TPC_18				(AR_SM_BASE + 0x23c)
++#define AR_PHY_TPC_18(_ah)			(AR_SM_BASE(_ah) + 0x23c)
+ #define AR_PHY_TPC_18_THERM_CAL_VALUE           0x000000ff
+ #define AR_PHY_TPC_18_THERM_CAL_VALUE_S         0
+ #define AR_PHY_TPC_18_VOLT_CAL_VALUE		0x0000ff00
+ #define AR_PHY_TPC_18_VOLT_CAL_VALUE_S		8
+ 
+-#define AR_PHY_TPC_19				(AR_SM_BASE + 0x240)
++#define AR_PHY_TPC_19(_ah)			(AR_SM_BASE(_ah) + 0x240)
+ #define AR_PHY_TPC_19_ALPHA_VOLT		0x001f0000
+ #define AR_PHY_TPC_19_ALPHA_VOLT_S		16
+ #define AR_PHY_TPC_19_ALPHA_THERM		0xff
+ #define AR_PHY_TPC_19_ALPHA_THERM_S		0
+ 
+-#define AR_PHY_TX_FORCED_GAIN				(AR_SM_BASE + 0x258)
++#define AR_PHY_TX_FORCED_GAIN(_ah)			(AR_SM_BASE(_ah) + 0x258)
+ #define AR_PHY_TX_FORCED_GAIN_FORCE_TX_GAIN		0x00000001
+ #define AR_PHY_TX_FORCED_GAIN_FORCE_TX_GAIN_S		0
+ #define AR_PHY_TX_FORCED_GAIN_FORCED_TXBB1DBGAIN	0x0000000e
+@@ -607,42 +607,42 @@
+ #define AR_PHY_TX_FORCED_GAIN_FORCED_ENABLE_PAL_S	24
+ 
+ 
+-#define AR_PHY_PDADC_TAB_0       (AR_SM_BASE + 0x280)
++#define AR_PHY_PDADC_TAB_0(_ah)       (AR_SM_BASE(_ah) + 0x280)
+ 
+-#define AR_PHY_TXGAIN_TABLE      (AR_SM_BASE + 0x300)
++#define AR_PHY_TXGAIN_TABLE(_ah)      (AR_SM_BASE(_ah) + 0x300)
+ 
+-#define AR_PHY_TX_IQCAL_CONTROL_0(_ah)   (AR_SM_BASE + (AR_SREV_9485(_ah) ? \
++#define AR_PHY_TX_IQCAL_CONTROL_0(_ah)   (AR_SM_BASE(_ah) + (AR_SREV_9485(_ah) ? \
+ 						 0x3c4 : 0x444))
+-#define AR_PHY_TX_IQCAL_CONTROL_1(_ah)   (AR_SM_BASE + (AR_SREV_9485(_ah) ? \
++#define AR_PHY_TX_IQCAL_CONTROL_1(_ah)   (AR_SM_BASE(_ah) + (AR_SREV_9485(_ah) ? \
+ 						 0x3c8 : 0x448))
+-#define AR_PHY_TX_IQCAL_START(_ah)       (AR_SM_BASE + (AR_SREV_9485(_ah) ? \
++#define AR_PHY_TX_IQCAL_START(_ah)       (AR_SM_BASE(_ah) + (AR_SREV_9485(_ah) ? \
+ 						 0x3c4 : 0x440))
+-#define AR_PHY_TX_IQCAL_STATUS_B0(_ah)   (AR_SM_BASE + (AR_SREV_9485(_ah) ? \
++#define AR_PHY_TX_IQCAL_STATUS_B0(_ah)   (AR_SM_BASE(_ah) + (AR_SREV_9485(_ah) ? \
+ 						 0x3f0 : 0x48c))
+-#define AR_PHY_TX_IQCAL_CORR_COEFF_B0(_ah, _i)    (AR_SM_BASE + \
++#define AR_PHY_TX_IQCAL_CORR_COEFF_B0(_ah, _i)    (AR_SM_BASE(_ah) + \
+ 					     (AR_SREV_9485(_ah) ? \
+ 					      0x3d0 : 0x450) + ((_i) << 2))
+-#define AR_PHY_RTT_CTRL			(AR_SM_BASE + 0x380)
++#define AR_PHY_RTT_CTRL(_ah)			(AR_SM_BASE(_ah) + 0x380)
+ 
+-#define AR_PHY_WATCHDOG_STATUS      (AR_SM_BASE + 0x5c0)
+-#define AR_PHY_WATCHDOG_CTL_1       (AR_SM_BASE + 0x5c4)
+-#define AR_PHY_WATCHDOG_CTL_2       (AR_SM_BASE + 0x5c8)
+-#define AR_PHY_WATCHDOG_CTL         (AR_SM_BASE + 0x5cc)
+-#define AR_PHY_ONLY_WARMRESET       (AR_SM_BASE + 0x5d0)
+-#define AR_PHY_ONLY_CTL             (AR_SM_BASE + 0x5d4)
+-#define AR_PHY_ECO_CTRL             (AR_SM_BASE + 0x5dc)
++#define AR_PHY_WATCHDOG_STATUS(_ah)      (AR_SM_BASE(_ah) + 0x5c0)
++#define AR_PHY_WATCHDOG_CTL_1(_ah)       (AR_SM_BASE(_ah) + 0x5c4)
++#define AR_PHY_WATCHDOG_CTL_2(_ah)       (AR_SM_BASE(_ah) + 0x5c8)
++#define AR_PHY_WATCHDOG_CTL(_ah)         (AR_SM_BASE(_ah) + 0x5cc)
++#define AR_PHY_ONLY_WARMRESET(_ah)       (AR_SM_BASE(_ah) + 0x5d0)
++#define AR_PHY_ONLY_CTL(_ah)             (AR_SM_BASE(_ah) + 0x5d4)
++#define AR_PHY_ECO_CTRL(_ah)             (AR_SM_BASE(_ah) + 0x5dc)
+ 
+-#define AR_PHY_BB_THERM_ADC_1				(AR_SM_BASE + 0x248)
++#define AR_PHY_BB_THERM_ADC_1(_ah)			(AR_SM_BASE(_ah) + 0x248)
+ #define AR_PHY_BB_THERM_ADC_1_INIT_THERM		0x000000ff
+ #define AR_PHY_BB_THERM_ADC_1_INIT_THERM_S		0
+ 
+-#define AR_PHY_BB_THERM_ADC_3				(AR_SM_BASE + 0x250)
++#define AR_PHY_BB_THERM_ADC_3(_ah)			(AR_SM_BASE(_ah) + 0x250)
+ #define AR_PHY_BB_THERM_ADC_3_THERM_ADC_SCALE_GAIN	0x0001ff00
+ #define AR_PHY_BB_THERM_ADC_3_THERM_ADC_SCALE_GAIN_S	8
+ #define AR_PHY_BB_THERM_ADC_3_THERM_ADC_OFFSET		0x000000ff
+ #define AR_PHY_BB_THERM_ADC_3_THERM_ADC_OFFSET_S	0
+ 
+-#define AR_PHY_BB_THERM_ADC_4				(AR_SM_BASE + 0x254)
++#define AR_PHY_BB_THERM_ADC_4(_ah)			(AR_SM_BASE(_ah) + 0x254)
+ #define AR_PHY_BB_THERM_ADC_4_LATEST_THERM_VALUE	0x000000ff
+ #define AR_PHY_BB_THERM_ADC_4_LATEST_THERM_VALUE_S	0
+ #define AR_PHY_BB_THERM_ADC_4_LATEST_VOLT_VALUE		0x0000ff00
+@@ -923,15 +923,15 @@
+ /*
+  * Channel 1 Register Map
+  */
+-#define AR_CHAN1_BASE	0xa800
++#define AR_CHAN1_BASE(_ah)	0xa800
+ 
+-#define AR_PHY_EXT_CCA_1            (AR_CHAN1_BASE + 0x30)
+-#define AR_PHY_TX_PHASE_RAMP_1      (AR_CHAN1_BASE + 0xd0)
+-#define AR_PHY_ADC_GAIN_DC_CORR_1   (AR_CHAN1_BASE + 0xd4)
++#define AR_PHY_EXT_CCA_1(_ah)            (AR_CHAN1_BASE(_ah) + 0x30)
++#define AR_PHY_TX_PHASE_RAMP_1(_ah)      (AR_CHAN1_BASE(_ah) + 0xd0)
++#define AR_PHY_ADC_GAIN_DC_CORR_1(_ah)   (AR_CHAN1_BASE(_ah) + 0xd4)
+ 
+-#define AR_PHY_SPUR_REPORT_1        (AR_CHAN1_BASE + 0xa8)
+-#define AR_PHY_CHAN_INFO_TAB_1      (AR_CHAN1_BASE + 0x300)
+-#define AR_PHY_RX_IQCAL_CORR_B1     (AR_CHAN1_BASE + 0xdc)
++#define AR_PHY_SPUR_REPORT_1(_ah)        (AR_CHAN1_BASE(_ah) + 0xa8)
++#define AR_PHY_CHAN_INFO_TAB_1(_ah)      (AR_CHAN1_BASE(_ah) + 0x300)
++#define AR_PHY_RX_IQCAL_CORR_B1(_ah)     (AR_CHAN1_BASE(_ah) + 0xdc)
+ 
+ /*
+  * Channel 1 Field Definitions
+@@ -942,15 +942,15 @@
+ /*
+  * AGC 1 Register Map
+  */
+-#define AR_AGC1_BASE	0xae00
++#define AR_AGC1_BASE(_ah)	0xae00
+ 
+-#define AR_PHY_FORCEMAX_GAINS_1      (AR_AGC1_BASE + 0x4)
+-#define AR_PHY_EXT_ATTEN_CTL_1       (AR_AGC1_BASE + 0x18)
+-#define AR_PHY_CCA_1                 (AR_AGC1_BASE + 0x1c)
+-#define AR_PHY_CCA_CTRL_1            (AR_AGC1_BASE + 0x20)
+-#define AR_PHY_RSSI_1                (AR_AGC1_BASE + 0x180)
+-#define AR_PHY_SPUR_CCK_REP_1        (AR_AGC1_BASE + 0x184)
+-#define AR_PHY_RX_OCGAIN_2           (AR_AGC1_BASE + 0x200)
++#define AR_PHY_FORCEMAX_GAINS_1(_ah)      (AR_AGC1_BASE(_ah) + 0x4)
++#define AR_PHY_EXT_ATTEN_CTL_1(_ah)       (AR_AGC1_BASE(_ah) + 0x18)
++#define AR_PHY_CCA_1(_ah)                 (AR_AGC1_BASE(_ah) + 0x1c)
++#define AR_PHY_CCA_CTRL_1(_ah)            (AR_AGC1_BASE(_ah) + 0x20)
++#define AR_PHY_RSSI_1(_ah)                (AR_AGC1_BASE(_ah) + 0x180)
++#define AR_PHY_SPUR_CCK_REP_1(_ah)        (AR_AGC1_BASE(_ah) + 0x184)
++#define AR_PHY_RX_OCGAIN_2(_ah)           (AR_AGC1_BASE(_ah) + 0x200)
+ 
+ /*
+  * AGC 1 Field Definitions
+@@ -961,41 +961,41 @@
+ /*
+  * SM 1 Register Map
+  */
+-#define AR_SM1_BASE	0xb200
+-
+-#define AR_PHY_SWITCH_CHAIN_1   (AR_SM1_BASE + 0x84)
+-#define AR_PHY_FCAL_2_1         (AR_SM1_BASE + 0xd0)
+-#define AR_PHY_DFT_TONE_CTL_1   (AR_SM1_BASE + 0xd4)
+-#define AR_PHY_CL_TAB_1         (AR_SM1_BASE + 0x100)
+-#define AR_PHY_CHAN_INFO_GAIN_1 (AR_SM1_BASE + 0x180)
+-#define AR_PHY_TPC_4_B1         (AR_SM1_BASE + 0x204)
+-#define AR_PHY_TPC_5_B1         (AR_SM1_BASE + 0x208)
+-#define AR_PHY_TPC_6_B1         (AR_SM1_BASE + 0x20c)
+-#define AR_PHY_TPC_11_B1        (AR_SM1_BASE + 0x220)
+-#define AR_PHY_PDADC_TAB_1(_ah)	(AR_SM1_BASE + (AR_SREV_9462_20_OR_LATER(_ah) ? \
++#define AR_SM1_BASE(_ah)	0xb200
++
++#define AR_PHY_SWITCH_CHAIN_1(_ah)   (AR_SM1_BASE(_ah) + 0x84)
++#define AR_PHY_FCAL_2_1(_ah)         (AR_SM1_BASE(_ah) + 0xd0)
++#define AR_PHY_DFT_TONE_CTL_1(_ah)   (AR_SM1_BASE(_ah) + 0xd4)
++#define AR_PHY_CL_TAB_1(_ah)         (AR_SM1_BASE(_ah) + 0x100)
++#define AR_PHY_CHAN_INFO_GAIN_1(_ah) (AR_SM1_BASE(_ah) + 0x180)
++#define AR_PHY_TPC_4_B1(_ah)         (AR_SM1_BASE(_ah) + 0x204)
++#define AR_PHY_TPC_5_B1(_ah)         (AR_SM1_BASE(_ah) + 0x208)
++#define AR_PHY_TPC_6_B1(_ah)         (AR_SM1_BASE(_ah) + 0x20c)
++#define AR_PHY_TPC_11_B1(_ah)        (AR_SM1_BASE(_ah) + 0x220)
++#define AR_PHY_PDADC_TAB_1(_ah)	(AR_SM1_BASE(_ah) + (AR_SREV_9462_20_OR_LATER(_ah) ? \
+ 					0x280 : 0x240))
+-#define AR_PHY_TPC_19_B1	(AR_SM1_BASE + 0x240)
++#define AR_PHY_TPC_19_B1(_ah)	(AR_SM1_BASE(_ah) + 0x240)
+ #define AR_PHY_TPC_19_B1_ALPHA_THERM		0xff
+ #define AR_PHY_TPC_19_B1_ALPHA_THERM_S		0
+-#define AR_PHY_TX_IQCAL_STATUS_B1   (AR_SM1_BASE + 0x48c)
+-#define AR_PHY_TX_IQCAL_CORR_COEFF_B1(_i)    (AR_SM1_BASE + 0x450 + ((_i) << 2))
++#define AR_PHY_TX_IQCAL_STATUS_B1(_ah)   (AR_SM1_BASE(_ah) + 0x48c)
++#define AR_PHY_TX_IQCAL_CORR_COEFF_B1(_ah, _i)    (AR_SM1_BASE(_ah) + 0x450 + ((_i) << 2))
+ 
+-#define AR_PHY_RTT_TABLE_SW_INTF_B(i)	(0x384 + ((i) ? \
+-					AR_SM1_BASE : AR_SM_BASE))
+-#define AR_PHY_RTT_TABLE_SW_INTF_1_B(i)	(0x388 + ((i) ? \
+-					AR_SM1_BASE : AR_SM_BASE))
++#define AR_PHY_RTT_TABLE_SW_INTF_B(_ah, i)	(0x384 + ((i) ? \
++					AR_SM1_BASE(_ah) : AR_SM_BASE(_ah)))
++#define AR_PHY_RTT_TABLE_SW_INTF_1_B(_ah, i)	(0x388 + ((i) ? \
++					AR_SM1_BASE(_ah) : AR_SM_BASE(_ah)))
+ /*
+  * Channel 2 Register Map
+  */
+-#define AR_CHAN2_BASE	0xb800
++#define AR_CHAN2_BASE(_ah)	0xb800
+ 
+-#define AR_PHY_EXT_CCA_2            (AR_CHAN2_BASE + 0x30)
+-#define AR_PHY_TX_PHASE_RAMP_2      (AR_CHAN2_BASE + 0xd0)
+-#define AR_PHY_ADC_GAIN_DC_CORR_2   (AR_CHAN2_BASE + 0xd4)
++#define AR_PHY_EXT_CCA_2(_ah)            (AR_CHAN2_BASE(_ah) + 0x30)
++#define AR_PHY_TX_PHASE_RAMP_2(_ah)      (AR_CHAN2_BASE(_ah) + 0xd0)
++#define AR_PHY_ADC_GAIN_DC_CORR_2(_ah)   (AR_CHAN2_BASE(_ah) + 0xd4)
+ 
+-#define AR_PHY_SPUR_REPORT_2        (AR_CHAN2_BASE + 0xa8)
+-#define AR_PHY_CHAN_INFO_TAB_2      (AR_CHAN2_BASE + 0x300)
+-#define AR_PHY_RX_IQCAL_CORR_B2     (AR_CHAN2_BASE + 0xdc)
++#define AR_PHY_SPUR_REPORT_2(_ah)        (AR_CHAN2_BASE(_ah) + 0xa8)
++#define AR_PHY_CHAN_INFO_TAB_2(_ah)      (AR_CHAN2_BASE(_ah) + 0x300)
++#define AR_PHY_RX_IQCAL_CORR_B2(_ah)     (AR_CHAN2_BASE(_ah) + 0xdc)
+ 
+ /*
+  * Channel 2 Field Definitions
+@@ -1005,13 +1005,13 @@
+ /*
+  * AGC 2 Register Map
+  */
+-#define AR_AGC2_BASE	0xbe00
++#define AR_AGC2_BASE(_ah)	0xbe00
+ 
+-#define AR_PHY_FORCEMAX_GAINS_2      (AR_AGC2_BASE + 0x4)
+-#define AR_PHY_EXT_ATTEN_CTL_2       (AR_AGC2_BASE + 0x18)
+-#define AR_PHY_CCA_2                 (AR_AGC2_BASE + 0x1c)
+-#define AR_PHY_CCA_CTRL_2            (AR_AGC2_BASE + 0x20)
+-#define AR_PHY_RSSI_2                (AR_AGC2_BASE + 0x180)
++#define AR_PHY_FORCEMAX_GAINS_2(_ah)      (AR_AGC2_BASE(_ah) + 0x4)
++#define AR_PHY_EXT_ATTEN_CTL_2(_ah)       (AR_AGC2_BASE(_ah) + 0x18)
++#define AR_PHY_CCA_2(_ah)                 (AR_AGC2_BASE(_ah) + 0x1c)
++#define AR_PHY_CCA_CTRL_2(_ah)            (AR_AGC2_BASE(_ah) + 0x20)
++#define AR_PHY_RSSI_2(_ah)                (AR_AGC2_BASE(_ah) + 0x180)
+ 
+ /*
+  * AGC 2 Field Definitions
+@@ -1022,20 +1022,20 @@
+ /*
+  * SM 2 Register Map
+  */
+-#define AR_SM2_BASE	0xc200
+-
+-#define AR_PHY_SWITCH_CHAIN_2    (AR_SM2_BASE + 0x84)
+-#define AR_PHY_FCAL_2_2          (AR_SM2_BASE + 0xd0)
+-#define AR_PHY_DFT_TONE_CTL_2    (AR_SM2_BASE + 0xd4)
+-#define AR_PHY_CL_TAB_2          (AR_SM2_BASE + 0x100)
+-#define AR_PHY_CHAN_INFO_GAIN_2  (AR_SM2_BASE + 0x180)
+-#define AR_PHY_TPC_4_B2          (AR_SM2_BASE + 0x204)
+-#define AR_PHY_TPC_5_B2          (AR_SM2_BASE + 0x208)
+-#define AR_PHY_TPC_6_B2          (AR_SM2_BASE + 0x20c)
+-#define AR_PHY_TPC_11_B2         (AR_SM2_BASE + 0x220)
+-#define AR_PHY_TPC_19_B2         (AR_SM2_BASE + 0x240)
+-#define AR_PHY_TX_IQCAL_STATUS_B2   (AR_SM2_BASE + 0x48c)
+-#define AR_PHY_TX_IQCAL_CORR_COEFF_B2(_i)    (AR_SM2_BASE + 0x450 + ((_i) << 2))
++#define AR_SM2_BASE(_ah)	0xc200
++
++#define AR_PHY_SWITCH_CHAIN_2(_ah)    (AR_SM2_BASE(_ah) + 0x84)
++#define AR_PHY_FCAL_2_2(_ah)          (AR_SM2_BASE(_ah) + 0xd0)
++#define AR_PHY_DFT_TONE_CTL_2(_ah)    (AR_SM2_BASE(_ah) + 0xd4)
++#define AR_PHY_CL_TAB_2(_ah)          (AR_SM2_BASE(_ah) + 0x100)
++#define AR_PHY_CHAN_INFO_GAIN_2(_ah)  (AR_SM2_BASE(_ah) + 0x180)
++#define AR_PHY_TPC_4_B2(_ah)          (AR_SM2_BASE(_ah) + 0x204)
++#define AR_PHY_TPC_5_B2(_ah)          (AR_SM2_BASE(_ah) + 0x208)
++#define AR_PHY_TPC_6_B2(_ah)          (AR_SM2_BASE(_ah) + 0x20c)
++#define AR_PHY_TPC_11_B2(_ah)         (AR_SM2_BASE(_ah) + 0x220)
++#define AR_PHY_TPC_19_B2(_ah)         (AR_SM2_BASE(_ah) + 0x240)
++#define AR_PHY_TX_IQCAL_STATUS_B2(_ah)   (AR_SM2_BASE(_ah) + 0x48c)
++#define AR_PHY_TX_IQCAL_CORR_COEFF_B2(_ah, _i)    (AR_SM2_BASE(_ah) + 0x450 + ((_i) << 2))
+ 
+ #define AR_PHY_TX_IQCAL_STATUS_B2_FAILED    0x00000001
+ 
+@@ -1050,7 +1050,7 @@
+ /*
+  * Misc helper defines
+  */
+-#define AR_PHY_CHAIN_OFFSET     (AR_CHAN1_BASE - AR_CHAN_BASE)
++#define AR_PHY_CHAIN_OFFSET     0x1000
+ 
+ #define AR_PHY_NEW_ADC_DC_GAIN_CORR(_i) (AR_PHY_ADC_GAIN_DC_CORR_0 + (AR_PHY_CHAIN_OFFSET * (_i)))
+ #define AR_PHY_NEW_ADC_DC_GAIN_CORR_9300_10(_i) (AR_PHY_ADC_GAIN_DC_CORR_0_9300_10 + (AR_PHY_CHAIN_OFFSET * (_i)))
+@@ -1061,10 +1061,10 @@
+ #define AR_PHY_TPCRG5(_i)           (AR_PHY_TPC_5_B0 + (AR_PHY_CHAIN_OFFSET * (_i)))
+ #define AR_PHY_PDADC_TAB(_i)        (AR_PHY_PDADC_TAB_0 + (AR_PHY_CHAIN_OFFSET * (_i)))
+ 
+-#define AR_PHY_CAL_MEAS_0(_i)       (AR_PHY_IQ_ADC_MEAS_0_B0 + (AR_PHY_CHAIN_OFFSET * (_i)))
+-#define AR_PHY_CAL_MEAS_1(_i)       (AR_PHY_IQ_ADC_MEAS_1_B0 + (AR_PHY_CHAIN_OFFSET * (_i)))
+-#define AR_PHY_CAL_MEAS_2(_i)       (AR_PHY_IQ_ADC_MEAS_2_B0 + (AR_PHY_CHAIN_OFFSET * (_i)))
+-#define AR_PHY_CAL_MEAS_3(_i)       (AR_PHY_IQ_ADC_MEAS_3_B0 + (AR_PHY_CHAIN_OFFSET * (_i)))
++#define AR_PHY_CAL_MEAS_0(_ah, _i)  (AR_PHY_IQ_ADC_MEAS_0_B0(_ah) + (AR_PHY_CHAIN_OFFSET * (_i)))
++#define AR_PHY_CAL_MEAS_1(_ah, _i)  (AR_PHY_IQ_ADC_MEAS_1_B0(_ah) + (AR_PHY_CHAIN_OFFSET * (_i)))
++#define AR_PHY_CAL_MEAS_2(_ah, _i)  (AR_PHY_IQ_ADC_MEAS_2_B0(_ah) + (AR_PHY_CHAIN_OFFSET * (_i)))
++#define AR_PHY_CAL_MEAS_3(_ah, _i)  (AR_PHY_IQ_ADC_MEAS_3_B0(_ah) + (AR_PHY_CHAIN_OFFSET * (_i)))
+ #define AR_PHY_CAL_MEAS_0_9300_10(_i) (AR_PHY_IQ_ADC_MEAS_0_B0_9300_10 + (AR_PHY_CHAIN_OFFSET * (_i)))
+ #define AR_PHY_CAL_MEAS_1_9300_10(_i) (AR_PHY_IQ_ADC_MEAS_1_B0_9300_10 + (AR_PHY_CHAIN_OFFSET * (_i)))
+ #define AR_PHY_CAL_MEAS_2_9300_10(_i) (AR_PHY_IQ_ADC_MEAS_2_B0_9300_10 + (AR_PHY_CHAIN_OFFSET * (_i)))
+@@ -1103,23 +1103,23 @@
+ /*
+  * PAPRD registers
+  */
+-#define AR_PHY_XPA_TIMING_CTL		(AR_SM_BASE + 0x64)
++#define AR_PHY_XPA_TIMING_CTL(_ah)	(AR_SM_BASE(_ah) + 0x64)
+ 
+-#define AR_PHY_PAPRD_AM2AM		(AR_CHAN_BASE + 0xe4)
++#define AR_PHY_PAPRD_AM2AM(_ah)		(AR_CHAN_BASE(_ah) + 0xe4)
+ #define AR_PHY_PAPRD_AM2AM_MASK		0x01ffffff
+ #define AR_PHY_PAPRD_AM2AM_MASK_S	0
+ 
+-#define AR_PHY_PAPRD_AM2PM		(AR_CHAN_BASE + 0xe8)
++#define AR_PHY_PAPRD_AM2PM(_ah)		(AR_CHAN_BASE(_ah) + 0xe8)
+ #define AR_PHY_PAPRD_AM2PM_MASK		0x01ffffff
+ #define AR_PHY_PAPRD_AM2PM_MASK_S	0
+ 
+-#define AR_PHY_PAPRD_HT40		(AR_CHAN_BASE + 0xec)
++#define AR_PHY_PAPRD_HT40(_ah)		(AR_CHAN_BASE(_ah) + 0xec)
+ #define AR_PHY_PAPRD_HT40_MASK		0x01ffffff
+ #define AR_PHY_PAPRD_HT40_MASK_S	0
+ 
+-#define AR_PHY_PAPRD_CTRL0_B0				(AR_CHAN_BASE + 0xf0)
+-#define AR_PHY_PAPRD_CTRL0_B1				(AR_CHAN1_BASE + 0xf0)
+-#define AR_PHY_PAPRD_CTRL0_B2				(AR_CHAN2_BASE + 0xf0)
++#define AR_PHY_PAPRD_CTRL0_B0(_ah)			(AR_CHAN_BASE(_ah) + 0xf0)
++#define AR_PHY_PAPRD_CTRL0_B1(_ah)			(AR_CHAN1_BASE(_ah) + 0xf0)
++#define AR_PHY_PAPRD_CTRL0_B2(_ah)			(AR_CHAN2_BASE(_ah) + 0xf0)
+ #define AR_PHY_PAPRD_CTRL0_PAPRD_ENABLE			0x00000001
+ #define AR_PHY_PAPRD_CTRL0_PAPRD_ENABLE_S		0
+ #define AR_PHY_PAPRD_CTRL0_USE_SINGLE_TABLE_MASK	0x00000002
+@@ -1127,9 +1127,9 @@
+ #define AR_PHY_PAPRD_CTRL0_PAPRD_MAG_THRSH		0xf8000000
+ #define AR_PHY_PAPRD_CTRL0_PAPRD_MAG_THRSH_S		27
+ 
+-#define AR_PHY_PAPRD_CTRL1_B0				(AR_CHAN_BASE + 0xf4)
+-#define AR_PHY_PAPRD_CTRL1_B1				(AR_CHAN1_BASE + 0xf4)
+-#define AR_PHY_PAPRD_CTRL1_B2				(AR_CHAN2_BASE + 0xf4)
++#define AR_PHY_PAPRD_CTRL1_B0(_ah)			(AR_CHAN_BASE(_ah) + 0xf4)
++#define AR_PHY_PAPRD_CTRL1_B1(_ah)			(AR_CHAN1_BASE(_ah) + 0xf4)
++#define AR_PHY_PAPRD_CTRL1_B2(_ah)			(AR_CHAN2_BASE(_ah) + 0xf4)
+ #define AR_PHY_PAPRD_CTRL1_ADAPTIVE_SCALING_ENA		0x00000001
+ #define AR_PHY_PAPRD_CTRL1_ADAPTIVE_SCALING_ENA_S	0
+ #define AR_PHY_PAPRD_CTRL1_ADAPTIVE_AM2AM_ENABLE	0x00000002
+@@ -1143,7 +1143,7 @@
+ #define AR_PHY_PAPRD_CTRL1_PAPRD_MAG_SCALE_FACT		0x0ffe0000
+ #define AR_PHY_PAPRD_CTRL1_PAPRD_MAG_SCALE_FACT_S	17
+ 
+-#define AR_PHY_PAPRD_TRAINER_CNTL1(_ah) (AR_SM_BASE + (AR_SREV_9485(_ah) ? 0x580 : 0x490))
++#define AR_PHY_PAPRD_TRAINER_CNTL1(_ah) (AR_SM_BASE(_ah) + (AR_SREV_9485(_ah) ? 0x580 : 0x490))
+ 
+ #define AR_PHY_PAPRD_TRAINER_CNTL1_CF_CF_PAPRD_TRAIN_ENABLE	0x00000001
+ #define AR_PHY_PAPRD_TRAINER_CNTL1_CF_CF_PAPRD_TRAIN_ENABLE_S	0
+@@ -1160,12 +1160,12 @@
+ #define AR_PHY_PAPRD_TRAINER_CNTL1_CF_PAPRD_LB_SKIP		0x0003f000
+ #define AR_PHY_PAPRD_TRAINER_CNTL1_CF_PAPRD_LB_SKIP_S		12
+ 
+-#define AR_PHY_PAPRD_TRAINER_CNTL2(_ah) (AR_SM_BASE + (AR_SREV_9485(_ah) ? 0x584 : 0x494))
++#define AR_PHY_PAPRD_TRAINER_CNTL2(_ah) (AR_SM_BASE(_ah) + (AR_SREV_9485(_ah) ? 0x584 : 0x494))
+ 
+ #define AR_PHY_PAPRD_TRAINER_CNTL2_CF_PAPRD_INIT_RX_BB_GAIN	0xFFFFFFFF
+ #define AR_PHY_PAPRD_TRAINER_CNTL2_CF_PAPRD_INIT_RX_BB_GAIN_S	0
+ 
+-#define AR_PHY_PAPRD_TRAINER_CNTL3(_ah) (AR_SM_BASE + (AR_SREV_9485(_ah) ? 0x588 : 0x498))
++#define AR_PHY_PAPRD_TRAINER_CNTL3(_ah) (AR_SM_BASE(_ah) + (AR_SREV_9485(_ah) ? 0x588 : 0x498))
+ 
+ #define AR_PHY_PAPRD_TRAINER_CNTL3_CF_PAPRD_ADC_DESIRED_SIZE	0x0000003f
+ #define AR_PHY_PAPRD_TRAINER_CNTL3_CF_PAPRD_ADC_DESIRED_SIZE_S	0
+@@ -1182,7 +1182,7 @@
+ #define AR_PHY_PAPRD_TRAINER_CNTL3_CF_PAPRD_BBTXMIX_DISABLE	0x20000000
+ #define AR_PHY_PAPRD_TRAINER_CNTL3_CF_PAPRD_BBTXMIX_DISABLE_S	29
+ 
+-#define AR_PHY_PAPRD_TRAINER_CNTL4(_ah) (AR_SM_BASE + (AR_SREV_9485(_ah) ? 0x58c : 0x49c))
++#define AR_PHY_PAPRD_TRAINER_CNTL4(_ah) (AR_SM_BASE(_ah) + (AR_SREV_9485(_ah) ? 0x58c : 0x49c))
+ 
+ #define AR_PHY_PAPRD_TRAINER_CNTL4_CF_PAPRD_NUM_TRAIN_SAMPLES	0x03ff0000
+ #define AR_PHY_PAPRD_TRAINER_CNTL4_CF_PAPRD_NUM_TRAIN_SAMPLES_S	16
+@@ -1191,18 +1191,18 @@
+ #define AR_PHY_PAPRD_TRAINER_CNTL4_CF_PAPRD_MIN_CORR		0x00000fff
+ #define AR_PHY_PAPRD_TRAINER_CNTL4_CF_PAPRD_MIN_CORR_S		0
+ 
+-#define AR_PHY_PAPRD_PRE_POST_SCALE_0_B0			(AR_CHAN_BASE + 0x100)
+-#define AR_PHY_PAPRD_PRE_POST_SCALE_1_B0			(AR_CHAN_BASE + 0x104)
+-#define AR_PHY_PAPRD_PRE_POST_SCALE_2_B0			(AR_CHAN_BASE + 0x108)
+-#define AR_PHY_PAPRD_PRE_POST_SCALE_3_B0			(AR_CHAN_BASE + 0x10c)
+-#define AR_PHY_PAPRD_PRE_POST_SCALE_4_B0			(AR_CHAN_BASE + 0x110)
+-#define AR_PHY_PAPRD_PRE_POST_SCALE_5_B0			(AR_CHAN_BASE + 0x114)
+-#define AR_PHY_PAPRD_PRE_POST_SCALE_6_B0			(AR_CHAN_BASE + 0x118)
+-#define AR_PHY_PAPRD_PRE_POST_SCALE_7_B0			(AR_CHAN_BASE + 0x11c)
++#define AR_PHY_PAPRD_PRE_POST_SCALE_0_B0(_ah)			(AR_CHAN_BASE(_ah) + 0x100)
++#define AR_PHY_PAPRD_PRE_POST_SCALE_1_B0(_ah)			(AR_CHAN_BASE(_ah) + 0x104)
++#define AR_PHY_PAPRD_PRE_POST_SCALE_2_B0(_ah)			(AR_CHAN_BASE(_ah) + 0x108)
++#define AR_PHY_PAPRD_PRE_POST_SCALE_3_B0(_ah)			(AR_CHAN_BASE(_ah) + 0x10c)
++#define AR_PHY_PAPRD_PRE_POST_SCALE_4_B0(_ah)			(AR_CHAN_BASE(_ah) + 0x110)
++#define AR_PHY_PAPRD_PRE_POST_SCALE_5_B0(_ah)			(AR_CHAN_BASE(_ah) + 0x114)
++#define AR_PHY_PAPRD_PRE_POST_SCALE_6_B0(_ah)			(AR_CHAN_BASE(_ah) + 0x118)
++#define AR_PHY_PAPRD_PRE_POST_SCALE_7_B0(_ah)			(AR_CHAN_BASE(_ah) + 0x11c)
+ #define AR_PHY_PAPRD_PRE_POST_SCALING				0x3FFFF
+ #define AR_PHY_PAPRD_PRE_POST_SCALING_S				0
+ 
+-#define AR_PHY_PAPRD_TRAINER_STAT1(_ah) (AR_SM_BASE + (AR_SREV_9485(_ah) ? 0x590 : 0x4a0))
++#define AR_PHY_PAPRD_TRAINER_STAT1(_ah) (AR_SM_BASE(_ah) + (AR_SREV_9485(_ah) ? 0x590 : 0x4a0))
+ 
+ #define AR_PHY_PAPRD_TRAINER_STAT1_PAPRD_TRAIN_DONE		0x00000001
+ #define AR_PHY_PAPRD_TRAINER_STAT1_PAPRD_TRAIN_DONE_S		0
+@@ -1217,7 +1217,7 @@
+ #define AR_PHY_PAPRD_TRAINER_STAT1_PAPRD_AGC2_PWR		0x0001fe00
+ #define AR_PHY_PAPRD_TRAINER_STAT1_PAPRD_AGC2_PWR_S		9
+ 
+-#define AR_PHY_PAPRD_TRAINER_STAT2(_ah) (AR_SM_BASE + (AR_SREV_9485(_ah) ? 0x594 : 0x4a4))
++#define AR_PHY_PAPRD_TRAINER_STAT2(_ah) (AR_SM_BASE(_ah) + (AR_SREV_9485(_ah) ? 0x594 : 0x4a4))
+ 
+ #define AR_PHY_PAPRD_TRAINER_STAT2_PAPRD_FINE_VAL		0x0000ffff
+ #define AR_PHY_PAPRD_TRAINER_STAT2_PAPRD_FINE_VAL_S		0
+@@ -1226,30 +1226,30 @@
+ #define AR_PHY_PAPRD_TRAINER_STAT2_PAPRD_FINE_IDX		0x00600000
+ #define AR_PHY_PAPRD_TRAINER_STAT2_PAPRD_FINE_IDX_S		21
+ 
+-#define AR_PHY_PAPRD_TRAINER_STAT3(_ah) (AR_SM_BASE + (AR_SREV_9485(_ah) ? 0x598 : 0x4a8))
++#define AR_PHY_PAPRD_TRAINER_STAT3(_ah) (AR_SM_BASE(_ah) + (AR_SREV_9485(_ah) ? 0x598 : 0x4a8))
+ 
+ #define AR_PHY_PAPRD_TRAINER_STAT3_PAPRD_TRAIN_SAMPLES_CNT	0x000fffff
+ #define AR_PHY_PAPRD_TRAINER_STAT3_PAPRD_TRAIN_SAMPLES_CNT_S	0
+ 
+-#define AR_PHY_PAPRD_MEM_TAB_B0			(AR_CHAN_BASE + 0x120)
+-#define AR_PHY_PAPRD_MEM_TAB_B1			(AR_CHAN1_BASE + 0x120)
+-#define AR_PHY_PAPRD_MEM_TAB_B2			(AR_CHAN2_BASE + 0x120)
++#define AR_PHY_PAPRD_MEM_TAB_B0(_ah)		(AR_CHAN_BASE(_ah) + 0x120)
++#define AR_PHY_PAPRD_MEM_TAB_B1(_ah)		(AR_CHAN1_BASE(_ah) + 0x120)
++#define AR_PHY_PAPRD_MEM_TAB_B2(_ah)		(AR_CHAN2_BASE(_ah) + 0x120)
+ 
+-#define AR_PHY_PA_GAIN123_B0			(AR_CHAN_BASE + 0xf8)
+-#define AR_PHY_PA_GAIN123_B1			(AR_CHAN1_BASE + 0xf8)
+-#define AR_PHY_PA_GAIN123_B2			(AR_CHAN2_BASE + 0xf8)
++#define AR_PHY_PA_GAIN123_B0(_ah)		(AR_CHAN_BASE(_ah) + 0xf8)
++#define AR_PHY_PA_GAIN123_B1(_ah)		(AR_CHAN1_BASE(_ah) + 0xf8)
++#define AR_PHY_PA_GAIN123_B2(_ah)		(AR_CHAN2_BASE(_ah) + 0xf8)
+ #define AR_PHY_PA_GAIN123_PA_GAIN1		0x3FF
+ #define AR_PHY_PA_GAIN123_PA_GAIN1_S		0
+ 
+-#define AR_PHY_POWERTX_RATE5			(AR_SM_BASE + 0x1d0)
++#define AR_PHY_POWERTX_RATE5(_ah)		(AR_SM_BASE(_ah) + 0x1d0)
+ #define AR_PHY_POWERTX_RATE5_POWERTXHT20_0	0x3F
+ #define AR_PHY_POWERTX_RATE5_POWERTXHT20_0_S	0
+ 
+-#define AR_PHY_POWERTX_RATE6			(AR_SM_BASE + 0x1d4)
++#define AR_PHY_POWERTX_RATE6(_ah)		(AR_SM_BASE(_ah) + 0x1d4)
+ #define AR_PHY_POWERTX_RATE6_POWERTXHT20_5	0x3F00
+ #define AR_PHY_POWERTX_RATE6_POWERTXHT20_5_S	8
+ 
+-#define AR_PHY_POWERTX_RATE8			(AR_SM_BASE + 0x1dc)
++#define AR_PHY_POWERTX_RATE8(_ah)		(AR_SM_BASE(_ah) + 0x1dc)
+ #define AR_PHY_POWERTX_RATE8_POWERTXHT40_5	0x3F00
+ #define AR_PHY_POWERTX_RATE8_POWERTXHT40_5_S	8
+ 
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_rtt.c b/drivers/net/wireless/ath/ath9k/ar9003_rtt.c
+index e4d11fa7fe..99b1ef2aaa 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_rtt.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_rtt.c
+@@ -37,31 +37,31 @@
+ 
+ void ar9003_hw_rtt_enable(struct ath_hw *ah)
+ {
+-	REG_WRITE(ah, AR_PHY_RTT_CTRL, 1);
++	REG_WRITE(ah, AR_PHY_RTT_CTRL(ah), 1);
+ }
+ 
+ void ar9003_hw_rtt_disable(struct ath_hw *ah)
+ {
+-	REG_WRITE(ah, AR_PHY_RTT_CTRL, 0);
++	REG_WRITE(ah, AR_PHY_RTT_CTRL(ah), 0);
+ }
+ 
+ void ar9003_hw_rtt_set_mask(struct ath_hw *ah, u32 rtt_mask)
+ {
+-	REG_RMW_FIELD(ah, AR_PHY_RTT_CTRL,
++	REG_RMW_FIELD(ah, AR_PHY_RTT_CTRL(ah),
+ 		      AR_PHY_RTT_CTRL_RESTORE_MASK, rtt_mask);
+ }
+ 
+ bool ar9003_hw_rtt_force_restore(struct ath_hw *ah)
+ {
+-	if (!ath9k_hw_wait(ah, AR_PHY_RTT_CTRL,
++	if (!ath9k_hw_wait(ah, AR_PHY_RTT_CTRL(ah),
+ 			   AR_PHY_RTT_CTRL_FORCE_RADIO_RESTORE,
+ 			   0, RTT_RESTORE_TIMEOUT))
+ 		return false;
+ 
+-	REG_RMW_FIELD(ah, AR_PHY_RTT_CTRL,
++	REG_RMW_FIELD(ah, AR_PHY_RTT_CTRL(ah),
+ 		      AR_PHY_RTT_CTRL_FORCE_RADIO_RESTORE, 1);
+ 
+-	if (!ath9k_hw_wait(ah, AR_PHY_RTT_CTRL,
++	if (!ath9k_hw_wait(ah, AR_PHY_RTT_CTRL(ah),
+ 			   AR_PHY_RTT_CTRL_FORCE_RADIO_RESTORE,
+ 			   0, RTT_RESTORE_TIMEOUT))
+ 		return false;
+@@ -75,28 +75,28 @@ static void ar9003_hw_rtt_load_hist_entry(struct ath_hw *ah, u8 chain,
+ 	u32 val;
+ 
+ 	val = SM(data28, AR_PHY_RTT_SW_RTT_TABLE_DATA);
+-	REG_WRITE(ah, AR_PHY_RTT_TABLE_SW_INTF_1_B(chain), val);
++	REG_WRITE(ah, AR_PHY_RTT_TABLE_SW_INTF_1_B(ah, chain), val);
+ 
+ 	val = SM(0, AR_PHY_RTT_SW_RTT_TABLE_ACCESS) |
+ 	      SM(1, AR_PHY_RTT_SW_RTT_TABLE_WRITE) |
+ 	      SM(index, AR_PHY_RTT_SW_RTT_TABLE_ADDR);
+-	REG_WRITE(ah, AR_PHY_RTT_TABLE_SW_INTF_B(chain), val);
++	REG_WRITE(ah, AR_PHY_RTT_TABLE_SW_INTF_B(ah, chain), val);
+ 	udelay(1);
+ 
+ 	val |= SM(1, AR_PHY_RTT_SW_RTT_TABLE_ACCESS);
+-	REG_WRITE(ah, AR_PHY_RTT_TABLE_SW_INTF_B(chain), val);
++	REG_WRITE(ah, AR_PHY_RTT_TABLE_SW_INTF_B(ah, chain), val);
+ 	udelay(1);
+ 
+-	if (!ath9k_hw_wait(ah, AR_PHY_RTT_TABLE_SW_INTF_B(chain),
++	if (!ath9k_hw_wait(ah, AR_PHY_RTT_TABLE_SW_INTF_B(ah, chain),
+ 			   AR_PHY_RTT_SW_RTT_TABLE_ACCESS, 0,
+ 			   RTT_ACCESS_TIMEOUT))
+ 		return;
+ 
+ 	val &= ~SM(1, AR_PHY_RTT_SW_RTT_TABLE_WRITE);
+-	REG_WRITE(ah, AR_PHY_RTT_TABLE_SW_INTF_B(chain), val);
++	REG_WRITE(ah, AR_PHY_RTT_TABLE_SW_INTF_B(ah, chain), val);
+ 	udelay(1);
+ 
+-	ath9k_hw_wait(ah, AR_PHY_RTT_TABLE_SW_INTF_B(chain),
++	ath9k_hw_wait(ah, AR_PHY_RTT_TABLE_SW_INTF_B(ah, chain),
+ 		      AR_PHY_RTT_SW_RTT_TABLE_ACCESS, 0,
+ 		      RTT_ACCESS_TIMEOUT);
+ }
+@@ -147,19 +147,19 @@ static int ar9003_hw_rtt_fill_hist_entry(struct ath_hw *ah, u8 chain, u32 index)
+ 	      SM(0, AR_PHY_RTT_SW_RTT_TABLE_WRITE) |
+ 	      SM(index, AR_PHY_RTT_SW_RTT_TABLE_ADDR);
+ 
+-	REG_WRITE(ah, AR_PHY_RTT_TABLE_SW_INTF_B(chain), val);
++	REG_WRITE(ah, AR_PHY_RTT_TABLE_SW_INTF_B(ah, chain), val);
+ 	udelay(1);
+ 
+ 	val |= SM(1, AR_PHY_RTT_SW_RTT_TABLE_ACCESS);
+-	REG_WRITE(ah, AR_PHY_RTT_TABLE_SW_INTF_B(chain), val);
++	REG_WRITE(ah, AR_PHY_RTT_TABLE_SW_INTF_B(ah, chain), val);
+ 	udelay(1);
+ 
+-	if (!ath9k_hw_wait(ah, AR_PHY_RTT_TABLE_SW_INTF_B(chain),
++	if (!ath9k_hw_wait(ah, AR_PHY_RTT_TABLE_SW_INTF_B(ah, chain),
+ 			   AR_PHY_RTT_SW_RTT_TABLE_ACCESS, 0,
+ 			   RTT_ACCESS_TIMEOUT))
+ 		return RTT_BAD_VALUE;
+ 
+-	val = MS(REG_READ(ah, AR_PHY_RTT_TABLE_SW_INTF_1_B(chain)),
++	val = MS(REG_READ(ah, AR_PHY_RTT_TABLE_SW_INTF_1_B(ah, chain)),
+ 		 AR_PHY_RTT_SW_RTT_TABLE_DATA);
+ 
+ 
+diff --git a/drivers/net/wireless/ath/ath9k/reg.h b/drivers/net/wireless/ath/ath9k/reg.h
+index 9f5b8a5380..2e65105d30 100644
+--- a/drivers/net/wireless/ath/ath9k/reg.h
++++ b/drivers/net/wireless/ath/ath9k/reg.h
+@@ -2111,10 +2111,10 @@ enum {
+ 						     * pcu_txsm.
+ 						     */
+ 
+-#define AR9300_SM_BASE				0xa200
++#define AR9300_SM_BASE(_ah)			0xa200
+ #define AR9002_PHY_AGC_CONTROL			0x9860
+-#define AR9003_PHY_AGC_CONTROL			AR9300_SM_BASE + 0xc4
+-#define AR_PHY_AGC_CONTROL(_ah)			(AR_SREV_9300_20_OR_LATER(_ah) ? AR9003_PHY_AGC_CONTROL : AR9002_PHY_AGC_CONTROL)
++#define AR9003_PHY_AGC_CONTROL(_ah)		(AR9300_SM_BASE(_ah) + 0xc4)
++#define AR_PHY_AGC_CONTROL(_ah)			(AR_SREV_9300_20_OR_LATER(_ah) ? AR9003_PHY_AGC_CONTROL(_ah) : AR9002_PHY_AGC_CONTROL)
+ #define AR_PHY_AGC_CONTROL_CAL			0x00000001  /* do internal calibration */
+ #define AR_PHY_AGC_CONTROL_NF			0x00000002  /* do noise-floor calibration */
+ #define AR_PHY_AGC_CONTROL_OFFSET_CAL		0x00000800  /* allow offset calibration */
+diff --git a/drivers/net/wireless/ath/ath9k/reg_aic.h b/drivers/net/wireless/ath/ath9k/reg_aic.h
+index f50994910e..ab69460314 100644
+--- a/drivers/net/wireless/ath/ath9k/reg_aic.h
++++ b/drivers/net/wireless/ath/ath9k/reg_aic.h
+@@ -17,32 +17,32 @@
+ #ifndef REG_AIC_H
+ #define REG_AIC_H
+ 
+-#define AR_PHY_AIC_CTRL_0_B0                    (AR_SM_BASE + 0x4b0)
+-#define AR_PHY_AIC_CTRL_1_B0                    (AR_SM_BASE + 0x4b4)
+-#define AR_PHY_AIC_CTRL_2_B0                    (AR_SM_BASE + 0x4b8)
+-#define AR_PHY_AIC_CTRL_3_B0                    (AR_SM_BASE + 0x4bc)
+-#define AR_PHY_AIC_CTRL_4_B0                    (AR_SM_BASE + 0x4c0)
++#define AR_PHY_AIC_CTRL_0_B0(_ah)               (AR_SM_BASE(_ah) + 0x4b0)
++#define AR_PHY_AIC_CTRL_1_B0(_ah)               (AR_SM_BASE(_ah) + 0x4b4)
++#define AR_PHY_AIC_CTRL_2_B0(_ah)               (AR_SM_BASE(_ah) + 0x4b8)
++#define AR_PHY_AIC_CTRL_3_B0(_ah)               (AR_SM_BASE(_ah) + 0x4bc)
++#define AR_PHY_AIC_CTRL_4_B0(_ah)               (AR_SM_BASE(_ah) + 0x4c0)
+ 
+-#define AR_PHY_AIC_STAT_0_B0                    (AR_SM_BASE + 0x4c4)
+-#define AR_PHY_AIC_STAT_1_B0                    (AR_SM_BASE + 0x4c8)
+-#define AR_PHY_AIC_STAT_2_B0                    (AR_SM_BASE + 0x4cc)
++#define AR_PHY_AIC_STAT_0_B0(_ah)               (AR_SM_BASE(_ah) + 0x4c4)
++#define AR_PHY_AIC_STAT_1_B0(_ah)               (AR_SM_BASE(_ah) + 0x4c8)
++#define AR_PHY_AIC_STAT_2_B0(_ah)               (AR_SM_BASE(_ah) + 0x4cc)
+ 
+-#define AR_PHY_AIC_CTRL_0_B1                    (AR_SM1_BASE + 0x4b0)
+-#define AR_PHY_AIC_CTRL_1_B1                    (AR_SM1_BASE + 0x4b4)
+-#define AR_PHY_AIC_CTRL_4_B1                    (AR_SM1_BASE + 0x4c0)
++#define AR_PHY_AIC_CTRL_0_B1(_ah)               (AR_SM1_BASE(_ah) + 0x4b0)
++#define AR_PHY_AIC_CTRL_1_B1(_ah)               (AR_SM1_BASE(_ah) + 0x4b4)
++#define AR_PHY_AIC_CTRL_4_B1(_ah)               (AR_SM1_BASE(_ah) + 0x4c0)
+ 
+-#define AR_PHY_AIC_STAT_0_B1                    (AR_SM1_BASE + 0x4c4)
+-#define AR_PHY_AIC_STAT_1_B1                    (AR_SM1_BASE + 0x4c8)
+-#define AR_PHY_AIC_STAT_2_B1                    (AR_SM1_BASE + 0x4cc)
++#define AR_PHY_AIC_STAT_0_B1(_ah)               (AR_SM1_BASE(_ah) + 0x4c4)
++#define AR_PHY_AIC_STAT_1_B1(_ah)               (AR_SM1_BASE(_ah) + 0x4c8)
++#define AR_PHY_AIC_STAT_2_B1(_ah)               (AR_SM1_BASE(_ah) + 0x4cc)
+ 
+-#define AR_PHY_AIC_SRAM_ADDR_B0                 (AR_SM_BASE + 0x5f0)
+-#define AR_PHY_AIC_SRAM_DATA_B0                 (AR_SM_BASE + 0x5f4)
++#define AR_PHY_AIC_SRAM_ADDR_B0(_ah)            (AR_SM_BASE(_ah) + 0x5f0)
++#define AR_PHY_AIC_SRAM_DATA_B0(_ah)            (AR_SM_BASE(_ah) + 0x5f4)
+ 
+-#define AR_PHY_AIC_SRAM_ADDR_B1                 (AR_SM1_BASE + 0x5f0)
+-#define AR_PHY_AIC_SRAM_DATA_B1                 (AR_SM1_BASE + 0x5f4)
++#define AR_PHY_AIC_SRAM_ADDR_B1(_ah)            (AR_SM1_BASE(_ah) + 0x5f0)
++#define AR_PHY_AIC_SRAM_DATA_B1(_ah)            (AR_SM1_BASE(_ah) + 0x5f4)
+ 
+-#define AR_PHY_BT_COEX_4                        (AR_AGC_BASE + 0x60)
+-#define AR_PHY_BT_COEX_5                        (AR_AGC_BASE + 0x64)
++#define AR_PHY_BT_COEX_4(_ah)                   (AR_AGC_BASE(_ah) + 0x60)
++#define AR_PHY_BT_COEX_5(_ah)                   (AR_AGC_BASE(_ah) + 0x64)
+ 
+ /* AIC fields */
+ #define AR_PHY_AIC_MON_ENABLE                   0x80000000
+diff --git a/drivers/net/wireless/ath/ath9k/rng.c b/drivers/net/wireless/ath/ath9k/rng.c
+index e1def77591..42b313c230 100644
+--- a/drivers/net/wireless/ath/ath9k/rng.c
++++ b/drivers/net/wireless/ath/ath9k/rng.c
+@@ -34,8 +34,8 @@ static int ath9k_rng_data_read(struct ath_softc *sc, u32 *buf, u32 buf_size)
+ 	REG_RMW_FIELD(ah, AR_PHY_TEST_CTL_STATUS(ah), AR_PHY_TEST_CTL_RX_OBS_SEL, 0);
+ 
+ 	for (i = 0, j = 0; i < buf_size; i++) {
+-		v1 = REG_READ(ah, AR_PHY_TST_ADC) & 0xffff;
+-		v2 = REG_READ(ah, AR_PHY_TST_ADC) & 0xffff;
++		v1 = REG_READ(ah, AR_PHY_TST_ADC(ah)) & 0xffff;
++		v2 = REG_READ(ah, AR_PHY_TST_ADC(ah)) & 0xffff;
+ 
+ 		/* wait for data ready */
+ 		if (v1 && v2 && rng_last != v1 && v1 != v2 && v1 != 0xffff &&
+-- 
+2.34.1
+
diff --git a/package/feeds/base/mac80211/patches/ath9k/004-Revert-ath9k_hw-fall-back-to-OTP-ROM-when-platfor.patch b/package/feeds/base/mac80211/patches/ath9k/004-Revert-ath9k_hw-fall-back-to-OTP-ROM-when-platfor.patch
new file mode 100644
index 0000000000..c6f69912b8
--- /dev/null
+++ b/package/feeds/base/mac80211/patches/ath9k/004-Revert-ath9k_hw-fall-back-to-OTP-ROM-when-platfor.patch
@@ -0,0 +1,48 @@
+From 49fb2ee3887979e3e86708cf8eff7d2374a90d80 Mon Sep 17 00:00:00 2001
+From: Wenli Looi <wlooi@ucalgary.ca>
+Date: Tue, 11 Apr 2023 05:21:04 +0000
+Subject: [PATCH v3 04/11] Revert "ath9k_hw: fall back to OTP ROM when platform
+ data has no valid eeprom data"
+
+This reverts commit 01967360a20598f95947a86af26c930ab1b50205.
+
+QCN5502 is a 4-stream device, so 0xff is the normal txrxMask. Users
+currently relying on this silent fallback will need to stop providing
+invalid EEPROM data to the driver.
+
+Signed-off-by: Wenli Looi <wlooi@ucalgary.ca>
+---
+ drivers/net/wireless/ath/ath9k/ar9003_eeprom.c | 15 ++-------------
+ 1 file changed, 2 insertions(+), 13 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+index 3dab290d8a..0f8af8c958 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+@@ -3321,21 +3321,10 @@ static int ar9300_eeprom_restore_internal(struct ath_hw *ah,
+ 	int it;
+ 	u16 checksum, mchecksum;
+ 	struct ath_common *common = ath9k_hw_common(ah);
+-	struct ar9300_eeprom *eep;
+ 	eeprom_read_op read;
+ 
+-	if (ath9k_hw_use_flash(ah)) {
+-		u8 txrx;
+-
+-		if (ar9300_eeprom_restore_flash(ah, mptr, mdata_size))
+-			return -EIO;
+-
+-		/* check if eeprom contains valid data */
+-		eep = (struct ar9300_eeprom *) mptr;
+-		txrx = eep->baseEepHeader.txrxMask;
+-		if (txrx != 0 && txrx != 0xff)
+-			return 0;
+-	}
++	if (ath9k_hw_use_flash(ah))
++		return ar9300_eeprom_restore_flash(ah, mptr, mdata_size);
+ 
+ 	word = kzalloc(2048, GFP_KERNEL);
+ 	if (!word)
+-- 
+2.34.1
+
diff --git a/package/feeds/base/mac80211/patches/ath9k/005-wifi-ath9k-add-QCN550x-device-IDs.patch b/package/feeds/base/mac80211/patches/ath9k/005-wifi-ath9k-add-QCN550x-device-IDs.patch
new file mode 100644
index 0000000000..90094c07d0
--- /dev/null
+++ b/package/feeds/base/mac80211/patches/ath9k/005-wifi-ath9k-add-QCN550x-device-IDs.patch
@@ -0,0 +1,110 @@
+From 926b8ecb846dfb9637b8d4f1f2cc80064a3623de Mon Sep 17 00:00:00 2001
+From: Wenli Looi <wlooi@ucalgary.ca>
+Date: Mon, 18 Apr 2022 05:13:45 +0000
+Subject: [PATCH v3 05/11] wifi: ath9k: add QCN550x device IDs
+
+Adds the device ID constants and augments the initialization code to
+recognize the device.
+
+Signed-off-by: Wenli Looi <wlooi@ucalgary.ca>
+---
+ drivers/net/wireless/ath/ath9k/ahb.c | 4 ++++
+ drivers/net/wireless/ath/ath9k/hw.c  | 6 ++++++
+ drivers/net/wireless/ath/ath9k/hw.h  | 1 +
+ drivers/net/wireless/ath/ath9k/reg.h | 5 ++++-
+ 4 files changed, 15 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/net/wireless/ath/ath9k/ahb.c b/drivers/net/wireless/ath/ath9k/ahb.c
+index 9cd12b20b1..1835b4469e 100644
+--- a/drivers/net/wireless/ath/ath9k/ahb.c
++++ b/drivers/net/wireless/ath/ath9k/ahb.c
+@@ -47,6 +47,10 @@ static const struct platform_device_id ath9k_platform_id_table[] = {
+ 		.name = "qca956x_wmac",
+ 		.driver_data = AR9300_DEVID_QCA956X,
+ 	},
++	{
++		.name = "qcn550x_wmac",
++		.driver_data = AR9300_DEVID_QCN550X,
++	},
+ 	{},
+ };
+ 
+diff --git a/drivers/net/wireless/ath/ath9k/hw.c b/drivers/net/wireless/ath/ath9k/hw.c
+index 5982e0db45..e63314544a 100644
+--- a/drivers/net/wireless/ath/ath9k/hw.c
++++ b/drivers/net/wireless/ath/ath9k/hw.c
+@@ -282,6 +282,9 @@ static bool ath9k_hw_read_revisions(struct ath_hw *ah)
+ 	case AR9300_DEVID_QCA956X:
+ 		ah->hw_version.macVersion = AR_SREV_VERSION_9561;
+ 		return true;
++	case AR9300_DEVID_QCN550X:
++		ah->hw_version.macVersion = AR_SREV_VERSION_5502;
++		return true;
+ 	}
+ 
+ 	srev = REG_READ(ah, AR_SREV(ah));
+@@ -592,6 +595,7 @@ static int __ath9k_hw_init(struct ath_hw *ah)
+ 	case AR_SREV_VERSION_9565:
+ 	case AR_SREV_VERSION_9531:
+ 	case AR_SREV_VERSION_9561:
++	case AR_SREV_VERSION_5502:
+ 		break;
+ 	default:
+ 		ath_err(common,
+@@ -688,6 +692,7 @@ int ath9k_hw_init(struct ath_hw *ah)
+ 	case AR9300_DEVID_AR9565:
+ 	case AR9300_DEVID_AR953X:
+ 	case AR9300_DEVID_QCA956X:
++	case AR9300_DEVID_QCN550X:
+ 		break;
+ 	default:
+ 		if (common->bus_ops->ath_bus_type == ATH_USB)
+@@ -3315,6 +3320,7 @@ static struct {
+ 	{ AR_SREV_VERSION_9565,         "9565" },
+ 	{ AR_SREV_VERSION_9531,         "9531" },
+ 	{ AR_SREV_VERSION_9561,         "9561" },
++	{ AR_SREV_VERSION_5502,         "5502" },
+ };
+ 
+ /* For devices with external radios */
+diff --git a/drivers/net/wireless/ath/ath9k/hw.h b/drivers/net/wireless/ath/ath9k/hw.h
+index 450ab19b1d..2349d0e93c 100644
+--- a/drivers/net/wireless/ath/ath9k/hw.h
++++ b/drivers/net/wireless/ath/ath9k/hw.h
+@@ -56,6 +56,7 @@
+ #define AR9300_DEVID_AR9565     0x0036
+ #define AR9300_DEVID_AR953X     0x003d
+ #define AR9300_DEVID_QCA956X    0x003f
++#define AR9300_DEVID_QCN550X    0x0040
+ 
+ #define AR5416_AR9100_DEVID	0x000b
+ 
+diff --git a/drivers/net/wireless/ath/ath9k/reg.h b/drivers/net/wireless/ath/ath9k/reg.h
+index 2e65105d30..75a9651983 100644
+--- a/drivers/net/wireless/ath/ath9k/reg.h
++++ b/drivers/net/wireless/ath/ath9k/reg.h
+@@ -825,6 +825,7 @@
+ #define AR_SREV_REVISION_9531_11        1
+ #define AR_SREV_REVISION_9531_20        2
+ #define AR_SREV_VERSION_9561            0x600
++#define AR_SREV_VERSION_5502            0x700
+ 
+ #define AR_SREV_5416(_ah) \
+ 	(((_ah)->hw_version.macVersion == AR_SREV_VERSION_5416_PCI) || \
+@@ -992,10 +993,12 @@
+ 
+ #define AR_SREV_9561(_ah) \
+ 	(((_ah)->hw_version.macVersion == AR_SREV_VERSION_9561))
++#define AR_SREV_5502(_ah) \
++	(((_ah)->hw_version.macVersion == AR_SREV_VERSION_5502))
+ 
+ #define AR_SREV_SOC(_ah) \
+ 	(AR_SREV_9340(_ah) || AR_SREV_9531(_ah) || AR_SREV_9550(_ah) || \
+-	 AR_SREV_9561(_ah))
++	 AR_SREV_9561(_ah) || AR_SREV_5502(_ah))
+ 
+ /* NOTE: When adding chips newer than Peacock, add chip check here */
+ #define AR_SREV_9580_10_OR_LATER(_ah) \
+-- 
+2.34.1
+
diff --git a/package/feeds/base/mac80211/patches/ath9k/006-wifi-ath9k-basic-support-for-QCN550x.patch b/package/feeds/base/mac80211/patches/ath9k/006-wifi-ath9k-basic-support-for-QCN550x.patch
new file mode 100644
index 0000000000..65a8af4920
--- /dev/null
+++ b/package/feeds/base/mac80211/patches/ath9k/006-wifi-ath9k-basic-support-for-QCN550x.patch
@@ -0,0 +1,734 @@
+From 0a4d765aef69660e4fb79a62023062a6acbaa03e Mon Sep 17 00:00:00 2001
+From: Wenli Looi <wlooi@ucalgary.ca>
+Date: Tue, 11 Apr 2023 03:15:17 +0000
+Subject: [PATCH v3 06/11] wifi: ath9k: basic support for QCN550x
+
+QCN550x is very similar to QCA956x. Note that AR_CH0_XTAL is
+intentionally unchanged.
+
+Signed-off-by: Wenli Looi <wlooi@ucalgary.ca>
+---
+ drivers/net/wireless/ath/ath9k/ani.c          |  2 +-
+ drivers/net/wireless/ath/ath9k/ar9003_calib.c |  4 +-
+ .../net/wireless/ath/ath9k/ar9003_eeprom.c    | 37 ++++++--
+ drivers/net/wireless/ath/ath9k/ar9003_paprd.c |  4 +-
+ drivers/net/wireless/ath/ath9k/ar9003_phy.c   | 48 ++++++----
+ drivers/net/wireless/ath/ath9k/ar9003_phy.h   | 91 +++++++++++++------
+ drivers/net/wireless/ath/ath9k/hw.c           | 33 ++++---
+ drivers/net/wireless/ath/ath9k/mac.c          |  2 +-
+ drivers/net/wireless/ath/ath9k/recv.c         |  2 +-
+ drivers/net/wireless/ath/ath9k/reg.h          |  4 +-
+ 10 files changed, 149 insertions(+), 78 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath9k/ani.c b/drivers/net/wireless/ath/ath9k/ani.c
+index 41d192709e..281103865d 100644
+--- a/drivers/net/wireless/ath/ath9k/ani.c
++++ b/drivers/net/wireless/ath/ath9k/ani.c
+@@ -261,7 +261,7 @@ static void ath9k_hw_set_cck_nil(struct ath_hw *ah, u_int8_t immunityLevel,
+ 
+ 	/* Skip MRC CCK for pre AR9003 families */
+ 	if (!AR_SREV_9300_20_OR_LATER(ah) || AR_SREV_9485(ah) ||
+-	    AR_SREV_9565(ah) || AR_SREV_9561(ah))
++	    AR_SREV_9565(ah) || AR_SREV_9561(ah) || AR_SREV_5502(ah))
+ 		return;
+ 
+ 	if (aniState->mrcCCK != entry_cck->mrc_cck_on)
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_calib.c b/drivers/net/wireless/ath/ath9k/ar9003_calib.c
+index 6d1f1242e6..95475e02af 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_calib.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_calib.c
+@@ -201,7 +201,7 @@ static void ar9003_hw_iqcalibrate(struct ath_hw *ah, u8 numChains)
+ 	u32 qCoffDenom, iCoffDenom;
+ 	int32_t qCoff, iCoff;
+ 	int iqCorrNeg, i;
+-	static const u_int32_t offset_array[3] = {
++	const u_int32_t offset_array[3] = {
+ 		AR_PHY_RX_IQCAL_CORR_B0(ah),
+ 		AR_PHY_RX_IQCAL_CORR_B1(ah),
+ 		AR_PHY_RX_IQCAL_CORR_B2(ah),
+@@ -1202,7 +1202,7 @@ static void ar9003_hw_manual_peak_cal(struct ath_hw *ah, u8 chain, bool is_2g)
+ 
+ 	if (AR_SREV_9550(ah) || AR_SREV_9531(ah))
+ 		peak_detect_threshold = 8;
+-	else if (AR_SREV_9561(ah))
++	else if (AR_SREV_9561(ah) || AR_SREV_5502(ah))
+ 		peak_detect_threshold = 11;
+ 
+ 	/*
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+index 0f8af8c958..810d75f553 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+@@ -3619,6 +3619,8 @@ static void ar9003_hw_xpa_bias_level_apply(struct ath_hw *ah, bool is2ghz)
+ 	if (AR_SREV_9485(ah) || AR_SREV_9330(ah) || AR_SREV_9340(ah) ||
+ 	    AR_SREV_9531(ah) || AR_SREV_9561(ah))
+ 		REG_RMW_FIELD(ah, AR_CH0_TOP2(ah), AR_CH0_TOP2_XPABIASLVL, bias);
++	else if (AR_SREV_5502(ah))
++		REG_RMW_FIELD(ah, AR_CH0_TOP3, AR_CH0_TOP3_XPABIASLVL, bias);
+ 	else if (AR_SREV_9462(ah) || AR_SREV_9550(ah) || AR_SREV_9565(ah))
+ 		REG_RMW_FIELD(ah, AR_CH0_TOP(ah), AR_CH0_TOP_XPABIASLVL, bias);
+ 	else {
+@@ -3637,7 +3639,7 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
+ 	struct ath9k_hw_capabilities *pCap = &ah->caps;
+ 	int chain;
+ 	u32 regval, value, gpio;
+-	static const u32 switch_chain_reg[AR9300_MAX_CHAINS] = {
++	const u32 switch_chain_reg[AR9300_MAX_CHAINS] = {
+ 			AR_PHY_SWITCH_CHAIN_0(ah),
+ 			AR_PHY_SWITCH_CHAIN_1(ah),
+ 			AR_PHY_SWITCH_CHAIN_2(ah),
+@@ -3658,7 +3660,8 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
+ 	if (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {
+ 		REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM(ah),
+ 				AR_SWITCH_TABLE_COM_AR9462_ALL, value);
+-	} else if (AR_SREV_9550(ah) || AR_SREV_9531(ah) || AR_SREV_9561(ah)) {
++	} else if (AR_SREV_9550(ah) || AR_SREV_9531(ah) || AR_SREV_9561(ah) ||
++		   AR_SREV_5502(ah)) {
+ 		REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM(ah),
+ 				AR_SWITCH_TABLE_COM_AR9550_ALL, value);
+ 	} else
+@@ -3989,11 +3992,11 @@ void ar9003_hw_internal_regulator_apply(struct ath_hw *ah)
+ 			if (!is_pmu_set(ah, AR_PHY_PMU2(ah), reg_pmu_set))
+ 				return;
+ 		} else if (AR_SREV_9462(ah) || AR_SREV_9565(ah) ||
+-			   AR_SREV_9561(ah)) {
++			   AR_SREV_9561(ah) || AR_SREV_5502(ah)) {
+ 			reg_val = le32_to_cpu(pBase->swreg);
+ 			REG_WRITE(ah, AR_PHY_PMU1(ah), reg_val);
+ 
+-			if (AR_SREV_9561(ah))
++			if (AR_SREV_9561(ah) || AR_SREV_5502(ah))
+ 				REG_WRITE(ah, AR_PHY_PMU2(ah), 0x10200000);
+ 		} else {
+ 			/* Internal regulator is ON. Write swreg register. */
+@@ -4037,17 +4040,23 @@ void ar9003_hw_internal_regulator_apply(struct ath_hw *ah)
+ static void ar9003_hw_apply_tuning_caps(struct ath_hw *ah)
+ {
+ 	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	u8 tuning_caps_param = eep->baseEepHeader.params_for_tuning_caps[0];
++	u8 param_0, param_1;
+ 
+ 	if (AR_SREV_9340(ah) || AR_SREV_9531(ah))
+ 		return;
+ 
+ 	if (eep->baseEepHeader.featureEnable & 0x40) {
+-		tuning_caps_param &= 0x7f;
++		param_0 = eep->baseEepHeader.params_for_tuning_caps[0];
++		if (AR_SREV_5502(ah)) {
++			param_1 = eep->baseEepHeader.params_for_tuning_caps[1];
++		} else {
++			param_0 &= 0x7f;
++			param_1 = param_0;
++		}
+ 		REG_RMW_FIELD(ah, AR_CH0_XTAL(ah), AR_CH0_XTAL_CAPINDAC,
+-			      tuning_caps_param);
++			      param_0);
+ 		REG_RMW_FIELD(ah, AR_CH0_XTAL(ah), AR_CH0_XTAL_CAPOUTDAC,
+-			      tuning_caps_param);
++			      param_1);
+ 	}
+ }
+ 
+@@ -4098,7 +4107,8 @@ static void ar9003_hw_xpa_timing_control_apply(struct ath_hw *ah, bool is2ghz)
+ 	    !AR_SREV_9340(ah) &&
+ 	    !AR_SREV_9580(ah) &&
+ 	    !AR_SREV_9531(ah) &&
+-	    !AR_SREV_9561(ah))
++	    !AR_SREV_9561(ah) &&
++	    !AR_SREV_5502(ah))
+ 		return;
+ 
+ 	xpa_ctl = ar9003_modal_header(ah, is2ghz)->txFrameToXpaOn;
+@@ -4878,7 +4888,8 @@ static void ar9003_hw_power_control_override(struct ath_hw *ah,
+ 	}
+ 
+ tempslope:
+-	if (AR_SREV_9550(ah) || AR_SREV_9531(ah) || AR_SREV_9561(ah)) {
++	if (AR_SREV_9550(ah) || AR_SREV_9531(ah) || AR_SREV_9561(ah) ||
++	    AR_SREV_5502(ah)) {
+ 		u8 txmask = (eep->baseEepHeader.txrxMask & 0xf0) >> 4;
+ 
+ 		/*
+@@ -4940,6 +4951,12 @@ static void ar9003_hw_power_control_override(struct ath_hw *ah,
+ 
+ 	REG_RMW_FIELD(ah, AR_PHY_TPC_18(ah), AR_PHY_TPC_18_THERM_CAL_VALUE,
+ 		      temperature[0]);
++	if (AR_SREV_5502(ah)) {
++		REG_RMW_FIELD(ah, AR_PHY_TPC_18_B1(ah),
++			      AR_PHY_TPC_18_THERM_CAL_VALUE, temperature[1]);
++		REG_RMW_FIELD(ah, AR_PHY_TPC_18_B2(ah),
++			      AR_PHY_TPC_18_THERM_CAL_VALUE, temperature[2]);
++	}
+ }
+ 
+ /* Apply the recorded correction values. */
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_paprd.c b/drivers/net/wireless/ath/ath9k/ar9003_paprd.c
+index 28192df046..ec2d38f13d 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_paprd.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_paprd.c
+@@ -138,12 +138,12 @@ static int ar9003_get_training_power_5g(struct ath_hw *ah)
+ static int ar9003_paprd_setup_single_table(struct ath_hw *ah)
+ {
+ 	struct ath_common *common = ath9k_hw_common(ah);
+-	static const u32 ctrl0[3] = {
++	const u32 ctrl0[3] = {
+ 		AR_PHY_PAPRD_CTRL0_B0(ah),
+ 		AR_PHY_PAPRD_CTRL0_B1(ah),
+ 		AR_PHY_PAPRD_CTRL0_B2(ah)
+ 	};
+-	static const u32 ctrl1[3] = {
++	const u32 ctrl1[3] = {
+ 		AR_PHY_PAPRD_CTRL1_B0(ah),
+ 		AR_PHY_PAPRD_CTRL1_B1(ah),
+ 		AR_PHY_PAPRD_CTRL1_B2(ah)
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_phy.c b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
+index 7944d12f2e..1009739f0d 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
+@@ -146,6 +146,7 @@ static const u8 mcs2pwr_ht40[] = {
+  * Channel Frequency = (3/2) * freq_ref * (chansel[8:0] + chanfrac[16:0]/2^17)
+  * (freq_ref = 40MHz)
+  */
++
+ static int ar9003_hw_set_channel(struct ath_hw *ah, struct ath9k_channel *chan)
+ {
+ 	u16 bMode, fracMode = 0, aModeRefSel = 0;
+@@ -157,14 +158,17 @@ static int ar9003_hw_set_channel(struct ath_hw *ah, struct ath9k_channel *chan)
+ 	freq = centers.synth_center;
+ 
+ 	if (freq < 4800) {     /* 2 GHz, fractional mode */
+-		if (AR_SREV_9330(ah) || AR_SREV_9485(ah) ||
+-		    AR_SREV_9531(ah) || AR_SREV_9550(ah) ||
+-		    AR_SREV_9561(ah) || AR_SREV_9565(ah)) {
++		if (AR_SREV_9330(ah) || AR_SREV_9485(ah) || AR_SREV_9531(ah) ||
++		    AR_SREV_9550(ah) || AR_SREV_9561(ah) || AR_SREV_5502(ah) ||
++		    AR_SREV_9565(ah)) {
+ 			if (ah->is_clk_25mhz)
+ 				div = 75;
+ 			else
+ 				div = 120;
+ 
++			/* Clock doubler is on for QCN5502. */
++			if (AR_SREV_5502(ah)) div <<= 1;
++
+ 			channelSel = (freq * 4) / div;
+ 			chan_frac = (((freq * 4) % div) * 0x20000) / div;
+ 			channelSel = (channelSel << 17) | chan_frac;
+@@ -182,11 +186,16 @@ static int ar9003_hw_set_channel(struct ath_hw *ah, struct ath9k_channel *chan)
+ 		/* Set to 2G mode */
+ 		bMode = 1;
+ 	} else {
+-		if ((AR_SREV_9340(ah) || AR_SREV_9550(ah) ||
+-		     AR_SREV_9531(ah) || AR_SREV_9561(ah)) &&
++		if ((AR_SREV_9340(ah) || AR_SREV_9550(ah) || AR_SREV_9531(ah) ||
++		     AR_SREV_9561(ah) || AR_SREV_5502(ah)) &&
+ 		    ah->is_clk_25mhz) {
+-			channelSel = freq / 75;
+-			chan_frac = ((freq % 75) * 0x20000) / 75;
++			div = 75;
++
++			/* Clock doubler is on for QCN5502. */
++			if (AR_SREV_5502(ah)) div <<= 1;
++
++			channelSel = freq / div;
++			chan_frac = ((freq % div) * 0x20000) / div;
+ 			channelSel = (channelSel << 17) | chan_frac;
+ 		} else {
+ 			channelSel = CHANSEL_5G(freq);
+@@ -250,7 +259,7 @@ static void ar9003_hw_spur_mitigate_mrc_cck(struct ath_hw *ah,
+ 	 */
+ 
+ 	if (AR_SREV_9485(ah) || AR_SREV_9340(ah) || AR_SREV_9330(ah) ||
+-	    AR_SREV_9550(ah) || AR_SREV_9561(ah)) {
++	    AR_SREV_9550(ah) || AR_SREV_9561(ah) || AR_SREV_5502(ah)) {
+ 		if (spur_fbin_ptr[0] == 0) /* No spur */
+ 			return;
+ 		max_spur_cnts = 5;
+@@ -277,7 +286,7 @@ static void ar9003_hw_spur_mitigate_mrc_cck(struct ath_hw *ah,
+ 
+ 		negative = 0;
+ 		if (AR_SREV_9485(ah) || AR_SREV_9340(ah) || AR_SREV_9330(ah) ||
+-		    AR_SREV_9550(ah) || AR_SREV_9561(ah))
++		    AR_SREV_9550(ah) || AR_SREV_9561(ah) || AR_SREV_5502(ah))
+ 			cur_bb_spur = ath9k_hw_fbin2freq(spur_fbin_ptr[i],
+ 							 IS_CHAN_2GHZ(chan));
+ 		else
+@@ -619,7 +628,7 @@ static void ar9003_hw_set_channel_regs(struct ath_hw *ah,
+ 	/* Enable 11n HT, 20 MHz */
+ 	phymode = AR_PHY_GC_HT_EN | AR_PHY_GC_SHORT_GI_40 | enableDacFifo;
+ 
+-	if (!AR_SREV_9561(ah))
++	if (!(AR_SREV_9561(ah) || AR_SREV_5502(ah)))
+ 		phymode |= AR_PHY_GC_SINGLE_HT_LTF1;
+ 
+ 	/* Configure baseband for dynamic 20/40 operation */
+@@ -724,7 +733,7 @@ static void ar9003_hw_override_ini(struct ath_hw *ah)
+ 		ah->enabled_cals &= ~TX_CL_CAL;
+ 
+ 	if (AR_SREV_9340(ah) || AR_SREV_9531(ah) || AR_SREV_9550(ah) ||
+-	    AR_SREV_9561(ah)) {
++	    AR_SREV_9561(ah) || AR_SREV_5502(ah)) {
+ 		if (ah->is_clk_25mhz) {
+ 			REG_WRITE(ah, AR_RTC_DERIVED_CLK(ah), 0x17c << 1);
+ 			REG_WRITE(ah, AR_SLP32_MODE, 0x0010f3d7);
+@@ -905,23 +914,25 @@ static int ar9003_hw_process_ini(struct ath_hw *ah,
+ 		}
+ 	}
+ 
+-	if (AR_SREV_9550(ah) || AR_SREV_9561(ah))
++	if (AR_SREV_9550(ah) || AR_SREV_9561(ah) || AR_SREV_5502(ah))
+ 		REG_WRITE_ARRAY(&ah->ini_modes_rx_gain_bounds, modesIndex,
+ 				regWrites);
+ 
+-	if (AR_SREV_9561(ah) && (ar9003_hw_get_rx_gain_idx(ah) == 0))
++	if ((AR_SREV_9561(ah) || AR_SREV_5502(ah)) &&
++	    (ar9003_hw_get_rx_gain_idx(ah) == 0))
+ 		REG_WRITE_ARRAY(&ah->ini_modes_rxgain_xlna,
+ 				modesIndex, regWrites);
+ 	/*
+ 	 * TXGAIN initvals.
+ 	 */
+-	if (AR_SREV_9550(ah) || AR_SREV_9531(ah) || AR_SREV_9561(ah)) {
++	if (AR_SREV_9550(ah) || AR_SREV_9531(ah) || AR_SREV_9561(ah) ||
++	    AR_SREV_5502(ah)) {
+ 		u32 modes_txgain_index = 1;
+ 
+ 		if (AR_SREV_9550(ah))
+ 			modes_txgain_index = ar9550_hw_get_modes_txgain_index(ah, chan);
+ 
+-		if (AR_SREV_9561(ah))
++		if (AR_SREV_9561(ah) || AR_SREV_5502(ah))
+ 			modes_txgain_index =
+ 				ar9561_hw_get_modes_txgain_index(ah, chan);
+ 
+@@ -1922,7 +1933,7 @@ void ar9003_hw_attach_phy_ops(struct ath_hw *ah)
+ {
+ 	struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
+ 	struct ath_hw_ops *ops = ath9k_hw_ops(ah);
+-	static const u32 ar9300_cca_regs[6] = {
++	const u32 ar9300_cca_regs[6] = {
+ 		AR_PHY_CCA_0(ah),
+ 		AR_PHY_CCA_1(ah),
+ 		AR_PHY_CCA_2(ah),
+@@ -1935,7 +1946,7 @@ void ar9003_hw_attach_phy_ops(struct ath_hw *ah)
+ 	priv_ops->spur_mitigate_freq = ar9003_hw_spur_mitigate;
+ 
+ 	if (AR_SREV_9340(ah) || AR_SREV_9550(ah) || AR_SREV_9531(ah) ||
+-	    AR_SREV_9561(ah))
++	    AR_SREV_9561(ah) || AR_SREV_5502(ah))
+ 		priv_ops->compute_pll_control = ar9003_hw_compute_pll_control_soc;
+ 	else
+ 		priv_ops->compute_pll_control = ar9003_hw_compute_pll_control;
+@@ -2021,7 +2032,8 @@ bool ar9003_hw_bb_watchdog_check(struct ath_hw *ah)
+ 	case 0x04000b09:
+ 		return true;
+ 	case 0x04000409:
+-		if (AR_SREV_9340(ah) || AR_SREV_9531(ah) || AR_SREV_9561(ah))
++		if (AR_SREV_9340(ah) || AR_SREV_9531(ah) || AR_SREV_9561(ah) ||
++		    AR_SREV_5502(ah))
+ 			return false;
+ 		else
+ 			return true;
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_phy.h b/drivers/net/wireless/ath/ath9k/ar9003_phy.h
+index ce7c398b8c..8bc62ca483 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.h
++++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.h
+@@ -20,7 +20,7 @@
+ /*
+  * Channel Register Map
+  */
+-#define AR_CHAN_BASE(_ah)	0x9800
++#define AR_CHAN_BASE(_ah)	(AR_SREV_5502(_ah) ? 0x29800 : 0x9800)
+ 
+ #define AR_PHY_TIMING1(_ah)      (AR_CHAN_BASE(_ah) + 0x0)
+ #define AR_PHY_TIMING2(_ah)      (AR_CHAN_BASE(_ah) + 0x4)
+@@ -214,7 +214,7 @@
+ /*
+  * MRC Register Map
+  */
+-#define AR_MRC_BASE(_ah)	0x9c00
++#define AR_MRC_BASE(_ah)	(AR_SREV_5502(_ah) ? 0x29c00 : 0x9c00)
+ 
+ #define AR_PHY_TIMING_3A(_ah)       (AR_MRC_BASE(_ah) + 0x0)
+ #define AR_PHY_LDPC_CNTL1(_ah)      (AR_MRC_BASE(_ah) + 0x4)
+@@ -255,12 +255,12 @@
+ /*
+  * BBB Register Map
+  */
+-#define AR_BBB_BASE(_ah)	0x9d00
++#define AR_BBB_BASE(_ah)	(AR_SREV_5502(_ah) ? 0x29d00 : 0x9d00)
+ 
+ /*
+  * AGC Register Map
+  */
+-#define AR_AGC_BASE(_ah)	0x9e00
++#define AR_AGC_BASE(_ah)	(AR_SREV_5502(_ah) ? 0x29e00 : 0x9e00)
+ 
+ #define AR_PHY_SETTLING(_ah)         (AR_AGC_BASE(_ah) + 0x0)
+ #define AR_PHY_FORCEMAX_GAINS_0(_ah) (AR_AGC_BASE(_ah) + 0x4)
+@@ -448,14 +448,18 @@
+ /*
+  * SM Register Map
+  */
+-#define AR_SM_BASE(_ah)	0xa200
++#define AR_SM_BASE(_ah)	(AR_SREV_5502(_ah) ? 0x2a200 : 0xa200)
+ 
+ #define AR_PHY_D2_CHIP_ID(_ah)        (AR_SM_BASE(_ah) + 0x0)
+ #define AR_PHY_GEN_CTRL(_ah)          (AR_SM_BASE(_ah) + 0x4)
+ #define AR_PHY_MODE(_ah)              (AR_SM_BASE(_ah) + 0x8)
+ #define AR_PHY_ACTIVE(_ah)            (AR_SM_BASE(_ah) + 0xc)
+-#define AR_PHY_SPUR_MASK_A(_ah)       (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x18 : 0x20))
+-#define AR_PHY_SPUR_MASK_B(_ah)       (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x1c : 0x24))
++#define AR_PHY_SPUR_MASK_A(_ah) \
++	(AR_SM_BASE(_ah) +      \
++	 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x18 : 0x20))
++#define AR_PHY_SPUR_MASK_B(_ah) \
++	(AR_SM_BASE(_ah) +      \
++	 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x1c : 0x24))
+ #define AR_PHY_SPECTRAL_SCAN(_ah)     (AR_SM_BASE(_ah) + 0x28)
+ #define AR_PHY_RADAR_BW_FILTER(_ah)   (AR_SM_BASE(_ah) + 0x2c)
+ #define AR_PHY_SEARCH_START_DELAY(_ah) (AR_SM_BASE(_ah) + 0x30)
+@@ -498,7 +502,9 @@
+ #define AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_A                       0x3FF
+ #define AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_A_S                     0
+ 
+-#define AR_PHY_TEST(_ah)         (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x15c : 0x160))
++#define AR_PHY_TEST(_ah)   \
++	(AR_SM_BASE(_ah) + \
++	 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x15c : 0x160))
+ 
+ #define AR_PHY_TEST_BBB_OBS_SEL       0x780000
+ #define AR_PHY_TEST_BBB_OBS_SEL_S     19
+@@ -509,7 +515,9 @@
+ #define AR_PHY_TEST_CHAIN_SEL      0xC0000000
+ #define AR_PHY_TEST_CHAIN_SEL_S    30
+ 
+-#define AR_PHY_TEST_CTL_STATUS(_ah) (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x160 : 0x164))
++#define AR_PHY_TEST_CTL_STATUS(_ah) \
++	(AR_SM_BASE(_ah) +          \
++	 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x160 : 0x164))
+ #define AR_PHY_TEST_CTL_TSTDAC_EN         0x1
+ #define AR_PHY_TEST_CTL_TSTDAC_EN_S       0
+ #define AR_PHY_TEST_CTL_TX_OBS_SEL        0x1C
+@@ -523,23 +531,42 @@
+ #define AR_PHY_TEST_CTL_DEBUGPORT_SEL	  0xe0000000
+ #define AR_PHY_TEST_CTL_DEBUGPORT_SEL_S	  29
+ 
++#define AR_PHY_TSTDAC(_ah) \
++	(AR_SM_BASE(_ah) + \
++	 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x164 : 0x168))
+ 
+-#define AR_PHY_TSTDAC(_ah)       (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x164 : 0x168))
++#define AR_PHY_CHAN_STATUS(_ah) \
++	(AR_SM_BASE(_ah) +      \
++	 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x168 : 0x16c))
+ 
+-#define AR_PHY_CHAN_STATUS(_ah)  (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x168 : 0x16c))
+-
+-#define AR_PHY_CHAN_INFO_MEMORY(_ah) (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x16c : 0x170))
++#define AR_PHY_CHAN_INFO_MEMORY(_ah) \
++	(AR_SM_BASE(_ah) +           \
++	 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x16c : 0x170))
+ #define AR_PHY_CHAN_INFO_MEMORY_CHANINFOMEM_S2_READ	0x00000008
+ #define AR_PHY_CHAN_INFO_MEMORY_CHANINFOMEM_S2_READ_S	3
+ 
+-#define AR_PHY_CHNINFO_NOISEPWR(_ah)  (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x170 : 0x174))
+-#define AR_PHY_CHNINFO_GAINDIFF(_ah)  (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x174 : 0x178))
+-#define AR_PHY_CHNINFO_FINETIM(_ah)   (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x178 : 0x17c))
+-#define AR_PHY_CHAN_INFO_GAIN_0(_ah)  (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x17c : 0x180))
+-#define AR_PHY_SCRAMBLER_SEED(_ah)    (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x184 : 0x190))
+-#define AR_PHY_CCK_TX_CTRL(_ah)       (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x188 : 0x194))
+-
+-#define AR_PHY_HEAVYCLIP_CTL(_ah) (AR_SM_BASE(_ah) + (AR_SREV_9561(_ah) ? 0x198 : 0x1a4))
++#define AR_PHY_CHNINFO_NOISEPWR(_ah) \
++	(AR_SM_BASE(_ah) +           \
++	 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x170 : 0x174))
++#define AR_PHY_CHNINFO_GAINDIFF(_ah) \
++	(AR_SM_BASE(_ah) +           \
++	 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x174 : 0x178))
++#define AR_PHY_CHNINFO_FINETIM(_ah) \
++	(AR_SM_BASE(_ah) +          \
++	 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x178 : 0x17c))
++#define AR_PHY_CHAN_INFO_GAIN_0(_ah) \
++	(AR_SM_BASE(_ah) +           \
++	 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x17c : 0x180))
++#define AR_PHY_SCRAMBLER_SEED(_ah) \
++	(AR_SM_BASE(_ah) +         \
++	 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x184 : 0x190))
++#define AR_PHY_CCK_TX_CTRL(_ah) \
++	(AR_SM_BASE(_ah) +      \
++	 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x188 : 0x194))
++
++#define AR_PHY_HEAVYCLIP_CTL(_ah) \
++	(AR_SM_BASE(_ah) +        \
++	 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x198 : 0x1a4))
+ #define AR_PHY_HEAVYCLIP_20(_ah)      (AR_SM_BASE(_ah) + 0x1a8)
+ #define AR_PHY_HEAVYCLIP_40(_ah)      (AR_SM_BASE(_ah) + 0x1ac)
+ #define AR_PHY_HEAVYCLIP_1(_ah)	 (AR_SM_BASE(_ah) + 0x19c)
+@@ -575,6 +602,8 @@
+ #define AR_PHY_TPC_12_DESIRED_SCALE_HT40_5_S	25
+ 
+ #define AR_PHY_TPC_18(_ah)			(AR_SM_BASE(_ah) + 0x23c)
++#define AR_PHY_TPC_18_B1(_ah)			(AR_SM1_BASE(_ah) + 0x23c)
++#define AR_PHY_TPC_18_B2(_ah)			(AR_SM2_BASE(_ah) + 0x23c)
+ #define AR_PHY_TPC_18_THERM_CAL_VALUE           0x000000ff
+ #define AR_PHY_TPC_18_THERM_CAL_VALUE_S         0
+ #define AR_PHY_TPC_18_VOLT_CAL_VALUE		0x0000ff00
+@@ -722,6 +751,10 @@
+ #define AR_CH0_TOP2_XPABIASLVL		(AR_SREV_9561(ah) ? 0x1e00 : 0xf000)
+ #define AR_CH0_TOP2_XPABIASLVL_S	(AR_SREV_9561(ah) ? 9 : 12)
+ 
++#define AR_CH0_TOP3		0x16288
++#define AR_CH0_TOP3_XPABIASLVL		0xf0000
++#define AR_CH0_TOP3_XPABIASLVL_S	16
++
+ #define AR_CH0_XTAL(_ah)	(AR_SREV_9300(_ah) ? 0x16294 : \
+ 				 ((AR_SREV_9462(_ah) || AR_SREV_9565(_ah)) ? 0x16298 : \
+ 				  (AR_SREV_9561(_ah) ? 0x162c0 : 0x16290)))
+@@ -731,12 +764,12 @@
+ #define AR_CH0_XTAL_CAPOUTDAC_S	17
+ 
+ #define AR_PHY_PMU1(_ah)	((AR_SREV_9462(_ah) || AR_SREV_9565(_ah)) ? 0x16340 : \
+-				 (AR_SREV_9561(_ah) ? 0x16cc0 : 0x16c40))
++				 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x16cc0 : 0x16c40))
+ #define AR_PHY_PMU1_PWD		0x1
+ #define AR_PHY_PMU1_PWD_S	0
+ 
+ #define AR_PHY_PMU2(_ah)	((AR_SREV_9462(_ah) || AR_SREV_9565(_ah)) ? 0x16344 : \
+-				 (AR_SREV_9561(_ah) ? 0x16cc4 : 0x16c44))
++				 ((AR_SREV_9561(_ah) || AR_SREV_5502(_ah)) ? 0x16cc4 : 0x16c44))
+ #define AR_PHY_PMU2_PGM		0x00200000
+ #define AR_PHY_PMU2_PGM_S	21
+ 
+@@ -923,7 +956,7 @@
+ /*
+  * Channel 1 Register Map
+  */
+-#define AR_CHAN1_BASE(_ah)	0xa800
++#define AR_CHAN1_BASE(_ah)	(AR_SREV_5502(_ah) ? 0x2a800 : 0xa800)
+ 
+ #define AR_PHY_EXT_CCA_1(_ah)            (AR_CHAN1_BASE(_ah) + 0x30)
+ #define AR_PHY_TX_PHASE_RAMP_1(_ah)      (AR_CHAN1_BASE(_ah) + 0xd0)
+@@ -942,7 +975,7 @@
+ /*
+  * AGC 1 Register Map
+  */
+-#define AR_AGC1_BASE(_ah)	0xae00
++#define AR_AGC1_BASE(_ah)	(AR_SREV_5502(_ah) ? 0x2ae00 : 0xae00)
+ 
+ #define AR_PHY_FORCEMAX_GAINS_1(_ah)      (AR_AGC1_BASE(_ah) + 0x4)
+ #define AR_PHY_EXT_ATTEN_CTL_1(_ah)       (AR_AGC1_BASE(_ah) + 0x18)
+@@ -961,7 +994,7 @@
+ /*
+  * SM 1 Register Map
+  */
+-#define AR_SM1_BASE(_ah)	0xb200
++#define AR_SM1_BASE(_ah)	(AR_SREV_5502(_ah) ? 0x2b200 : 0xb200)
+ 
+ #define AR_PHY_SWITCH_CHAIN_1(_ah)   (AR_SM1_BASE(_ah) + 0x84)
+ #define AR_PHY_FCAL_2_1(_ah)         (AR_SM1_BASE(_ah) + 0xd0)
+@@ -987,7 +1020,7 @@
+ /*
+  * Channel 2 Register Map
+  */
+-#define AR_CHAN2_BASE(_ah)	0xb800
++#define AR_CHAN2_BASE(_ah)	(AR_SREV_5502(_ah) ? 0x2b800 : 0xb800)
+ 
+ #define AR_PHY_EXT_CCA_2(_ah)            (AR_CHAN2_BASE(_ah) + 0x30)
+ #define AR_PHY_TX_PHASE_RAMP_2(_ah)      (AR_CHAN2_BASE(_ah) + 0xd0)
+@@ -1005,7 +1038,7 @@
+ /*
+  * AGC 2 Register Map
+  */
+-#define AR_AGC2_BASE(_ah)	0xbe00
++#define AR_AGC2_BASE(_ah)	(AR_SREV_5502(_ah) ? 0x2be00 : 0xbe00)
+ 
+ #define AR_PHY_FORCEMAX_GAINS_2(_ah)      (AR_AGC2_BASE(_ah) + 0x4)
+ #define AR_PHY_EXT_ATTEN_CTL_2(_ah)       (AR_AGC2_BASE(_ah) + 0x18)
+@@ -1022,7 +1055,7 @@
+ /*
+  * SM 2 Register Map
+  */
+-#define AR_SM2_BASE(_ah)	0xc200
++#define AR_SM2_BASE(_ah)	(AR_SREV_5502(_ah) ? 0x2c200 : 0xc200)
+ 
+ #define AR_PHY_SWITCH_CHAIN_2(_ah)    (AR_SM2_BASE(_ah) + 0x84)
+ #define AR_PHY_FCAL_2_2(_ah)          (AR_SM2_BASE(_ah) + 0xd0)
+diff --git a/drivers/net/wireless/ath/ath9k/hw.c b/drivers/net/wireless/ath/ath9k/hw.c
+index e63314544a..f572fca3e6 100644
+--- a/drivers/net/wireless/ath/ath9k/hw.c
++++ b/drivers/net/wireless/ath/ath9k/hw.c
+@@ -834,7 +834,7 @@ static void ath9k_hw_init_pll(struct ath_hw *ah,
+ 		REG_RMW_FIELD(ah, AR_CH0_BB_DPLL3,
+ 			      AR_CH0_BB_DPLL3_PHASE_SHIFT, 0x1);
+ 	} else if (AR_SREV_9340(ah) || AR_SREV_9550(ah) || AR_SREV_9531(ah) ||
+-		   AR_SREV_9561(ah)) {
++		   AR_SREV_9561(ah) || AR_SREV_5502(ah)) {
+ 		u32 regval, pll2_divint, pll2_divfrac, refdiv;
+ 
+ 		REG_WRITE(ah, AR_RTC_PLL_CONTROL(ah),
+@@ -845,7 +845,8 @@ static void ath9k_hw_init_pll(struct ath_hw *ah,
+ 		udelay(100);
+ 
+ 		if (ah->is_clk_25mhz) {
+-			if (AR_SREV_9531(ah) || AR_SREV_9561(ah)) {
++			if (AR_SREV_9531(ah) || AR_SREV_9561(ah) ||
++			    AR_SREV_5502(ah)) {
+ 				pll2_divint = 0x1c;
+ 				pll2_divfrac = 0xa3d2;
+ 				refdiv = 1;
+@@ -861,15 +862,16 @@ static void ath9k_hw_init_pll(struct ath_hw *ah,
+ 				refdiv = 5;
+ 			} else {
+ 				pll2_divint = 0x11;
+-				pll2_divfrac = (AR_SREV_9531(ah) ||
+-						AR_SREV_9561(ah)) ?
++				pll2_divfrac =
++					(AR_SREV_9531(ah) || AR_SREV_9561(ah) ||
++					 AR_SREV_5502(ah)) ?
+ 						0x26665 : 0x26666;
+ 				refdiv = 1;
+ 			}
+ 		}
+ 
+ 		regval = REG_READ(ah, AR_PHY_PLL_MODE);
+-		if (AR_SREV_9531(ah) || AR_SREV_9561(ah))
++		if (AR_SREV_9531(ah) || AR_SREV_9561(ah) || AR_SREV_5502(ah))
+ 			regval |= (0x1 << 22);
+ 		else
+ 			regval |= (0x1 << 16);
+@@ -887,7 +889,8 @@ static void ath9k_hw_init_pll(struct ath_hw *ah,
+ 				(0x1 << 13) |
+ 				(0x4 << 26) |
+ 				(0x18 << 19);
+-		else if (AR_SREV_9531(ah) || AR_SREV_9561(ah)) {
++		else if (AR_SREV_9531(ah) || AR_SREV_9561(ah) ||
++			 AR_SREV_5502(ah)) {
+ 			regval = (regval & 0x01c00fff) |
+ 				(0x1 << 31) |
+ 				(0x2 << 29) |
+@@ -904,7 +907,7 @@ static void ath9k_hw_init_pll(struct ath_hw *ah,
+ 				(0x60 << 19);
+ 		REG_WRITE(ah, AR_PHY_PLL_MODE, regval);
+ 
+-		if (AR_SREV_9531(ah) || AR_SREV_9561(ah))
++		if (AR_SREV_9531(ah) || AR_SREV_9561(ah) || AR_SREV_5502(ah))
+ 			REG_WRITE(ah, AR_PHY_PLL_MODE,
+ 				  REG_READ(ah, AR_PHY_PLL_MODE) & 0xffbfffff);
+ 		else
+@@ -945,7 +948,7 @@ static void ath9k_hw_init_interrupt_masks(struct ath_hw *ah,
+ 	u32 msi_cfg = 0;
+ 
+ 	if (AR_SREV_9340(ah) || AR_SREV_9550(ah) || AR_SREV_9531(ah) ||
+-	    AR_SREV_9561(ah))
++	    AR_SREV_9561(ah) || AR_SREV_5502(ah))
+ 		sync_default &= ~AR_INTR_SYNC_HOST1_FATAL;
+ 
+ 	if (AR_SREV_9300_20_OR_LATER(ah)) {
+@@ -1235,8 +1238,9 @@ static inline void ath9k_hw_set_dma(struct ath_hw *ah)
+ 	REG_WRITE(ah, AR_RXFIFO_CFG, 0x200);
+ 
+ 	if (AR_SREV_9300_20_OR_LATER(ah)) {
+-		REG_RMW_FIELD(ah, AR_RXBP_THRESH, AR_RXBP_THRESH_HP, 0x1);
+-		REG_RMW_FIELD(ah, AR_RXBP_THRESH, AR_RXBP_THRESH_LP, 0x1);
++		u8 rxbp = AR_SREV_5502(ah) ? 0x3 : 0x1;
++		REG_RMW_FIELD(ah, AR_RXBP_THRESH, AR_RXBP_THRESH_HP, rxbp);
++		REG_RMW_FIELD(ah, AR_RXBP_THRESH, AR_RXBP_THRESH_LP, rxbp);
+ 
+ 		ath9k_hw_set_rx_bufsize(ah, common->rx_bufsize -
+ 			ah->caps.rx_status_len);
+@@ -1777,7 +1781,7 @@ static void ath9k_hw_init_desc(struct ath_hw *ah)
+ #ifdef __BIG_ENDIAN
+ 		else if (AR_SREV_9330(ah) || AR_SREV_9340(ah) ||
+ 			 AR_SREV_9550(ah) || AR_SREV_9531(ah) ||
+-			 AR_SREV_9561(ah))
++			 AR_SREV_9561(ah) || AR_SREV_5502(ah))
+ 			REG_RMW(ah, AR_CFG, AR_CFG_SWRB | AR_CFG_SWTB, 0);
+ 		else
+ 			REG_WRITE(ah, AR_CFG, AR_CFG_SWTD | AR_CFG_SWRD);
+@@ -2474,6 +2478,9 @@ static void ath9k_gpio_cap_init(struct ath_hw *ah)
+ 	} else if (AR_SREV_9561(ah)) {
+ 		pCap->num_gpio_pins = AR9561_NUM_GPIO;
+ 		pCap->gpio_mask = AR9561_GPIO_MASK;
++	} else if (AR_SREV_5502(ah)) {
++		pCap->num_gpio_pins = AR5502_NUM_GPIO;
++		pCap->gpio_mask = AR5502_GPIO_MASK;
+ 	} else if (AR_SREV_9565(ah)) {
+ 		pCap->num_gpio_pins = AR9565_NUM_GPIO;
+ 		pCap->gpio_mask = AR9565_GPIO_MASK;
+@@ -2610,7 +2617,7 @@ int ath9k_hw_fill_cap_info(struct ath_hw *ah)
+ 	if (AR_SREV_9300_20_OR_LATER(ah)) {
+ 		pCap->hw_caps |= ATH9K_HW_CAP_EDMA | ATH9K_HW_CAP_FASTCLOCK;
+ 		if (!AR_SREV_9330(ah) && !AR_SREV_9485(ah) &&
+-		    !AR_SREV_9561(ah) && !AR_SREV_9565(ah))
++		    !AR_SREV_9561(ah) && !AR_SREV_5502(ah) && !AR_SREV_9565(ah))
+ 			pCap->hw_caps |= ATH9K_HW_CAP_LDPC;
+ 
+ 		pCap->rx_hp_qdepth = ATH9K_HW_RX_HP_QDEPTH;
+@@ -2627,7 +2634,7 @@ int ath9k_hw_fill_cap_info(struct ath_hw *ah)
+ 	if (AR_SREV_9300_20_OR_LATER(ah))
+ 		pCap->hw_caps |= ATH9K_HW_CAP_RAC_SUPPORTED;
+ 
+-	if (AR_SREV_9561(ah))
++	if (AR_SREV_9561(ah) || AR_SREV_5502(ah))
+ 		ah->ent_mode = 0x3BDA000;
+ 	else if (AR_SREV_9300_20_OR_LATER(ah))
+ 		ah->ent_mode = REG_READ(ah, AR_ENT_OTP);
+diff --git a/drivers/net/wireless/ath/ath9k/mac.c b/drivers/net/wireless/ath/ath9k/mac.c
+index b070403e08..b18c437ca4 100644
+--- a/drivers/net/wireless/ath/ath9k/mac.c
++++ b/drivers/net/wireless/ath/ath9k/mac.c
+@@ -813,7 +813,7 @@ static void __ath9k_hw_enable_interrupts(struct ath_hw *ah)
+ 	u32 async_mask;
+ 
+ 	if (AR_SREV_9340(ah) || AR_SREV_9550(ah) || AR_SREV_9531(ah) ||
+-	    AR_SREV_9561(ah))
++	    AR_SREV_9561(ah) || AR_SREV_5502(ah))
+ 		sync_default &= ~AR_INTR_SYNC_HOST1_FATAL;
+ 
+ 	async_mask = AR_INTR_MAC_IRQ;
+diff --git a/drivers/net/wireless/ath/ath9k/recv.c b/drivers/net/wireless/ath/ath9k/recv.c
+index 0c0624a3b4..3299aef65e 100644
+--- a/drivers/net/wireless/ath/ath9k/recv.c
++++ b/drivers/net/wireless/ath/ath9k/recv.c
+@@ -422,7 +422,7 @@ u32 ath_calcrxfilter(struct ath_softc *sc)
+ 	}
+ 
+ 	if (AR_SREV_9550(sc->sc_ah) || AR_SREV_9531(sc->sc_ah) ||
+-	    AR_SREV_9561(sc->sc_ah))
++	    AR_SREV_9561(sc->sc_ah) || AR_SREV_5502(sc->sc_ah))
+ 		rfilt |= ATH9K_RX_FILTER_4ADDRESS;
+ 
+ 	if (AR_SREV_9462(sc->sc_ah) || AR_SREV_9565(sc->sc_ah))
+diff --git a/drivers/net/wireless/ath/ath9k/reg.h b/drivers/net/wireless/ath/ath9k/reg.h
+index 75a9651983..1809217264 100644
+--- a/drivers/net/wireless/ath/ath9k/reg.h
++++ b/drivers/net/wireless/ath/ath9k/reg.h
+@@ -1138,6 +1138,7 @@ enum {
+ #define AR9531_NUM_GPIO				 18
+ #define AR9550_NUM_GPIO				 24
+ #define AR9561_NUM_GPIO				 23
++#define AR5502_NUM_GPIO				 20
+ #define AR9565_NUM_GPIO				 14
+ #define AR9580_NUM_GPIO				 16
+ #define AR7010_NUM_GPIO                          16
+@@ -1155,6 +1156,7 @@ enum {
+ #define AR9531_GPIO_MASK			 0x0000000F
+ #define AR9550_GPIO_MASK			 0x0000000F
+ #define AR9561_GPIO_MASK			 0x0000000F
++#define AR5502_GPIO_MASK			 0x0000000F
+ #define AR9565_GPIO_MASK			 0x00003FFF
+ #define AR9580_GPIO_MASK			 0x0000F4FF
+ #define AR7010_GPIO_MASK			 0x0000FFFF
+@@ -2114,7 +2116,7 @@ enum {
+ 						     * pcu_txsm.
+ 						     */
+ 
+-#define AR9300_SM_BASE(_ah)			0xa200
++#define AR9300_SM_BASE(_ah)			(AR_SREV_5502(_ah) ? 0x2a200 : 0xa200)
+ #define AR9002_PHY_AGC_CONTROL			0x9860
+ #define AR9003_PHY_AGC_CONTROL(_ah)		(AR9300_SM_BASE(_ah) + 0xc4)
+ #define AR_PHY_AGC_CONTROL(_ah)			(AR_SREV_9300_20_OR_LATER(_ah) ? AR9003_PHY_AGC_CONTROL(_ah) : AR9002_PHY_AGC_CONTROL)
+-- 
+2.34.1
+
diff --git a/package/feeds/base/mac80211/patches/ath9k/007-wifi-ath9k-add-QCN550x-initvals.patch b/package/feeds/base/mac80211/patches/ath9k/007-wifi-ath9k-add-QCN550x-initvals.patch
new file mode 100644
index 0000000000..e10ec8039d
--- /dev/null
+++ b/package/feeds/base/mac80211/patches/ath9k/007-wifi-ath9k-add-QCN550x-initvals.patch
@@ -0,0 +1,1708 @@
+From be9d37706721b9af64bcb88e0e8fa434859708ed Mon Sep 17 00:00:00 2001
+From: Wenli Looi <wlooi@ucalgary.ca>
+Date: Mon, 18 Apr 2022 05:15:03 +0000
+Subject: [PATCH v3 07/11] wifi: ath9k: add QCN550x initvals
+
+These values are based on the D-Link DAP-2682 GPL dump. Overall, they
+are very similar to QCA956x initvals found in ath9k except for adding
+0x20000 to many addresses and adding 4th-chain related addresses. I have
+also edited certain values to enable the clock doubler, which matches
+stock firmware behavior and seems necessary for decent performance.
+
+See the link for more details about the initvals.
+
+Link: https://github.com/looi/qcn5502-initvals
+Signed-off-by: Wenli Looi <wlooi@ucalgary.ca>
+---
+ .../net/wireless/ath/ath9k/ar550x_initvals.h  | 1539 +++++++++++++++++
+ drivers/net/wireless/ath/ath9k/ar9003_hw.c    |   65 +
+ 2 files changed, 1604 insertions(+)
+ create mode 100644 drivers/net/wireless/ath/ath9k/ar550x_initvals.h
+
+diff --git a/drivers/net/wireless/ath/ath9k/ar550x_initvals.h b/drivers/net/wireless/ath/ath9k/ar550x_initvals.h
+new file mode 100644
+index 0000000000..632283c067
+--- /dev/null
++++ b/drivers/net/wireless/ath/ath9k/ar550x_initvals.h
+@@ -0,0 +1,1539 @@
++#ifndef INITVALS_550X_H
++#define INITVALS_550X_H
++
++#define qcn550x_1p0_mac_core ar955x_1p0_mac_core
++
++#define qcn550x_1p0_mac_postamble ar9331_1p1_mac_postamble
++
++#define qcn550x_1p0_soc_preamble ar955x_1p0_soc_preamble
++
++#define qcn550x_1p0_soc_postamble ar9300_2p2_soc_postamble
++
++static const u32 qcn550x_1p0_common_wo_xlna_rx_gain_table[][2] = {
++	/* Addr      allmodes  */
++	{0x0002a000, 0x00010000},
++	{0x0002a004, 0x00030002},
++	{0x0002a008, 0x00050004},
++	{0x0002a00c, 0x00810080},
++	{0x0002a010, 0x00830082},
++	{0x0002a014, 0x01810180},
++	{0x0002a018, 0x01830182},
++	{0x0002a01c, 0x01850184},
++	{0x0002a020, 0x01890188},
++	{0x0002a024, 0x018b018a},
++	{0x0002a028, 0x018d018c},
++	{0x0002a02c, 0x03820190},
++	{0x0002a030, 0x03840383},
++	{0x0002a034, 0x03880385},
++	{0x0002a038, 0x038a0389},
++	{0x0002a03c, 0x038c038b},
++	{0x0002a040, 0x0390038d},
++	{0x0002a044, 0x03920391},
++	{0x0002a048, 0x03940393},
++	{0x0002a04c, 0x03960395},
++	{0x0002a050, 0x00000000},
++	{0x0002a054, 0x00000000},
++	{0x0002a058, 0x00000000},
++	{0x0002a05c, 0x00000000},
++	{0x0002a060, 0x00000000},
++	{0x0002a064, 0x00000000},
++	{0x0002a068, 0x00000000},
++	{0x0002a06c, 0x00000000},
++	{0x0002a070, 0x00000000},
++	{0x0002a074, 0x00000000},
++	{0x0002a078, 0x00000000},
++	{0x0002a07c, 0x00000000},
++	{0x0002a080, 0x29292929},
++	{0x0002a084, 0x29292929},
++	{0x0002a088, 0x29292929},
++	{0x0002a08c, 0x29292929},
++	{0x0002a090, 0x22292929},
++	{0x0002a094, 0x1d1d2222},
++	{0x0002a098, 0x0c111117},
++	{0x0002a09c, 0x00030303},
++	{0x0002a0a0, 0x00000000},
++	{0x0002a0a4, 0x00000000},
++	{0x0002a0a8, 0x00000000},
++	{0x0002a0ac, 0x00000000},
++	{0x0002a0b0, 0x00000000},
++	{0x0002a0b4, 0x00000000},
++	{0x0002a0b8, 0x00000000},
++	{0x0002a0bc, 0x00000000},
++	{0x0002a0c0, 0x001f0000},
++	{0x0002a0c4, 0x01000101},
++	{0x0002a0c8, 0x011e011f},
++	{0x0002a0cc, 0x011c011d},
++	{0x0002a0d0, 0x02030204},
++	{0x0002a0d4, 0x02010202},
++	{0x0002a0d8, 0x021f0200},
++	{0x0002a0dc, 0x0302021e},
++	{0x0002a0e0, 0x03000301},
++	{0x0002a0e4, 0x031e031f},
++	{0x0002a0e8, 0x0402031d},
++	{0x0002a0ec, 0x04000401},
++	{0x0002a0f0, 0x041e041f},
++	{0x0002a0f4, 0x0502041d},
++	{0x0002a0f8, 0x05000501},
++	{0x0002a0fc, 0x051e051f},
++	{0x0002a100, 0x06010602},
++	{0x0002a104, 0x061f0600},
++	{0x0002a108, 0x061d061e},
++	{0x0002a10c, 0x07020703},
++	{0x0002a110, 0x07000701},
++	{0x0002a114, 0x00000000},
++	{0x0002a118, 0x00000000},
++	{0x0002a11c, 0x00000000},
++	{0x0002a120, 0x00000000},
++	{0x0002a124, 0x00000000},
++	{0x0002a128, 0x00000000},
++	{0x0002a12c, 0x00000000},
++	{0x0002a130, 0x00000000},
++	{0x0002a134, 0x00000000},
++	{0x0002a138, 0x00000000},
++	{0x0002a13c, 0x00000000},
++	{0x0002a140, 0x001f0000},
++	{0x0002a144, 0x01000101},
++	{0x0002a148, 0x011e011f},
++	{0x0002a14c, 0x011c011d},
++	{0x0002a150, 0x02030204},
++	{0x0002a154, 0x02010202},
++	{0x0002a158, 0x021f0200},
++	{0x0002a15c, 0x0302021e},
++	{0x0002a160, 0x03000301},
++	{0x0002a164, 0x031e031f},
++	{0x0002a168, 0x0402031d},
++	{0x0002a16c, 0x04000401},
++	{0x0002a170, 0x041e041f},
++	{0x0002a174, 0x0502041d},
++	{0x0002a178, 0x05000501},
++	{0x0002a17c, 0x051e051f},
++	{0x0002a180, 0x06010602},
++	{0x0002a184, 0x061f0600},
++	{0x0002a188, 0x061d061e},
++	{0x0002a18c, 0x07020703},
++	{0x0002a190, 0x07000701},
++	{0x0002a194, 0x00000000},
++	{0x0002a198, 0x00000000},
++	{0x0002a19c, 0x00000000},
++	{0x0002a1a0, 0x00000000},
++	{0x0002a1a4, 0x00000000},
++	{0x0002a1a8, 0x00000000},
++	{0x0002a1ac, 0x00000000},
++	{0x0002a1b0, 0x00000000},
++	{0x0002a1b4, 0x00000000},
++	{0x0002a1b8, 0x00000000},
++	{0x0002a1bc, 0x00000000},
++	{0x0002a1c0, 0x00000000},
++	{0x0002a1c4, 0x00000000},
++	{0x0002a1c8, 0x00000000},
++	{0x0002a1cc, 0x00000000},
++	{0x0002a1d0, 0x00000000},
++	{0x0002a1d4, 0x00000000},
++	{0x0002a1d8, 0x00000000},
++	{0x0002a1dc, 0x00000000},
++	{0x0002a1e0, 0x00000000},
++	{0x0002a1e4, 0x00000000},
++	{0x0002a1e8, 0x00000000},
++	{0x0002a1ec, 0x00000000},
++	{0x0002a1f0, 0x00000396},
++	{0x0002a1f4, 0x00000396},
++	{0x0002a1f8, 0x00000396},
++	{0x0002a1fc, 0x00000196},
++	{0x0002b000, 0x00010000},
++	{0x0002b004, 0x00030002},
++	{0x0002b008, 0x00050004},
++	{0x0002b00c, 0x00810080},
++	{0x0002b010, 0x00830082},
++	{0x0002b014, 0x01810180},
++	{0x0002b018, 0x01830182},
++	{0x0002b01c, 0x01850184},
++	{0x0002b020, 0x02810280},
++	{0x0002b024, 0x02830282},
++	{0x0002b028, 0x02850284},
++	{0x0002b02c, 0x02890288},
++	{0x0002b030, 0x028b028a},
++	{0x0002b034, 0x0388028c},
++	{0x0002b038, 0x038a0389},
++	{0x0002b03c, 0x038c038b},
++	{0x0002b040, 0x0390038d},
++	{0x0002b044, 0x03920391},
++	{0x0002b048, 0x03940393},
++	{0x0002b04c, 0x03960395},
++	{0x0002b050, 0x00000000},
++	{0x0002b054, 0x00000000},
++	{0x0002b058, 0x00000000},
++	{0x0002b05c, 0x00000000},
++	{0x0002b060, 0x00000000},
++	{0x0002b064, 0x00000000},
++	{0x0002b068, 0x00000000},
++	{0x0002b06c, 0x00000000},
++	{0x0002b070, 0x00000000},
++	{0x0002b074, 0x00000000},
++	{0x0002b078, 0x00000000},
++	{0x0002b07c, 0x00000000},
++	{0x0002b080, 0x32323232},
++	{0x0002b084, 0x2f2f3232},
++	{0x0002b088, 0x23282a2d},
++	{0x0002b08c, 0x1c1e2123},
++	{0x0002b090, 0x14171919},
++	{0x0002b094, 0x0e0e1214},
++	{0x0002b098, 0x03050707},
++	{0x0002b09c, 0x00030303},
++	{0x0002b0a0, 0x00000000},
++	{0x0002b0a4, 0x00000000},
++	{0x0002b0a8, 0x00000000},
++	{0x0002b0ac, 0x00000000},
++	{0x0002b0b0, 0x00000000},
++	{0x0002b0b4, 0x00000000},
++	{0x0002b0b8, 0x00000000},
++	{0x0002b0bc, 0x00000000},
++	{0x0002b0c0, 0x003f0020},
++	{0x0002b0c4, 0x00400041},
++	{0x0002b0c8, 0x0140005f},
++	{0x0002b0cc, 0x0160015f},
++	{0x0002b0d0, 0x017e017f},
++	{0x0002b0d4, 0x02410242},
++	{0x0002b0d8, 0x025f0240},
++	{0x0002b0dc, 0x027f0260},
++	{0x0002b0e0, 0x0341027e},
++	{0x0002b0e4, 0x035f0340},
++	{0x0002b0e8, 0x037f0360},
++	{0x0002b0ec, 0x04400441},
++	{0x0002b0f0, 0x0460045f},
++	{0x0002b0f4, 0x0541047f},
++	{0x0002b0f8, 0x055f0540},
++	{0x0002b0fc, 0x057f0560},
++	{0x0002b100, 0x06400641},
++	{0x0002b104, 0x0660065f},
++	{0x0002b108, 0x067e067f},
++	{0x0002b10c, 0x07410742},
++	{0x0002b110, 0x075f0740},
++	{0x0002b114, 0x077f0760},
++	{0x0002b118, 0x07800781},
++	{0x0002b11c, 0x07a0079f},
++	{0x0002b120, 0x07c107bf},
++	{0x0002b124, 0x000007c0},
++	{0x0002b128, 0x00000000},
++	{0x0002b12c, 0x00000000},
++	{0x0002b130, 0x00000000},
++	{0x0002b134, 0x00000000},
++	{0x0002b138, 0x00000000},
++	{0x0002b13c, 0x00000000},
++	{0x0002b140, 0x003f0020},
++	{0x0002b144, 0x00400041},
++	{0x0002b148, 0x0140005f},
++	{0x0002b14c, 0x0160015f},
++	{0x0002b150, 0x017e017f},
++	{0x0002b154, 0x02410242},
++	{0x0002b158, 0x025f0240},
++	{0x0002b15c, 0x027f0260},
++	{0x0002b160, 0x0341027e},
++	{0x0002b164, 0x035f0340},
++	{0x0002b168, 0x037f0360},
++	{0x0002b16c, 0x04400441},
++	{0x0002b170, 0x0460045f},
++	{0x0002b174, 0x0541047f},
++	{0x0002b178, 0x055f0540},
++	{0x0002b17c, 0x057f0560},
++	{0x0002b180, 0x06400641},
++	{0x0002b184, 0x0660065f},
++	{0x0002b188, 0x067e067f},
++	{0x0002b18c, 0x07410742},
++	{0x0002b190, 0x075f0740},
++	{0x0002b194, 0x077f0760},
++	{0x0002b198, 0x07800781},
++	{0x0002b19c, 0x07a0079f},
++	{0x0002b1a0, 0x07c107bf},
++	{0x0002b1a4, 0x000007c0},
++	{0x0002b1a8, 0x00000000},
++	{0x0002b1ac, 0x00000000},
++	{0x0002b1b0, 0x00000000},
++	{0x0002b1b4, 0x00000000},
++	{0x0002b1b8, 0x00000000},
++	{0x0002b1bc, 0x00000000},
++	{0x0002b1c0, 0x00000000},
++	{0x0002b1c4, 0x00000000},
++	{0x0002b1c8, 0x00000000},
++	{0x0002b1cc, 0x00000000},
++	{0x0002b1d0, 0x00000000},
++	{0x0002b1d4, 0x00000000},
++	{0x0002b1d8, 0x00000000},
++	{0x0002b1dc, 0x00000000},
++	{0x0002b1e0, 0x00000000},
++	{0x0002b1e4, 0x00000000},
++	{0x0002b1e8, 0x00000000},
++	{0x0002b1ec, 0x00000000},
++	{0x0002b1f0, 0x00000396},
++	{0x0002b1f4, 0x00000396},
++	{0x0002b1f8, 0x00000396},
++	{0x0002b1fc, 0x00000196},
++};
++
++static const u32 qcn550x_1p0_baseband_postamble_dfs_channel[][3] = {
++	/* Addr      5G          2G        */
++	{0x00029824, 0x5ac668d0, 0x5ac668d0},
++	{0x00029e0c, 0x6d4000e2, 0x6d4000e2},
++	{0x00029e14, 0x37b9625e, 0x37b9625e},
++};
++
++static const u32 qcn550x_1p0_common_wo_xlna_rx_gain_bounds[][5] = {
++	/* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
++	{0x00029e44, 0xfe321e27, 0xfe321e27, 0xfe291e27, 0xfe291e27},
++	{0x00029e48, 0x5030201a, 0x5030201a, 0x50302012, 0x50302012},
++};
++
++static const u32 qcn550x_1p0_common_rx_gain_bounds[][5] = {
++	/* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
++	{0x00029e44, 0xfe321e27, 0xfe321e27, 0xfe291e27, 0xfe291e27},
++	{0x00029e48, 0x5030201a, 0x5030201a, 0x50302018, 0x50302018},
++};
++
++static const u32 qcn550x_1p0_modes_fast_clock[][3] = {
++	/* Addr      5G_HT20     5G_HT40   */
++	{0x00001030, 0x00000268, 0x000004d0},
++	{0x00001070, 0x0000018c, 0x00000318},
++	{0x000010b0, 0x00000fd0, 0x00001fa0},
++	{0x00008014, 0x044c044c, 0x08980898},
++	{0x0000801c, 0x148ec02b, 0x148ec057},
++	{0x00008318, 0x000044c0, 0x00008980},
++	{0x00029e00, 0xc372131c, 0xc372131c},
++	{0x0002a230, 0x0000400b, 0x00004016},
++	{0x0002a254, 0x00000898, 0x00001130},
++};
++
++static const u32 qcn550x_1p0_baseband_core[][2] = {
++	/* Addr      allmodes  */
++	{0x00029800, 0xafe68e30},
++	{0x00029804, 0xfd14e000},
++	{0x00029808, 0x9c0a9f6b},
++	{0x0002980c, 0x04900000},
++	{0x00029814, 0x0280c00a},
++	{0x00029818, 0x80000000},
++	{0x0002981c, 0x00020028},
++	{0x00029834, 0x6400a190},
++	{0x00029838, 0x0108ecff},
++	{0x0002983c, 0x14000600},
++	{0x00029880, 0x201fff00},
++	{0x00029884, 0x0c411042},
++	{0x0002988c, 0x00000001},
++	{0x000298a4, 0x00200400},
++	{0x000298b0, 0x32840cbf},
++	{0x000298bc, 0x00000002},
++	{0x000298d0, 0x004b6a8e},
++	{0x000298d4, 0x00000820},
++	{0x000298dc, 0x00000000},
++	{0x000298f0, 0x00000000},
++	{0x000298f4, 0x00000000},
++	{0x00029c04, 0xff55ff55},
++	{0x00029c08, 0x0320ff55},
++	{0x00029c0c, 0x00000000},
++	{0x00029c10, 0x00000000},
++	{0x00029c14, 0x00046384},
++	{0x00029c18, 0x05b6b440},
++	{0x00029c1c, 0x00b6b440},
++	{0x00029d00, 0xc080a333},
++	{0x00029d04, 0x40206c10},
++	{0x00029d08, 0x009c4060},
++	{0x00029d0c, 0x9883800a},
++	{0x00029d10, 0x01834061},
++	{0x00029d14, 0x00c0040b},
++	{0x00029d18, 0x00000000},
++	{0x00029e08, 0x0038230c},
++	{0x00029e24, 0x990bb515},
++	{0x00029e28, 0x0c6f0000},
++	{0x00029e30, 0x06336f77},
++	{0x00029e34, 0x6af6532f},
++	{0x00029e38, 0x0cc80c00},
++	{0x00029e40, 0x0d361820},
++	{0x00029e4c, 0x00001004},
++	{0x00029e50, 0x00ff03f1},
++	{0x00029fc0, 0x813e4789},
++	{0x00029fc4, 0x0001efb5},
++	{0x00029fcc, 0x40000014},
++	{0x00029fd0, 0x02993b93},
++	{0x00029fd4, 0x81e5a8ab},
++	{0x0002a20c, 0x00000000},
++	{0x0002a218, 0x00000000},
++	{0x0002a21c, 0x00000000},
++	{0x0002a228, 0x10002310},
++	{0x0002a23c, 0x00000000},
++	{0x0002a244, 0x0c000000},
++	{0x0002a248, 0x00000140},
++	{0x0002a2a0, 0x0000000f},
++	{0x0002a2c0, 0x0000000f},
++	{0x0002a2c8, 0x00000000},
++	{0x0002a2d4, 0x00000000},
++	{0x0002a344, 0x00000000},
++	{0x0002a34c, 0x00000000},
++	{0x0002a350, 0x0000a000},
++	{0x0002a360, 0x00000000},
++	{0x0002a36c, 0x00000000},
++	{0x0002a384, 0x00000001},
++	{0x0002a388, 0x00003444},
++	{0x0002a38c, 0x00000000},
++	{0x0002a390, 0x210d0401},
++	{0x0002a394, 0xab9a7144},
++	{0x0002a398, 0x00000201},
++	{0x0002a39c, 0x45454545},
++	{0x0002a3a0, 0x3c466478},
++	{0x0002a3a4, 0x3a363600},
++	{0x0002a3a8, 0x0000003a},
++	{0x0002a3ac, 0x00000000},
++	{0x0002a3b0, 0x009011fe},
++	{0x0002a3b4, 0x00000034},
++	{0x0002a3b8, 0x00b3ec0a},
++	{0x0002a3bc, 0x00000036},
++	{0x0002a3c0, 0x20202020},
++	{0x0002a3c4, 0x22222220},
++	{0x0002a3c8, 0x20200020},
++	{0x0002a3cc, 0x20202020},
++	{0x0002a3d0, 0x20202020},
++	{0x0002a3d4, 0x20202020},
++	{0x0002a3d8, 0x20202020},
++	{0x0002a3dc, 0x20202020},
++	{0x0002a3e0, 0x20202020},
++	{0x0002a3e4, 0x20202020},
++	{0x0002a3e8, 0x20202020},
++	{0x0002a3ec, 0x20202020},
++	{0x0002a3f0, 0x00000000},
++	{0x0002a3f4, 0x00000000},
++	{0x0002a3f8, 0x0c9bd380},
++	{0x0002a3fc, 0x000f0f01},
++	{0x0002a400, 0x8fa91f01},
++	{0x0002a404, 0x00000000},
++	{0x0002a408, 0x0e79e5c6},
++	{0x0002a40c, 0x00820820},
++	{0x0002a414, 0x1ce739ce},
++	{0x0002a418, 0x2d001dce},
++	{0x0002a41c, 0x1ce739ce},
++	{0x0002a420, 0x000001ce},
++	{0x0002a424, 0x1ce739ce},
++	{0x0002a428, 0x000001ce},
++	{0x0002a42c, 0x1ce739ce},
++	{0x0002a430, 0x1ce739ce},
++	{0x0002a434, 0x00000000},
++	{0x0002a438, 0x00001801},
++	{0x0002a43c, 0x00000000},
++	{0x0002a444, 0x00000000},
++	{0x0002a448, 0x05000080},
++	{0x0002a44c, 0x00000001},
++	{0x0002a450, 0x00010000},
++	{0x0002a454, 0x05000000},
++	{0x0002a458, 0x00000000},
++	{0x0002a45c, 0x20202020},
++	{0x0002a460, 0x20202020},
++	{0x0002a464, 0x000739ce},
++	{0x0002a468, 0x000739ce},
++	{0x0002a644, 0xbfad9fee},
++	{0x0002a648, 0x0048660a},
++	{0x0002a64c, 0x00003c37},
++	{0x0002a670, 0x03020100},
++	{0x0002a674, 0x21200504},
++	{0x0002a678, 0x61602322},
++	{0x0002a67c, 0x65646362},
++	{0x0002a680, 0x6b6a6968},
++	{0x0002a684, 0xe2706d6c},
++	{0x0002a688, 0x000000e3},
++	{0x0002a690, 0x00000838},
++	{0x0002a7cc, 0x00000000},
++	{0x0002a7d0, 0x00000000},
++	{0x0002a7d4, 0x00000004},
++	{0x0002a7dc, 0x00000000},
++	{0x0002a8d0, 0x004b6a8e},
++	{0x0002a8d4, 0x00000820},
++	{0x0002a8dc, 0x00000000},
++	{0x0002a8f0, 0x00000000},
++	{0x0002a8f4, 0x00000000},
++	{0x0002b2d0, 0x00000080},
++	{0x0002b2d4, 0x00000000},
++	{0x0002b408, 0x0e79e5c0},
++	{0x0002b40c, 0x00820820},
++	{0x0002b420, 0x00000000},
++	{0x0002b43c, 0x00000000},
++	{0x0002b8d0, 0x004b6a8e},
++	{0x0002b8d4, 0x00000820},
++	{0x0002b8dc, 0x00000000},
++	{0x0002b8f0, 0x00000000},
++	{0x0002b8f4, 0x00000000},
++	{0x0002c2d0, 0x00000080},
++	{0x0002c2d4, 0x00000000},
++	{0x0002c408, 0x0e79e5c0},
++	{0x0002c40c, 0x00820820},
++	{0x0002c420, 0x00000000},
++	{0x0002c43c, 0x00000000},
++	{0x0002d8d0, 0x004b6a8e},
++	{0x0002d8d4, 0x00000820},
++	{0x0002d8dc, 0x00000000},
++	{0x0002d8f0, 0x00000000},
++	{0x0002d8f4, 0x00000000},
++	{0x0002e408, 0x0e79e5c0},
++	{0x0002e40c, 0x00820820},
++	{0x0002e420, 0x00000000},
++	{0x0002e43c, 0x00000000},
++};
++
++static const u32 qcn550x_1p0_baseband_postamble[][5] = {
++	/* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
++	{0x00029810, 0xd00a8105, 0xd00a8105, 0xd00a8109, 0xd00a8109},
++	{0x00029820, 0x206a022e, 0x206a022e, 0x206a012e, 0x206a012e},
++	{0x00029824, 0x5ac640d0, 0x5ac640d0, 0x5ac621f1, 0x5ac621f1},
++	{0x00029828, 0x06903081, 0x06903081, 0x07d43881, 0x07d43881},
++	{0x0002982c, 0x05eea6d4, 0x05eea6d4, 0x05eea6d4, 0x05eea6d4},
++	{0x00029830, 0x0000059c, 0x0000059c, 0x0000099c, 0x0000099c},
++	{0x00029c00, 0x000003c4, 0x000003c4, 0x000003c4, 0x000003c4},
++	{0x00029e00, 0x8372111a, 0x8372111a, 0x837216a1, 0x837216a1},
++	{0x00029e04, 0x001c0000, 0x001c0000, 0x001c0000, 0x001c0000},
++	{0x00029e0c, 0x6c4000e2, 0x6d4000e2, 0x6d4000de, 0x6c4000de},
++	{0x00029e10, 0x7ec88d2e, 0x7ec88d2e, 0x7ec87d2e, 0x7ec87d2e},
++	{0x00029e14, 0x37b95d5e, 0x37b9605e, 0x3379505e, 0x3377505e},
++	{0x00029e18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
++	{0x00029e1c, 0x0001cf9c, 0x0001cf9c, 0x00021f9c, 0x00021f9c},
++	{0x00029e20, 0x000003b5, 0x000003b5, 0x000003a6, 0x000003a6},
++	{0x00029e2c, 0x0000001c, 0x0000001c, 0x00000021, 0x00000021},
++	{0x00029e3c, 0xcfa10822, 0xcfa10822, 0xcf906222, 0xcf906222},
++	{0x00029e44, 0xfe321e27, 0xfe321e27, 0xfe291e27, 0xfe291e27},
++	{0x00029e48, 0x5030201a, 0x5030201a, 0x50302012, 0x50302012},
++	{0x00029fc8, 0x0002f000, 0x0002f000, 0x0002e000, 0x0002e000},
++	{0x0002a204, 0x085c1ec0, 0x085c1ec4, 0x0cfc0fc4, 0x0cfc0fc0},
++	{0x0002a208, 0x00000104, 0x00000104, 0x00000004, 0x00000004},
++	{0x0002a22c, 0x07e26a2f, 0x07e26a2f, 0x01026a2f, 0x01026a2f},
++	{0x0002a230, 0x0000400a, 0x00004014, 0x00004016, 0x0000400b},
++	{0x0002a234, 0xc0000fff, 0xd0000fff, 0xd0000fff, 0xc0000fff},
++	{0x0002a238, 0xffb01018, 0xffb01018, 0xffb01018, 0xffb01018},
++	{0x0002a250, 0x00000000, 0x00000000, 0x00000210, 0x00000108},
++	{0x0002a254, 0x000007d0, 0x00000fa0, 0x00001130, 0x00000898},
++	{0x0002a258, 0x02020002, 0x02020002, 0x02020002, 0x02020002},
++	{0x0002a25c, 0x01001010, 0x01001010, 0x01011010, 0x01011010},
++	{0x0002a260, 0x0a021501, 0x0a021501, 0x3a021501, 0x3a021501},
++	{0x0002a264, 0x00000e0e, 0x00000e0e, 0x01000e0e, 0x01000e0e},
++	{0x0002a280, 0x00000007, 0x00000007, 0x0000000b, 0x0000000b},
++	{0x0002a284, 0x00000000, 0x00000000, 0x00000010, 0x00000010},
++	{0x0002a288, 0x00000110, 0x00000110, 0x00000110, 0x00000110},
++	{0x0002a28c, 0x00022222, 0x00022222, 0x00022222, 0x00022222},
++	{0x0002a2c4, 0x00158d18, 0x00158d18, 0x00158d18, 0x00158d18},
++	{0x0002a2cc, 0x18c50033, 0x18c43433, 0x18c41033, 0x18c44c33},
++	{0x0002a2d0, 0x00041982, 0x00041982, 0x00041982, 0x00041982},
++	{0x0002a2d8, 0x799ca83b, 0x799ca83b, 0x799ca83b, 0x799ca83b},
++	{0x0002a358, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
++	{0x0002a830, 0x0000019c, 0x0000019c, 0x0000019c, 0x0000019c},
++	{0x0002ae04, 0x001c0000, 0x001c0000, 0x001c0000, 0x001c0000},
++	{0x0002ae18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
++	{0x0002ae1c, 0x0000019c, 0x0000019c, 0x0000019c, 0x0000019c},
++	{0x0002ae20, 0x000001b5, 0x000001b5, 0x000001a6, 0x000001a6},
++	{0x0002b284, 0x00000000, 0x00000000, 0x00000010, 0x00000010},
++	{0x0002b830, 0x0000019c, 0x0000019c, 0x0000019c, 0x0000019c},
++	{0x0002be04, 0x001c0000, 0x001c0000, 0x001c0000, 0x001c0000},
++	{0x0002be18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
++	{0x0002be1c, 0x0000019c, 0x0000019c, 0x0000019c, 0x0000019c},
++	{0x0002be20, 0x000001b5, 0x000001b5, 0x000001a6, 0x000001a6},
++	{0x0002c284, 0x00000000, 0x00000000, 0x00000010, 0x00000010},
++	{0x0002d830, 0x0000019c, 0x0000019c, 0x0000019c, 0x0000019c},
++	{0x0002de04, 0x001c0000, 0x001c0000, 0x001c0000, 0x001c0000},
++	{0x0002de18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
++	{0x0002de1c, 0x0000019c, 0x0000019c, 0x0000019c, 0x0000019c},
++	{0x0002de20, 0x000001b5, 0x000001b5, 0x000001a6, 0x000001a6},
++	{0x0002e284, 0x00000000, 0x00000000, 0x00000010, 0x00000010},
++};
++
++static const u32 qcn550x_1p0_radio_core[][2] = {
++	/* Addr      allmodes  */
++	{0x00016000, 0x36db6db6},
++	{0x00016004, 0x8db6db40},
++	{0x00016008, 0x73f00000},
++	{0x0001600c, 0x00000000},
++	{0x00016040, 0x3f80fff8},
++	{0x0001604c, 0x000f0278},
++	{0x00016050, 0x8036d36c},
++	{0x00016054, 0x6db60000},
++	{0x00016080, 0x00080000},
++	{0x00016084, 0x0e48048c},
++	{0x00016088, 0x14214514},
++	{0x0001608c, 0x119f080a},
++	{0x00016090, 0x24926490},
++	{0x00016094, 0x00000000},
++	{0x000160a0, 0x02108ffe},
++	{0x000160a4, 0x812fc373},
++	{0x000160a8, 0x423c8300},
++	{0x000160b4, 0x92480000},
++	{0x000160c0, 0x006db6d8},
++	{0x000160c4, 0x24b6db6c},
++	{0x000160c8, 0x6db6db6c},
++	{0x000160cc, 0x6db6fb7c},
++	{0x000160d0, 0x6db6da44},
++	{0x00016100, 0x07ff8001},
++	{0x00016108, 0x00080010},
++	{0x00016144, 0x01884080},
++	{0x00016148, 0x00008058},
++	{0x00016288, 0xa0307860},
++	{0x0001628c, 0x50000000},
++	{0x00016290, 0x4b96250b},
++	{0x00016294, 0x00000000},
++	{0x00016380, 0x00000000},
++	{0x00016384, 0x00000000},
++	{0x00016388, 0x00800700},
++	{0x0001638c, 0x00800700},
++	{0x00016390, 0x00800700},
++	{0x00016394, 0x00000000},
++	{0x00016398, 0x00000000},
++	{0x0001639c, 0x00000000},
++	{0x000163a0, 0x00000001},
++	{0x000163a4, 0x00000001},
++	{0x000163a8, 0x00000000},
++	{0x000163ac, 0x00000000},
++	{0x000163b0, 0x00000000},
++	{0x000163b4, 0x00000000},
++	{0x000163b8, 0x00000000},
++	{0x000163bc, 0x00000000},
++	{0x000163c0, 0x000000a0},
++	{0x000163c4, 0x000c0000},
++	{0x000163c8, 0x14021402},
++	{0x000163cc, 0x00001402},
++	{0x000163d0, 0x00000000},
++	{0x000163d4, 0x00000000},
++	{0x00016400, 0x36db6db6},
++	{0x00016404, 0x8db6db40},
++	{0x00016408, 0x73f00000},
++	{0x0001640c, 0x00000000},
++	{0x00016440, 0x3f80fff8},
++	{0x0001644c, 0x000f0278},
++	{0x00016450, 0x8036d36c},
++	{0x00016454, 0x6db60000},
++	{0x00016500, 0x07ff8001},
++	{0x00016508, 0x00080010},
++	{0x00016544, 0x01884080},
++	{0x00016548, 0x00008058},
++	{0x00016780, 0x00000000},
++	{0x00016784, 0x00000000},
++	{0x00016788, 0x00800700},
++	{0x0001678c, 0x00800700},
++	{0x00016790, 0x00800700},
++	{0x00016794, 0x00000000},
++	{0x00016798, 0x00000000},
++	{0x0001679c, 0x00000000},
++	{0x000167a0, 0x00000001},
++	{0x000167a4, 0x00000001},
++	{0x000167a8, 0x00000000},
++	{0x000167ac, 0x00000000},
++	{0x000167b0, 0x00000000},
++	{0x000167b4, 0x00000000},
++	{0x000167b8, 0x00000000},
++	{0x000167bc, 0x00000000},
++	{0x000167c0, 0x000000a0},
++	{0x000167c4, 0x000c0000},
++	{0x000167c8, 0x14021402},
++	{0x000167cc, 0x00001402},
++	{0x000167d0, 0x00000000},
++	{0x000167d4, 0x00000000},
++	{0x00016800, 0x36db6db6},
++	{0x00016804, 0x8db6db40},
++	{0x00016808, 0x73f00000},
++	{0x0001680c, 0x00000000},
++	{0x00016840, 0x3f80fff8},
++	{0x0001684c, 0x000f0278},
++	{0x00016850, 0x8036d36c},
++	{0x00016854, 0x6db60000},
++	{0x00016900, 0x07ff8001},
++	{0x00016908, 0x00080010},
++	{0x00016944, 0x01884080},
++	{0x00016948, 0x00008058},
++	{0x00016b80, 0x00000000},
++	{0x00016b84, 0x00000000},
++	{0x00016b88, 0x00800700},
++	{0x00016b8c, 0x00800700},
++	{0x00016b90, 0x00800700},
++	{0x00016b94, 0x00000000},
++	{0x00016b98, 0x00000000},
++	{0x00016b9c, 0x00000000},
++	{0x00016ba0, 0x00000001},
++	{0x00016ba4, 0x00000001},
++	{0x00016ba8, 0x00000000},
++	{0x00016bac, 0x00000000},
++	{0x00016bb0, 0x00000000},
++	{0x00016bb4, 0x00000000},
++	{0x00016bb8, 0x00000000},
++	{0x00016bbc, 0x00000000},
++	{0x00016bc0, 0x000000a0},
++	{0x00016bc4, 0x000c0000},
++	{0x00016bc8, 0x14021402},
++	{0x00016bcc, 0x00001402},
++	{0x00016bd0, 0x00000000},
++	{0x00016bd4, 0x00000000},
++	{0x00016c00, 0x36db6db6},
++	{0x00016c04, 0x8db6db40},
++	{0x00016c08, 0x73f00000},
++	{0x00016c0c, 0x00000000},
++	{0x00016c40, 0x3f80fff8},
++	{0x00016c4c, 0x000f0278},
++	{0x00016c50, 0x8036d36c},
++	{0x00016c54, 0x6db60000},
++	{0x00016cc0, 0x633c8186},
++	{0x00016d00, 0x07ff8001},
++	{0x00016d08, 0x00080010},
++	{0x00016d44, 0x01884080},
++	{0x00016d48, 0x00008058},
++	{0x00016f80, 0x00000000},
++	{0x00016f84, 0x00000000},
++	{0x00016f88, 0x00800700},
++	{0x00016f8c, 0x00800700},
++	{0x00016f90, 0x00800700},
++	{0x00016f94, 0x00000000},
++	{0x00016f98, 0x00000000},
++	{0x00016f9c, 0x00000000},
++	{0x00016fa0, 0x00000001},
++	{0x00016fa4, 0x00000001},
++	{0x00016fa8, 0x00000000},
++	{0x00016fac, 0x00000000},
++	{0x00016fb0, 0x00000000},
++	{0x00016fb4, 0x00000000},
++	{0x00016fb8, 0x00000000},
++	{0x00016fbc, 0x00000000},
++	{0x00016fc0, 0x000000a0},
++	{0x00016fc4, 0x000c0000},
++	{0x00016fc8, 0x14021402},
++	{0x00016fcc, 0x00001402},
++	{0x00016fd0, 0x00000000},
++	{0x00016fd4, 0x00000000},
++};
++
++static const u32 qcn550x_1p0_radio_postamble[][5] = {
++	/* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
++	{0x00016098, 0xd2055554, 0xd2055554, 0xc2028f5c, 0xc2028f5c},
++	{0x0001609c, 0x02566f3a, 0x02566f3a, 0x07d08f25, 0x07d08f25},
++	{0x000160ac, 0x24647c01, 0x24647c01, 0x24646801, 0x24646801},
++	{0x000160b0, 0x09885f52, 0x09885f52, 0x08fe7f46, 0x08fe7f46},
++	{0x00016104, 0xb7a00000, 0xb7a00000, 0xfff80001, 0xfff80001},
++	{0x0001610c, 0xc0000000, 0xc0000000, 0x00000000, 0x00000000},
++	{0x00016140, 0x10804008, 0x10804008, 0x50804008, 0x50804008},
++	{0x00016504, 0xb7a00000, 0xb7a00000, 0xfff80001, 0xfff80001},
++	{0x0001650c, 0xc0000000, 0xc0000000, 0x00000000, 0x00000000},
++	{0x00016540, 0x10804008, 0x10804008, 0x50804008, 0x50804008},
++	{0x00016904, 0xb7a00000, 0xb7a00000, 0xfff80001, 0xfff80001},
++	{0x0001690c, 0xc0000000, 0xc0000000, 0x00000000, 0x00000000},
++	{0x00016940, 0x10804008, 0x10804008, 0x50804008, 0x50804008},
++	{0x00016d04, 0xb7a00000, 0xb7a00000, 0xfff80001, 0xfff80001},
++	{0x00016d0c, 0xc0000000, 0xc0000000, 0x00000000, 0x00000000},
++	{0x00016d40, 0x10804008, 0x10804008, 0x50804008, 0x50804008},
++};
++
++static const u32 qcn550x_1p0_baseband_core_txfir_coeff_japan_2484[][2] = {
++	/* Addr      allmodes  */
++	{0x0002a38c, 0x00000000},
++	{0x0002a390, 0x6f7f0301},
++	{0x0002a394, 0xca9228ee},
++};
++
++static const u32 qcn550x_1p0_modes_no_xpa_tx_gain_table[][3] = {
++	/* Addr      5G          2G        */
++	{0x00016044, 0x049242e4, 0x049242e4},
++	{0x00016048, 0x64925a70, 0x64925a70},
++	{0x00016148, 0x00008050, 0x00008050},
++	{0x00016280, 0x42222000, 0x42222000},
++	{0x00016284, 0x0060800b, 0x0060800b},
++	{0x00016444, 0x049242ed, 0x049242ed},
++	{0x00016448, 0x6c925a70, 0x6c925a70},
++	{0x00016548, 0x00008050, 0x00008050},
++	{0x00016844, 0x049242e4, 0x049242e4},
++	{0x00016848, 0x6c925a70, 0x6c925a70},
++	{0x00016948, 0x00008050, 0x00008050},
++	{0x00016c44, 0x049242e4, 0x049242e4},
++	{0x00016c48, 0x6c925a70, 0x6c925a70},
++	{0x00016d48, 0x00008050, 0x00008050},
++	{0x0002a2dc, 0x16ea554a, 0x16ea554a},
++	{0x0002a2e0, 0xe473668c, 0xe473668c},
++	{0x0002a2e4, 0x38fc4710, 0x38fc4710},
++	{0x0002a2e8, 0x3cfb8000, 0x3cfb8000},
++	{0x0002a39c, 0x45454545, 0x45454545},
++	{0x0002a3a4, 0x3a3e3e00, 0x3a3e3e00},
++	{0x0002a3b0, 0x00a01404, 0x00a01404},
++	{0x0002a3b4, 0x00000034, 0x00000034},
++	{0x0002a3b8, 0x00800408, 0x00800408},
++	{0x0002a3bc, 0x00000036, 0x00000036},
++	{0x0002a410, 0x000040dc, 0x000040dc},
++	{0x0002a500, 0x09000040, 0x09000040},
++	{0x0002a504, 0x0b000041, 0x0b000041},
++	{0x0002a508, 0x0d000042, 0x0d000042},
++	{0x0002a50c, 0x11000044, 0x11000044},
++	{0x0002a510, 0x15000046, 0x15000046},
++	{0x0002a514, 0x1d000440, 0x1d000440},
++	{0x0002a518, 0x1f000441, 0x1f000441},
++	{0x0002a51c, 0x21000442, 0x21000442},
++	{0x0002a520, 0x23000443, 0x23000443},
++	{0x0002a524, 0x28000860, 0x28000860},
++	{0x0002a528, 0x2a000861, 0x2a000861},
++	{0x0002a52c, 0x2c000862, 0x2c000862},
++	{0x0002a530, 0x2e000863, 0x2e000863},
++	{0x0002a534, 0x30000864, 0x30000864},
++	{0x0002a538, 0x33000e61, 0x33000e61},
++	{0x0002a53c, 0x35000e62, 0x35000e62},
++	{0x0002a540, 0x3b000e65, 0x3b000e65},
++	{0x0002a544, 0x49001ee2, 0x49001ee2},
++	{0x0002a548, 0x4b001ee3, 0x4b001ee3},
++	{0x0002a54c, 0x4d001ee4, 0x4d001ee4},
++	{0x0002a550, 0x4f001ee5, 0x4f001ee5},
++	{0x0002a554, 0x52001ee6, 0x52001ee6},
++	{0x0002a558, 0x56001eea, 0x56001eea},
++	{0x0002a55c, 0x5a001eec, 0x5a001eec},
++	{0x0002a560, 0x5e001ef0, 0x5e001ef0},
++	{0x0002a564, 0x60001ef1, 0x60001ef1},
++	{0x0002a568, 0x61001ef2, 0x61001ef2},
++	{0x0002a56c, 0x62001ef3, 0x62001ef3},
++	{0x0002a570, 0x63001ef4, 0x63001ef4},
++	{0x0002a574, 0x64001ef5, 0x64001ef5},
++	{0x0002a578, 0x65001ffc, 0x65001ffc},
++	{0x0002a57c, 0x65001ffc, 0x65001ffc},
++	{0x0002a600, 0x00000000, 0x00000000},
++	{0x0002a604, 0x00000000, 0x00000000},
++	{0x0002a608, 0x00000000, 0x00000000},
++	{0x0002a60c, 0x00000000, 0x00000000},
++	{0x0002a610, 0x00404000, 0x00404000},
++	{0x0002a614, 0x00404101, 0x00404101},
++	{0x0002a618, 0x00404101, 0x00404101},
++	{0x0002a61c, 0x00404101, 0x00404101},
++	{0x0002a620, 0x00404101, 0x00404101},
++	{0x0002a624, 0x02008802, 0x02008802},
++	{0x0002a628, 0x0280c802, 0x0280c802},
++	{0x0002a62c, 0x0280ca03, 0x0280ca03},
++	{0x0002a630, 0x0280ca03, 0x0280ca03},
++	{0x0002a634, 0x03c10f04, 0x03c10f04},
++	{0x0002a638, 0x03c10f04, 0x03c10f04},
++	{0x0002a63c, 0x05015405, 0x05015405},
++	{0x0002b2dc, 0x16ea554a, 0x16ea554a},
++	{0x0002b2e0, 0xe473668c, 0xe473668c},
++	{0x0002b2e4, 0x38fc4710, 0x38fc4710},
++	{0x0002b2e8, 0x3cfb8000, 0x3cfb8000},
++	{0x0002c2dc, 0x16ea554a, 0x16ea554a},
++	{0x0002c2e0, 0xe47c668c, 0xe473668c},
++	{0x0002c2e4, 0x38fc4710, 0x38fc4710},
++	{0x0002c2e8, 0x3cfb8000, 0x3cfb8000},
++	{0x0002e2dc, 0x16ea554a, 0x16ea554a},
++	{0x0002e2e0, 0xe473668c, 0xe473668c},
++	{0x0002e2e4, 0x38fc4710, 0x38fc4710},
++	{0x0002e2e8, 0x3cfb8000, 0x3cfb8000},
++};
++
++static const u32 qcn550x_1p0_modes_xpa_tx_gain_table[][3] = {
++	/* Addr      5G          2G        */
++	{0x00016044, 0x024922e4, 0x024922e4},
++	{0x00016048, 0x6c927a70, 0x6c927a70},
++	{0x00016090, 0x249b64d0, 0x249b64d0},
++	{0x00016280, 0x42222000, 0x42222000},
++	{0x00016284, 0x0060800b, 0x0060800b},
++	{0x00016444, 0x024922e4, 0x024922e4},
++	{0x00016448, 0x6c927a70, 0x6c927a70},
++	{0x00016844, 0x024922e4, 0x024922e4},
++	{0x00016848, 0x6c927a70, 0x6c927a70},
++	{0x00016c44, 0x024922e4, 0x024922e4},
++	{0x00016c48, 0x6c927a70, 0x6c927a70},
++	{0x0002a2dc, 0xcc69ac8c, 0xcc69ac8c},
++	{0x0002a2e0, 0xf0b23100, 0xf0b23100},
++	{0x0002a2e4, 0xffffc000, 0xffffc000},
++	{0x0002a2e8, 0xc0000000, 0xc0000000},
++	{0x0002a410, 0x000040d2, 0x000040d2},
++	{0x0002a418, 0x2d0019ce, 0x2d0019ce},
++	{0x0002a500, 0x0a000040, 0x0a000040},
++	{0x0002a504, 0x0c000041, 0x0c000041},
++	{0x0002a508, 0x0e000042, 0x0e000042},
++	{0x0002a50c, 0x10000043, 0x10000043},
++	{0x0002a510, 0x16000240, 0x16000240},
++	{0x0002a514, 0x1d000440, 0x1d000440},
++	{0x0002a518, 0x1f000441, 0x1f000441},
++	{0x0002a51c, 0x23000443, 0x23000443},
++	{0x0002a520, 0x25000444, 0x25000444},
++	{0x0002a524, 0x29000a40, 0x29000a40},
++	{0x0002a528, 0x2d000a42, 0x2d000a42},
++	{0x0002a52c, 0x2f000a43, 0x2f000a43},
++	{0x0002a530, 0x31000a44, 0x31000a44},
++	{0x0002a534, 0x35000a46, 0x35000a46},
++	{0x0002a538, 0x38000ce0, 0x38000ce0},
++	{0x0002a53c, 0x3c000ce2, 0x3c000ce2},
++	{0x0002a540, 0x3e000ce3, 0x3e000ce3},
++	{0x0002a544, 0x40000ce4, 0x40000ce4},
++	{0x0002a548, 0x46001ee0, 0x46001ee0},
++	{0x0002a54c, 0x4a001ee2, 0x4a001ee2},
++	{0x0002a550, 0x4e001ee4, 0x4e001ee4},
++	{0x0002a554, 0x52001ee6, 0x52001ee6},
++	{0x0002a558, 0x56001eea, 0x56001eea},
++	{0x0002a55c, 0x5a001eec, 0x5a001eec},
++	{0x0002a560, 0x5e001ef0, 0x5e001ef0},
++	{0x0002a564, 0x60001ef1, 0x60001ef1},
++	{0x0002a568, 0x61001ef2, 0x61001ef2},
++	{0x0002a56c, 0x62001ef3, 0x62001ef3},
++	{0x0002a570, 0x63001ef4, 0x63001ef4},
++	{0x0002a574, 0x64001ef5, 0x64001ef5},
++	{0x0002a578, 0x65001ffc, 0x65001ffc},
++	{0x0002a57c, 0x65001ffc, 0x65001ffc},
++	{0x0002a600, 0x00000000, 0x00000000},
++	{0x0002a604, 0x00000000, 0x00000000},
++	{0x0002a608, 0x00000000, 0x00000000},
++	{0x0002a60c, 0x00000000, 0x00000000},
++	{0x0002a610, 0x00000000, 0x00000000},
++	{0x0002a614, 0x00000000, 0x00000000},
++	{0x0002a618, 0x00000000, 0x00000000},
++	{0x0002a61c, 0x00804201, 0x00804201},
++	{0x0002a620, 0x00804201, 0x00804201},
++	{0x0002a624, 0x00804201, 0x00804201},
++	{0x0002a628, 0x00804201, 0x00804201},
++	{0x0002a62c, 0x02808a02, 0x02808a02},
++	{0x0002a630, 0x0340cd03, 0x0340cd03},
++	{0x0002a634, 0x0340cd03, 0x0340cd03},
++	{0x0002a638, 0x0340cd03, 0x0340cd03},
++	{0x0002a63c, 0x05011404, 0x05011404},
++	{0x0002b2dc, 0xcc69ac8c, 0xcc69ac8c},
++	{0x0002b2e0, 0xf0b23100, 0xf0b23100},
++	{0x0002b2e4, 0xffffc000, 0xffffc000},
++	{0x0002b2e8, 0xc0000000, 0xc0000000},
++	{0x0002c2dc, 0xcc69ac8c, 0xcc69ac8c},
++	{0x0002c2e0, 0xf0b23100, 0xf0b23100},
++	{0x0002c2e4, 0xffffc000, 0xffffc000},
++	{0x0002c2e8, 0xc0000000, 0xc0000000},
++	{0x0002e2dc, 0xcc69ac8c, 0xcc69ac8c},
++	{0x0002e2e0, 0xf0b23100, 0xf0b23100},
++	{0x0002e2e4, 0xffffc000, 0xffffc000},
++	{0x0002e2e8, 0xc0000000, 0xc0000000},
++};
++
++static const u32 qcn550x_1p0_modes_no_xpa_low_ob_db_tx_gain_table[][3] = {
++	/* Addr      5G          2G        */
++	{0x00016044, 0x046e42e4, 0x046e42e4},
++	{0x00016048, 0x64925a70, 0x64925a70},
++	{0x00016148, 0x00008050, 0x00008050},
++	{0x00016280, 0x42222000, 0x42222000},
++	{0x00016284, 0x0060800b, 0x0060800b},
++	{0x00016444, 0x046e42ed, 0x046e42ed},
++	{0x00016448, 0x6c925a70, 0x6c925a70},
++	{0x00016548, 0x00008050, 0x00008050},
++	{0x00016844, 0x046e42e4, 0x046e42e4},
++	{0x00016848, 0x6c925a70, 0x6c925a70},
++	{0x00016948, 0x00008050, 0x00008050},
++	{0x00016c44, 0x046e42e4, 0x046e42e4},
++	{0x00016c48, 0x6c925a70, 0x6c925a70},
++	{0x00016d48, 0x00008050, 0x00008050},
++	{0x0002a2dc, 0x16ea554a, 0x16ea554a},
++	{0x0002a2e0, 0xe473668c, 0xe473668c},
++	{0x0002a2e4, 0x38fc4710, 0x38fc4710},
++	{0x0002a2e8, 0x3cfb8000, 0x3cfb8000},
++	{0x0002a39c, 0x45454545, 0x45454545},
++	{0x0002a3a4, 0x3a3e3e00, 0x3a3e3e00},
++	{0x0002a3b0, 0x00a01404, 0x00a01404},
++	{0x0002a3b4, 0x00000034, 0x00000034},
++	{0x0002a3b8, 0x00800408, 0x00800408},
++	{0x0002a3bc, 0x00000036, 0x00000036},
++	{0x0002a410, 0x000040dc, 0x000040dc},
++	{0x0002a414, 0x16b739ce, 0x16b739ce},
++	{0x0002a418, 0x2d001d8b, 0x2d001d8b},
++	{0x0002a41c, 0x16b5adce, 0x16b5adce},
++	{0x0002a420, 0x0000014a, 0x0000014a},
++	{0x0002a424, 0x14a525cc, 0x14a525cc},
++	{0x0002a428, 0x0000012a, 0x0000012a},
++	{0x0002a42c, 0x14a5294a, 0x14a5294a},
++	{0x0002a430, 0x1294a929, 0x1294a929},
++	{0x0002a500, 0x09000040, 0x09000040},
++	{0x0002a504, 0x0b000041, 0x0b000041},
++	{0x0002a508, 0x0d000042, 0x0d000042},
++	{0x0002a50c, 0x11000044, 0x11000044},
++	{0x0002a510, 0x15000046, 0x15000046},
++	{0x0002a514, 0x1d000440, 0x1d000440},
++	{0x0002a518, 0x1f000441, 0x1f000441},
++	{0x0002a51c, 0x21000442, 0x21000442},
++	{0x0002a520, 0x23000443, 0x23000443},
++	{0x0002a524, 0x28000860, 0x28000860},
++	{0x0002a528, 0x2a000861, 0x2a000861},
++	{0x0002a52c, 0x2c000862, 0x2c000862},
++	{0x0002a530, 0x2e000863, 0x2e080863},
++	{0x0002a534, 0x30000864, 0x30000864},
++	{0x0002a538, 0x33000e61, 0x33000e61},
++	{0x0002a53c, 0x35000e62, 0x35000e62},
++	{0x0002a540, 0x3b000e65, 0x3b000e65},
++	{0x0002a544, 0x49001ee2, 0x49001ee2},
++	{0x0002a548, 0x4b001ee3, 0x4b001ee3},
++	{0x0002a54c, 0x4d001ee4, 0x4d001ee4},
++	{0x0002a550, 0x4f001ee5, 0x4f001ee5},
++	{0x0002a554, 0x52001ee6, 0x52001ee6},
++	{0x0002a558, 0x56001eea, 0x56001eea},
++	{0x0002a55c, 0x5a001eec, 0x5a001eec},
++	{0x0002a560, 0x5e001ef0, 0x5e001ef0},
++	{0x0002a564, 0x60001ef1, 0x60001ef1},
++	{0x0002a568, 0x61001ef2, 0x61001ef2},
++	{0x0002a56c, 0x62001ef3, 0x62001ef3},
++	{0x0002a570, 0x63001ef4, 0x63001ef4},
++	{0x0002a574, 0x64001ef5, 0x64001ef5},
++	{0x0002a578, 0x65001ffc, 0x65001ffc},
++	{0x0002a57c, 0x65001ffc, 0x65001ffc},
++	{0x0002a600, 0x00000000, 0x00000000},
++	{0x0002a604, 0x00000000, 0x00000000},
++	{0x0002a608, 0x00000000, 0x00000000},
++	{0x0002a60c, 0x00000000, 0x00000000},
++	{0x0002a610, 0x00404000, 0x00404000},
++	{0x0002a614, 0x00404101, 0x00404101},
++	{0x0002a618, 0x00404101, 0x00404101},
++	{0x0002a61c, 0x00404101, 0x00404101},
++	{0x0002a620, 0x00404101, 0x00404101},
++	{0x0002a624, 0x02008802, 0x02008802},
++	{0x0002a628, 0x0280c802, 0x0280c802},
++	{0x0002a62c, 0x0280ca03, 0x0280ca03},
++	{0x0002a630, 0x0280ca03, 0x0280ca03},
++	{0x0002a634, 0x03c10f04, 0x03c10f04},
++	{0x0002a638, 0x03c10f04, 0x03c10f04},
++	{0x0002a63c, 0x05015405, 0x05015405},
++	{0x0002b2dc, 0x16ea554a, 0x16ea554a},
++	{0x0002b2e0, 0xe473668c, 0xe473668c},
++	{0x0002b2e4, 0x38fc4710, 0x38fc4710},
++	{0x0002b2e8, 0x3cfb8000, 0x3cfb8000},
++	{0x0002c2dc, 0x16ea554a, 0x16ea554a},
++	{0x0002c2e0, 0xe473668c, 0xe473668c},
++	{0x0002c2e4, 0x38fc4710, 0x38fc4710},
++	{0x0002c2e8, 0x3cfb8000, 0x3cfb8000},
++	{0x0002e2dc, 0x16ea554a, 0x16ea554a},
++	{0x0002e2e0, 0xe473668c, 0xe473668c},
++	{0x0002e2e4, 0x38fc4710, 0x38fc4710},
++	{0x0002e2e8, 0x3cfb8000, 0x3cfb8000},
++};
++
++static const u32 qcn550x_1p0_modes_no_xpa_green_tx_gain_table[][3] = {
++	/* Addr      5G          2G        */
++	{0x00016044, 0x849242e4, 0x849242e4},
++	{0x00016048, 0x64925a70, 0x64925a70},
++	{0x00016280, 0x42222000, 0x42222000},
++	{0x00016284, 0x0060800b, 0x0060800b},
++	{0x00016444, 0x849242ed, 0x849242ed},
++	{0x00016448, 0x6c925a70, 0x6c925a70},
++	{0x00016844, 0x849242e4, 0x849242e4},
++	{0x00016848, 0x6c925a70, 0x6c925a70},
++	{0x00016c44, 0x849242e4, 0x849242e4},
++	{0x00016c48, 0x6c925a70, 0x6c925a70},
++	{0x000298bc, 0x00000001, 0x00000001},
++	{0x0002a2dc, 0xd3555284, 0xd3555284},
++	{0x0002a2e0, 0x1c666318, 0x1c666318},
++	{0x0002a2e4, 0xe07bbc00, 0xe07bbc00},
++	{0x0002a2e8, 0xff800000, 0xff800000},
++	{0x0002a3a4, 0x3a3e3e00, 0x3a3e3e00},
++	{0x0002a410, 0x000040dc, 0x000040dc},
++	{0x0002a500, 0x07000040, 0x07000040},
++	{0x0002a504, 0x09000041, 0x09000041},
++	{0x0002a508, 0x0b000042, 0x0b000042},
++	{0x0002a50c, 0x0f000044, 0x0f000044},
++	{0x0002a510, 0x11000045, 0x11000045},
++	{0x0002a514, 0x18000440, 0x18000440},
++	{0x0002a518, 0x1a000441, 0x1a000441},
++	{0x0002a51c, 0x1e000443, 0x1e000443},
++	{0x0002a520, 0x20000444, 0x20000444},
++	{0x0002a524, 0x230004e0, 0x230004e0},
++	{0x0002a528, 0x270004e2, 0x270004e2},
++	{0x0002a52c, 0x290004e3, 0x290004e3},
++	{0x0002a530, 0x2b0004e4, 0x2b0004e4},
++	{0x0002a534, 0x2f0004e6, 0x2f0004e6},
++	{0x0002a538, 0x34000ce0, 0x34000ce0},
++	{0x0002a53c, 0x38000ce2, 0x38000ce2},
++	{0x0002a540, 0x3c000ce4, 0x3c000ce4},
++	{0x0002a544, 0x40000ce6, 0x40000ce6},
++	{0x0002a548, 0x45001ee0, 0x45001ee0},
++	{0x0002a54c, 0x49001ee2, 0x49001ee2},
++	{0x0002a550, 0x4d001ee4, 0x4d001ee4},
++	{0x0002a554, 0x50001ee6, 0x50001ee6},
++	{0x0002a558, 0x53001eea, 0x53001eea},
++	{0x0002a55c, 0x55001eec, 0x55001eec},
++	{0x0002a560, 0x57001ef0, 0x57001ef0},
++	{0x0002a564, 0x58001ef1, 0x58001ef1},
++	{0x0002a568, 0x59001ef2, 0x59001ef2},
++	{0x0002a56c, 0x5a001ef3, 0x5a001ef3},
++	{0x0002a570, 0x5b001ef4, 0x5b001ef4},
++	{0x0002a574, 0x5c001ff5, 0x5c001ff5},
++	{0x0002a578, 0x64001ffc, 0x64001ffc},
++	{0x0002a57c, 0x64001ffc, 0x64001ffc},
++	{0x0002a600, 0x00000000, 0x00000000},
++	{0x0002a604, 0x00000000, 0x00000000},
++	{0x0002a608, 0x00000000, 0x00000000},
++	{0x0002a60c, 0x00000000, 0x00000000},
++	{0x0002a610, 0x00804000, 0x00804000},
++	{0x0002a614, 0x00804201, 0x00804201},
++	{0x0002a618, 0x00804201, 0x00804201},
++	{0x0002a61c, 0x00804201, 0x00804201},
++	{0x0002a620, 0x00804201, 0x00804201},
++	{0x0002a624, 0x00804201, 0x00804201},
++	{0x0002a628, 0x00804201, 0x00804201},
++	{0x0002a62c, 0x02808a02, 0x02808a02},
++	{0x0002a630, 0x0340cd03, 0x0340cd03},
++	{0x0002a634, 0x0340cd03, 0x0340cd03},
++	{0x0002a638, 0x0340cd03, 0x0340cd03},
++	{0x0002a63c, 0x05011404, 0x05011404},
++	{0x0002b2dc, 0xd3555284, 0xd3555284},
++	{0x0002b2e0, 0x1c666318, 0x1c666318},
++	{0x0002b2e4, 0xe07bbc00, 0xe07bbc00},
++	{0x0002b2e8, 0xff800000, 0xff800000},
++	{0x0002c2dc, 0xd3555284, 0xd3555284},
++	{0x0002c2e0, 0x1c666318, 0x1c666318},
++	{0x0002c2e4, 0xe07bbc00, 0xe07bbc00},
++	{0x0002c2e8, 0xff800000, 0xff800000},
++	{0x0002e2dc, 0xd3555284, 0xd3555284},
++	{0x0002e2e0, 0x1c666318, 0x1c666318},
++	{0x0002e2e4, 0xe07bbc00, 0xe07bbc00},
++	{0x0002e2e8, 0xff800000, 0xff800000},
++};
++
++static const u32 qcn550x_1p0_modes_no_xpa_mcal_tx_gain_table[][3] = {
++	/* Addr      5G          2G        */
++	{0x00016044, 0x049242c9, 0x049242c9},
++	{0x00016048, 0x64925a70, 0x64925a70},
++	{0x00016148, 0x00008050, 0x00008050},
++	{0x00016280, 0x42222000, 0x42222000},
++	{0x00016284, 0x0060800b, 0x0060800b},
++	{0x00016444, 0x049242c9, 0x049242c9},
++	{0x00016448, 0x6c925a70, 0x6c925a70},
++	{0x00016548, 0x00008050, 0x00008050},
++	{0x00016844, 0x049242c9, 0x049242c9},
++	{0x00016848, 0x6c925a70, 0x6c925a70},
++	{0x00016948, 0x00008050, 0x00008050},
++	{0x00016c44, 0x049242c9, 0x049242c9},
++	{0x00016c48, 0x6c925a70, 0x6c925a70},
++	{0x00016d48, 0x00008050, 0x00008050},
++	{0x0002a2dc, 0xec69ac94, 0xec69ac94},
++	{0x0002a2e0, 0xf0b23118, 0xf0b23118},
++	{0x0002a2e4, 0xe0fffe00, 0xe0fffe00},
++	{0x0002a2e8, 0xff000000, 0xff000000},
++	{0x0002a39c, 0x42424242, 0x42424242},
++	{0x0002a3a4, 0x3a3e3e00, 0x3a3e3e00},
++	{0x0002a3b0, 0x00a01404, 0x00a01404},
++	{0x0002a3b4, 0x00000034, 0x00000034},
++	{0x0002a3b8, 0x00800408, 0x00800408},
++	{0x0002a3bc, 0x00000036, 0x00000036},
++	{0x0002a410, 0x000050dc, 0x000050dc},
++	{0x0002a500, 0x09000040, 0x09000040},
++	{0x0002a504, 0x0b000041, 0x0b000041},
++	{0x0002a508, 0x0d000042, 0x0d000042},
++	{0x0002a50c, 0x11000044, 0x11000044},
++	{0x0002a510, 0x15000046, 0x15000046},
++	{0x0002a514, 0x1d000440, 0x1d000440},
++	{0x0002a518, 0x1f000441, 0x1f000441},
++	{0x0002a51c, 0x23000443, 0x23000443},
++	{0x0002a520, 0x25000444, 0x25000444},
++	{0x0002a524, 0x280004e0, 0x280004e0},
++	{0x0002a528, 0x2c0004e2, 0x2c0004e2},
++	{0x0002a52c, 0x2e0004e3, 0x2e0004e3},
++	{0x0002a530, 0x300004e4, 0x300004e4},
++	{0x0002a534, 0x340004e6, 0x340004e6},
++	{0x0002a538, 0x37000ce0, 0x37000ce0},
++	{0x0002a53c, 0x3b000ce2, 0x3b000ce2},
++	{0x0002a540, 0x3d000ce3, 0x3d000ce3},
++	{0x0002a544, 0x3f000ce4, 0x3f000ce4},
++	{0x0002a548, 0x45001ee0, 0x45001ee0},
++	{0x0002a54c, 0x49001ee2, 0x49001ee2},
++	{0x0002a550, 0x4d001ee4, 0x4d001ee4},
++	{0x0002a554, 0x51001ee6, 0x51001ee6},
++	{0x0002a558, 0x55001eea, 0x55001eea},
++	{0x0002a55c, 0x59001eec, 0x59001eec},
++	{0x0002a560, 0x5d001ef0, 0x5d001ef0},
++	{0x0002a564, 0x5f001ef1, 0x5f001ef1},
++	{0x0002a568, 0x60001ef2, 0x60001ef2},
++	{0x0002a56c, 0x61001ef3, 0x61001ef3},
++	{0x0002a570, 0x62001ef4, 0x62001ef4},
++	{0x0002a574, 0x63001ef5, 0x63001ef5},
++	{0x0002a578, 0x64001ffc, 0x64001ffc},
++	{0x0002a57c, 0x64001ffc, 0x64001ffc},
++	{0x0002a600, 0x00000000, 0x00000000},
++	{0x0002a604, 0x00804402, 0x00804402},
++	{0x0002a608, 0x00000603, 0x00000603},
++	{0x0002a60c, 0x00804000, 0x00804000},
++	{0x0002a610, 0x01008604, 0x01008604},
++	{0x0002a614, 0x01e14785, 0x01e14785},
++	{0x0002a618, 0x02e1c986, 0x02e1c986},
++	{0x0002a61c, 0x01810785, 0x01810785},
++	{0x0002a620, 0x02618785, 0x02618785},
++	{0x0002a624, 0x01810785, 0x01810785},
++	{0x0002a628, 0x02e1c986, 0x02e1c986},
++	{0x0002a62c, 0x02618785, 0x02618785},
++	{0x0002a630, 0x01810604, 0x01810604},
++	{0x0002a634, 0x01e14785, 0x01e14785},
++	{0x0002a638, 0x02618986, 0x02618986},
++	{0x0002a63c, 0x02618986, 0x02618986},
++	{0x0002b2dc, 0xec69ac94, 0xec69ac94},
++	{0x0002b2e0, 0xf0b23118, 0xf0b23118},
++	{0x0002b2e4, 0xe0fffe00, 0xe0fffe00},
++	{0x0002b2e8, 0xff000000, 0xff000000},
++	{0x0002c2dc, 0xec69ac94, 0xec69ac94},
++	{0x0002c2e0, 0xf0b23118, 0xf0b23118},
++	{0x0002c2e4, 0xe0fffe00, 0xe0fffe00},
++	{0x0002c2e8, 0xff000000, 0xff000000},
++	{0x0002e2dc, 0xec69ac94, 0xec69ac94},
++	{0x0002e2e0, 0xf0b23118, 0xf0b23118},
++	{0x0002e2e4, 0xe0fffe00, 0xe0fffe00},
++	{0x0002e2e8, 0xff000000, 0xff000000},
++};
++
++static const u32 qcn550x_1p0_modes_no_xpa_table_5_tx_gain_table[][3] = {
++	/* Addr      5G          2G        */
++	{0x00016044, 0x049242c9, 0x049242c9},
++	{0x00016048, 0x64925a70, 0x64925a70},
++	{0x00016148, 0x00008050, 0x00008050},
++	{0x00016280, 0x42222000, 0x42222000},
++	{0x00016284, 0x0060800b, 0x0060800b},
++	{0x00016444, 0x049242c9, 0x049242c9},
++	{0x00016448, 0x6c925a70, 0x6c925a70},
++	{0x00016548, 0x00008050, 0x00008050},
++	{0x00016844, 0x049242c9, 0x049242c9},
++	{0x00016848, 0x6c925a70, 0x6c925a70},
++	{0x00016948, 0x00008050, 0x00008050},
++	{0x00016c44, 0x049242c9, 0x049242c9},
++	{0x00016c48, 0x6c925a70, 0x6c925a70},
++	{0x00016d48, 0x00008050, 0x00008050},
++	{0x0002a2dc, 0xf3486e8a, 0xf3486e8a},
++	{0x0002a2e0, 0xfc8c730c, 0xfc8c730c},
++	{0x0002a2e4, 0xff118390, 0xff118390},
++	{0x0002a2e8, 0x0e020000, 0x0e020000},
++	{0x0002a39c, 0x42424242, 0x42424242},
++	{0x0002a3a4, 0x3a3e3e00, 0x3a3e3e00},
++	{0x0002a3b0, 0x00a01404, 0x00a01404},
++	{0x0002a3b4, 0x00000034, 0x00000034},
++	{0x0002a3b8, 0x00800408, 0x00800408},
++	{0x0002a3bc, 0x00000036, 0x00000036},
++	{0x0002a410, 0x000050dc, 0x000050dc},
++	{0x0002a500, 0x1b000060, 0x1b000060},
++	{0x0002a504, 0x1f000062, 0x1f000062},
++	{0x0002a508, 0x23000064, 0x23000064},
++	{0x0002a50c, 0x27000068, 0x27000068},
++	{0x0002a510, 0x2b00006a, 0x2b00006a},
++	{0x0002a514, 0x2d00006b, 0x2d00006b},
++	{0x0002a518, 0x3100006d, 0x3100006d},
++	{0x0002a51c, 0x350000f1, 0x350000f1},
++	{0x0002a520, 0x390004e1, 0x390004e1},
++	{0x0002a524, 0x3c0004e3, 0x3c0004e3},
++	{0x0002a528, 0x3e000464, 0x3e000464},
++	{0x0002a52c, 0x41000c62, 0x41000c62},
++	{0x0002a530, 0x43000c63, 0x43000c63},
++	{0x0002a534, 0x45000c64, 0x45000c64},
++	{0x0002a538, 0x49000c68, 0x49000c68},
++	{0x0002a53c, 0x4b000c69, 0x4b000c69},
++	{0x0002a540, 0x4d000c6a, 0x4d000c6a},
++	{0x0002a544, 0x4f000ceb, 0x4f000ceb},
++	{0x0002a548, 0x53001e64, 0x53001e64},
++	{0x0002a54c, 0x56001e68, 0x56001e68},
++	{0x0002a550, 0x5a001e6a, 0x5a001e6a},
++	{0x0002a554, 0x5e001ee8, 0x5e001ee8},
++	{0x0002a558, 0x60001eea, 0x60001eea},
++	{0x0002a55c, 0x62001eec, 0x62001eec},
++	{0x0002a560, 0x64001ef0, 0x64001ef0},
++	{0x0002a564, 0x65001ef1, 0x65001ef1},
++	{0x0002a568, 0x66001ef2, 0x66001ef2},
++	{0x0002a56c, 0x67001ef3, 0x67001ef3},
++	{0x0002a570, 0x68001ef4, 0x68001ef4},
++	{0x0002a574, 0x69001ef5, 0x69001ef5},
++	{0x0002a578, 0x6a001ffc, 0x6a001ffc},
++	{0x0002a57c, 0x6a001ffc, 0x6a001ffc},
++	{0x0002a600, 0x00804000, 0x00804000},
++	{0x0002a604, 0x00000402, 0x00000402},
++	{0x0002a608, 0x00804201, 0x00804201},
++	{0x0002a60c, 0x00000402, 0x00000402},
++	{0x0002a610, 0x01a14504, 0x01a14504},
++	{0x0002a614, 0x00804786, 0x00804786},
++	{0x0002a618, 0x01008201, 0x01008201},
++	{0x0002a61c, 0x00000000, 0x00000000},
++	{0x0002a620, 0x00804201, 0x00804201},
++	{0x0002a624, 0x00000402, 0x00000402},
++	{0x0002a628, 0x01410201, 0x01410201},
++	{0x0002a62c, 0x01e18685, 0x01e18685},
++	{0x0002a630, 0x01410504, 0x01410504},
++	{0x0002a634, 0x01a14685, 0x01a14685},
++	{0x0002a638, 0x01e18786, 0x01e18786},
++	{0x0002a63c, 0x01e18786, 0x01e18786},
++	{0x0002b2dc, 0xf3486e8a, 0xf3486e8a},
++	{0x0002b2e0, 0xfc8c730c, 0xfc8c730c},
++	{0x0002b2e4, 0xff118390, 0xff118390},
++	{0x0002b2e8, 0x0e020000, 0x0e020000},
++	{0x0002c2dc, 0xf3486e8a, 0xf3486e8a},
++	{0x0002c2e0, 0xfc8c730c, 0xfc8c730c},
++	{0x0002c2e4, 0xff118390, 0xff118390},
++	{0x0002c2e8, 0x0e020000, 0x0e020000},
++	{0x0002e2dc, 0xf3486e8a, 0xf3486e8a},
++	{0x0002e2e0, 0xfc8c730c, 0xfc8c730c},
++	{0x0002e2e4, 0xff118390, 0xff118390},
++	{0x0002e2e8, 0x0e020000, 0x0e020000},
++};
++
++static const u32 qcn550x_1p0_common_rx_gain_table[][2] = {
++	/* Addr      allmodes  */
++	{0x0002a000, 0x00010000},
++	{0x0002a004, 0x00030002},
++	{0x0002a008, 0x00050004},
++	{0x0002a00c, 0x00810080},
++	{0x0002a010, 0x00830082},
++	{0x0002a014, 0x01810180},
++	{0x0002a018, 0x01830182},
++	{0x0002a01c, 0x01850184},
++	{0x0002a020, 0x01890188},
++	{0x0002a024, 0x018b018a},
++	{0x0002a028, 0x018d018c},
++	{0x0002a02c, 0x01910190},
++	{0x0002a030, 0x01930192},
++	{0x0002a034, 0x01950194},
++	{0x0002a038, 0x038a0196},
++	{0x0002a03c, 0x038c038b},
++	{0x0002a040, 0x0390038d},
++	{0x0002a044, 0x03920391},
++	{0x0002a048, 0x03940393},
++	{0x0002a04c, 0x03960395},
++	{0x0002a050, 0x00000000},
++	{0x0002a054, 0x00000000},
++	{0x0002a058, 0x00000000},
++	{0x0002a05c, 0x00000000},
++	{0x0002a060, 0x00000000},
++	{0x0002a064, 0x00000000},
++	{0x0002a068, 0x00000000},
++	{0x0002a06c, 0x00000000},
++	{0x0002a070, 0x00000000},
++	{0x0002a074, 0x00000000},
++	{0x0002a078, 0x00000000},
++	{0x0002a07c, 0x00000000},
++	{0x0002a080, 0x22292929},
++	{0x0002a084, 0x1d1d1d1d},
++	{0x0002a088, 0x1d1d1d1d},
++	{0x0002a08c, 0x1d1d1d1d},
++	{0x0002a090, 0x17171717},
++	{0x0002a094, 0x11111717},
++	{0x0002a098, 0x00030311},
++	{0x0002a09c, 0x00000000},
++	{0x0002a0a0, 0x00000000},
++	{0x0002a0a4, 0x00000000},
++	{0x0002a0a8, 0x00000000},
++	{0x0002a0ac, 0x00000000},
++	{0x0002a0b0, 0x00000000},
++	{0x0002a0b4, 0x00000000},
++	{0x0002a0b8, 0x00000000},
++	{0x0002a0bc, 0x00000000},
++	{0x0002a0c0, 0x001f0000},
++	{0x0002a0c4, 0x01000101},
++	{0x0002a0c8, 0x011e011f},
++	{0x0002a0cc, 0x011c011d},
++	{0x0002a0d0, 0x02030204},
++	{0x0002a0d4, 0x02010202},
++	{0x0002a0d8, 0x021f0200},
++	{0x0002a0dc, 0x0302021e},
++	{0x0002a0e0, 0x03000301},
++	{0x0002a0e4, 0x031e031f},
++	{0x0002a0e8, 0x0402031d},
++	{0x0002a0ec, 0x04000401},
++	{0x0002a0f0, 0x041e041f},
++	{0x0002a0f4, 0x0502041d},
++	{0x0002a0f8, 0x05000501},
++	{0x0002a0fc, 0x051e051f},
++	{0x0002a100, 0x06010602},
++	{0x0002a104, 0x061f0600},
++	{0x0002a108, 0x061d061e},
++	{0x0002a10c, 0x07020703},
++	{0x0002a110, 0x07000701},
++	{0x0002a114, 0x00000000},
++	{0x0002a118, 0x00000000},
++	{0x0002a11c, 0x00000000},
++	{0x0002a120, 0x00000000},
++	{0x0002a124, 0x00000000},
++	{0x0002a128, 0x00000000},
++	{0x0002a12c, 0x00000000},
++	{0x0002a130, 0x00000000},
++	{0x0002a134, 0x00000000},
++	{0x0002a138, 0x00000000},
++	{0x0002a13c, 0x00000000},
++	{0x0002a140, 0x001f0000},
++	{0x0002a144, 0x01000101},
++	{0x0002a148, 0x011e011f},
++	{0x0002a14c, 0x011c011d},
++	{0x0002a150, 0x02030204},
++	{0x0002a154, 0x02010202},
++	{0x0002a158, 0x021f0200},
++	{0x0002a15c, 0x0302021e},
++	{0x0002a160, 0x03000301},
++	{0x0002a164, 0x031e031f},
++	{0x0002a168, 0x0402031d},
++	{0x0002a16c, 0x04000401},
++	{0x0002a170, 0x041e041f},
++	{0x0002a174, 0x0502041d},
++	{0x0002a178, 0x05000501},
++	{0x0002a17c, 0x051e051f},
++	{0x0002a180, 0x06010602},
++	{0x0002a184, 0x061f0600},
++	{0x0002a188, 0x061d061e},
++	{0x0002a18c, 0x07020703},
++	{0x0002a190, 0x07000701},
++	{0x0002a194, 0x00000000},
++	{0x0002a198, 0x00000000},
++	{0x0002a19c, 0x00000000},
++	{0x0002a1a0, 0x00000000},
++	{0x0002a1a4, 0x00000000},
++	{0x0002a1a8, 0x00000000},
++	{0x0002a1ac, 0x00000000},
++	{0x0002a1b0, 0x00000000},
++	{0x0002a1b4, 0x00000000},
++	{0x0002a1b8, 0x00000000},
++	{0x0002a1bc, 0x00000000},
++	{0x0002a1c0, 0x00000000},
++	{0x0002a1c4, 0x00000000},
++	{0x0002a1c8, 0x00000000},
++	{0x0002a1cc, 0x00000000},
++	{0x0002a1d0, 0x00000000},
++	{0x0002a1d4, 0x00000000},
++	{0x0002a1d8, 0x00000000},
++	{0x0002a1dc, 0x00000000},
++	{0x0002a1e0, 0x00000000},
++	{0x0002a1e4, 0x00000000},
++	{0x0002a1e8, 0x00000000},
++	{0x0002a1ec, 0x00000000},
++	{0x0002a1f0, 0x00000396},
++	{0x0002a1f4, 0x00000396},
++	{0x0002a1f8, 0x00000396},
++	{0x0002a1fc, 0x00000196},
++	{0x0002b000, 0x00010000},
++	{0x0002b004, 0x00030002},
++	{0x0002b008, 0x00050004},
++	{0x0002b00c, 0x00810080},
++	{0x0002b010, 0x00830082},
++	{0x0002b014, 0x01810180},
++	{0x0002b018, 0x01830182},
++	{0x0002b01c, 0x01850184},
++	{0x0002b020, 0x02810280},
++	{0x0002b024, 0x02830282},
++	{0x0002b028, 0x02850284},
++	{0x0002b02c, 0x02890288},
++	{0x0002b030, 0x028b028a},
++	{0x0002b034, 0x0388028c},
++	{0x0002b038, 0x038a0389},
++	{0x0002b03c, 0x038c038b},
++	{0x0002b040, 0x0390038d},
++	{0x0002b044, 0x03920391},
++	{0x0002b048, 0x03940393},
++	{0x0002b04c, 0x03960395},
++	{0x0002b050, 0x00000000},
++	{0x0002b054, 0x00000000},
++	{0x0002b058, 0x00000000},
++	{0x0002b05c, 0x00000000},
++	{0x0002b060, 0x00000000},
++	{0x0002b064, 0x00000000},
++	{0x0002b068, 0x00000000},
++	{0x0002b06c, 0x00000000},
++	{0x0002b070, 0x00000000},
++	{0x0002b074, 0x00000000},
++	{0x0002b078, 0x00000000},
++	{0x0002b07c, 0x00000000},
++	{0x0002b080, 0x23232323},
++	{0x0002b084, 0x21232323},
++	{0x0002b088, 0x19191c1e},
++	{0x0002b08c, 0x12141417},
++	{0x0002b090, 0x07070e0e},
++	{0x0002b094, 0x03030305},
++	{0x0002b098, 0x00000003},
++	{0x0002b09c, 0x00000000},
++	{0x0002b0a0, 0x00000000},
++	{0x0002b0a4, 0x00000000},
++	{0x0002b0a8, 0x00000000},
++	{0x0002b0ac, 0x00000000},
++	{0x0002b0b0, 0x00000000},
++	{0x0002b0b4, 0x00000000},
++	{0x0002b0b8, 0x00000000},
++	{0x0002b0bc, 0x00000000},
++	{0x0002b0c0, 0x003f0020},
++	{0x0002b0c4, 0x00400041},
++	{0x0002b0c8, 0x0140005f},
++	{0x0002b0cc, 0x0160015f},
++	{0x0002b0d0, 0x017e017f},
++	{0x0002b0d4, 0x02410242},
++	{0x0002b0d8, 0x025f0240},
++	{0x0002b0dc, 0x027f0260},
++	{0x0002b0e0, 0x0341027e},
++	{0x0002b0e4, 0x035f0340},
++	{0x0002b0e8, 0x037f0360},
++	{0x0002b0ec, 0x04400441},
++	{0x0002b0f0, 0x0460045f},
++	{0x0002b0f4, 0x0541047f},
++	{0x0002b0f8, 0x055f0540},
++	{0x0002b0fc, 0x057f0560},
++	{0x0002b100, 0x06400641},
++	{0x0002b104, 0x0660065f},
++	{0x0002b108, 0x067e067f},
++	{0x0002b10c, 0x07410742},
++	{0x0002b110, 0x075f0740},
++	{0x0002b114, 0x077f0760},
++	{0x0002b118, 0x07800781},
++	{0x0002b11c, 0x07a0079f},
++	{0x0002b120, 0x07c107bf},
++	{0x0002b124, 0x000007c0},
++	{0x0002b128, 0x00000000},
++	{0x0002b12c, 0x00000000},
++	{0x0002b130, 0x00000000},
++	{0x0002b134, 0x00000000},
++	{0x0002b138, 0x00000000},
++	{0x0002b13c, 0x00000000},
++	{0x0002b140, 0x003f0020},
++	{0x0002b144, 0x00400041},
++	{0x0002b148, 0x0140005f},
++	{0x0002b14c, 0x0160015f},
++	{0x0002b150, 0x017e017f},
++	{0x0002b154, 0x02410242},
++	{0x0002b158, 0x025f0240},
++	{0x0002b15c, 0x027f0260},
++	{0x0002b160, 0x0341027e},
++	{0x0002b164, 0x035f0340},
++	{0x0002b168, 0x037f0360},
++	{0x0002b16c, 0x04400441},
++	{0x0002b170, 0x0460045f},
++	{0x0002b174, 0x0541047f},
++	{0x0002b178, 0x055f0540},
++	{0x0002b17c, 0x057f0560},
++	{0x0002b180, 0x06400641},
++	{0x0002b184, 0x0660065f},
++	{0x0002b188, 0x067e067f},
++	{0x0002b18c, 0x07410742},
++	{0x0002b190, 0x075f0740},
++	{0x0002b194, 0x077f0760},
++	{0x0002b198, 0x07800781},
++	{0x0002b19c, 0x07a0079f},
++	{0x0002b1a0, 0x07c107bf},
++	{0x0002b1a4, 0x000007c0},
++	{0x0002b1a8, 0x00000000},
++	{0x0002b1ac, 0x00000000},
++	{0x0002b1b0, 0x00000000},
++	{0x0002b1b4, 0x00000000},
++	{0x0002b1b8, 0x00000000},
++	{0x0002b1bc, 0x00000000},
++	{0x0002b1c0, 0x00000000},
++	{0x0002b1c4, 0x00000000},
++	{0x0002b1c8, 0x00000000},
++	{0x0002b1cc, 0x00000000},
++	{0x0002b1d0, 0x00000000},
++	{0x0002b1d4, 0x00000000},
++	{0x0002b1d8, 0x00000000},
++	{0x0002b1dc, 0x00000000},
++	{0x0002b1e0, 0x00000000},
++	{0x0002b1e4, 0x00000000},
++	{0x0002b1e8, 0x00000000},
++	{0x0002b1ec, 0x00000000},
++	{0x0002b1f0, 0x00000396},
++	{0x0002b1f4, 0x00000396},
++	{0x0002b1f8, 0x00000396},
++	{0x0002b1fc, 0x00000196},
++};
++
++static const u32 qcn550x_1p0_xlna_only[][5] = {
++	/* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
++	{0x00029820, 0x206a022e, 0x206a022e, 0x206a01ae, 0x206a022e},
++	{0x00029824, 0x5ac640d0, 0x5ac640d0, 0x5ac621f1, 0x5ac621f1},
++	{0x00029828, 0x06903081, 0x06903081, 0x0712b281, 0x052e6381},
++	{0x00029e00, 0x8372111a, 0x8372111a, 0x8372159d, 0x83721620},
++	{0x00029e0c, 0x6c4000e2, 0x6d4000e2, 0x6d4000de, 0x6c4000da},
++	{0x00029e10, 0x7ec88d2e, 0x7ec88d2e, 0x7ec86d2e, 0x7ec86d2e},
++	{0x00029e14, 0x37b95d5e, 0x37b9605e, 0x317a625d, 0x3175535d},
++	{0x00029e18, 0x00000000, 0x00000000, 0x04008020, 0x04008020},
++	{0x00029e20, 0x000003b5, 0x000003b5, 0x000003b2, 0x000003b2},
++	{0x00029e3c, 0xcfa10822, 0xcfa10822, 0xcf946222, 0xcf946222},
++	{0x00029e40, 0x0cf61820, 0x0cf61820, 0x0cf61820, 0x0cf61820},
++	{0x00029e44, 0xfe292927, 0xfe292927, 0xfe292927, 0xfe292927},
++	{0x00029e48, 0x50302020, 0x50302020, 0x50302020, 0x50302020},
++	{0x00029fc0, 0x813e4788, 0x813e4788, 0x813e4789, 0x813e4789},
++	{0x00029fd4, 0x81e5a89a, 0x81e5a89a, 0x81e5a89a, 0x81e5a89a},
++	{0x0002a3a4, 0x3a3e3e00, 0x3a3e3e00, 0x3a3e3e00, 0x3a3e3e00},
++	{0x0002a424, 0x1ce739cb, 0x1ce739cb, 0x1ce739cb, 0x1ce739cb},
++	{0x0002ae18, 0x00000000, 0x00000000, 0x04008020, 0x04008020},
++	{0x0002ae20, 0x000001b5, 0x000001b5, 0x000001b2, 0x000001b2},
++	{0x0002be18, 0x00000000, 0x00000000, 0x04008020, 0x04008020},
++	{0x0002be20, 0x000001b5, 0x000001b5, 0x000001b2, 0x000001b2},
++	{0x0002de04, 0x001c0000, 0x001c0000, 0x001c0000, 0x001c0000},
++	{0x0002de18, 0x00000000, 0x00000000, 0x04008020, 0x04008020},
++	{0x0002de20, 0x000001b5, 0x000001b5, 0x000001b2, 0x000001b2},
++};
++
++#endif /* INITVALS_550X_H */
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_hw.c b/drivers/net/wireless/ath/ath9k/ar9003_hw.c
+index e9bd13eeee..be0a3d3b71 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_hw.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_hw.c
+@@ -30,6 +30,7 @@
+ #include "ar9565_1p1_initvals.h"
+ #include "ar953x_initvals.h"
+ #include "ar956x_initvals.h"
++#include "ar550x_initvals.h"
+ 
+ /* General hardware code for the AR9003 hadware family */
+ 
+@@ -410,6 +411,40 @@ static void ar9003_hw_init_mode_regs(struct ath_hw *ah)
+ 			       qca956x_1p0_baseband_core_txfir_coeff_japan_2484);
+ 		INIT_INI_ARRAY(&ah->iniModesFastClock,
+ 			       qca956x_1p0_modes_fast_clock);
++	} else if (AR_SREV_5502(ah)) {
++		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
++			       qcn550x_1p0_mac_core);
++		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_POST],
++			       qcn550x_1p0_mac_postamble);
++
++		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_CORE],
++			       qcn550x_1p0_baseband_core);
++		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_POST],
++			       qcn550x_1p0_baseband_postamble);
++
++		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_CORE],
++			       qcn550x_1p0_radio_core);
++		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_POST],
++			       qcn550x_1p0_radio_postamble);
++
++		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_PRE],
++			       qcn550x_1p0_soc_preamble);
++		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_POST],
++			       qcn550x_1p0_soc_postamble);
++
++		INIT_INI_ARRAY(&ah->iniModesRxGain,
++			       qcn550x_1p0_common_wo_xlna_rx_gain_table);
++		INIT_INI_ARRAY(&ah->ini_modes_rx_gain_bounds,
++			       qcn550x_1p0_common_wo_xlna_rx_gain_bounds);
++		INIT_INI_ARRAY(&ah->iniModesTxGain,
++			       qcn550x_1p0_modes_xpa_tx_gain_table);
++
++		INIT_INI_ARRAY(&ah->ini_dfs,
++			       qcn550x_1p0_baseband_postamble_dfs_channel);
++		INIT_INI_ARRAY(&ah->iniCckfirJapan2484,
++			       qcn550x_1p0_baseband_core_txfir_coeff_japan_2484);
++		INIT_INI_ARRAY(&ah->iniModesFastClock,
++			       qcn550x_1p0_modes_fast_clock);
+ 	} else if (AR_SREV_9580(ah)) {
+ 		/* mac */
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
+@@ -617,6 +652,9 @@ static void ar9003_tx_gain_table_mode0(struct ath_hw *ah)
+ 	else if (AR_SREV_9561(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+ 			       qca956x_1p0_modes_xpa_tx_gain_table);
++	else if (AR_SREV_5502(ah))
++		INIT_INI_ARRAY(&ah->iniModesTxGain,
++			       qcn550x_1p0_modes_xpa_tx_gain_table);
+ 	else if (AR_SREV_9580(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+ 			ar9580_1p0_lowest_ob_db_tx_gain_table);
+@@ -670,6 +708,9 @@ static void ar9003_tx_gain_table_mode1(struct ath_hw *ah)
+ 	} else if (AR_SREV_9561(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+ 			       qca956x_1p0_modes_no_xpa_tx_gain_table);
++	else if (AR_SREV_5502(ah))
++		INIT_INI_ARRAY(&ah->iniModesTxGain,
++			       qcn550x_1p0_modes_no_xpa_tx_gain_table);
+ 	else if (AR_SREV_9462_21(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+ 			ar9462_2p1_modes_high_ob_db_tx_gain);
+@@ -710,6 +751,9 @@ static void ar9003_tx_gain_table_mode2(struct ath_hw *ah)
+ 	else if (AR_SREV_9561(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+ 			       qca956x_1p0_modes_no_xpa_low_ob_db_tx_gain_table);
++	else if (AR_SREV_5502(ah))
++		INIT_INI_ARRAY(&ah->iniModesTxGain,
++			       qcn550x_1p0_modes_no_xpa_low_ob_db_tx_gain_table);
+ 	else if (AR_SREV_9565_11(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+ 			       ar9565_1p1_modes_low_ob_db_tx_gain_table);
+@@ -738,6 +782,9 @@ static void ar9003_tx_gain_table_mode3(struct ath_hw *ah)
+ 	else if (AR_SREV_9580(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+ 			ar9580_1p0_high_power_tx_gain_table);
++	else if (AR_SREV_5502(ah))
++		INIT_INI_ARRAY(&ah->iniModesTxGain,
++			       qcn550x_1p0_modes_no_xpa_mcal_tx_gain_table);
+ 	else if (AR_SREV_9565_11(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+ 			       ar9565_1p1_modes_high_power_tx_gain_table);
+@@ -762,6 +809,9 @@ static void ar9003_tx_gain_table_mode4(struct ath_hw *ah)
+ 	else if (AR_SREV_9580(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+ 			ar9580_1p0_mixed_ob_db_tx_gain_table);
++	else if (AR_SREV_5502(ah))
++		INIT_INI_ARRAY(&ah->iniModesTxGain,
++			       qcn550x_1p0_modes_no_xpa_table_5_tx_gain_table);
+ 	else if (AR_SREV_9462_21(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+ 		       ar9462_2p1_modes_mix_ob_db_tx_gain);
+@@ -784,6 +834,9 @@ static void ar9003_tx_gain_table_mode5(struct ath_hw *ah)
+ 	else if (AR_SREV_9561(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+ 			       qca956x_1p0_modes_no_xpa_green_tx_gain_table);
++	else if (AR_SREV_5502(ah))
++		INIT_INI_ARRAY(&ah->iniModesTxGain,
++			       qcn550x_1p0_modes_no_xpa_green_tx_gain_table);
+ 	else if (AR_SREV_9300_22(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+ 			ar9300Modes_type5_tx_gain_table_2p2);
+@@ -862,6 +915,13 @@ static void ar9003_rx_gain_table_mode0(struct ath_hw *ah)
+ 			       qca956x_1p0_common_rx_gain_bounds);
+ 		INIT_INI_ARRAY(&ah->ini_modes_rxgain_xlna,
+ 			       qca956x_1p0_xlna_only);
++	} else if (AR_SREV_5502(ah)) {
++		INIT_INI_ARRAY(&ah->iniModesRxGain,
++			       qcn550x_1p0_common_rx_gain_table);
++		INIT_INI_ARRAY(&ah->ini_modes_rx_gain_bounds,
++			       qcn550x_1p0_common_rx_gain_bounds);
++		INIT_INI_ARRAY(&ah->ini_modes_rxgain_xlna,
++			       qcn550x_1p0_xlna_only);
+ 	} else if (AR_SREV_9580(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+ 				ar9580_1p0_rx_gain_table);
+@@ -922,6 +982,11 @@ static void ar9003_rx_gain_table_mode1(struct ath_hw *ah)
+ 			       qca956x_1p0_common_wo_xlna_rx_gain_table);
+ 		INIT_INI_ARRAY(&ah->ini_modes_rx_gain_bounds,
+ 			       qca956x_1p0_common_wo_xlna_rx_gain_bounds);
++	} else if (AR_SREV_5502(ah)) {
++		INIT_INI_ARRAY(&ah->iniModesRxGain,
++			       qcn550x_1p0_common_wo_xlna_rx_gain_table);
++		INIT_INI_ARRAY(&ah->ini_modes_rx_gain_bounds,
++			       qcn550x_1p0_common_wo_xlna_rx_gain_bounds);
+ 	} else if (AR_SREV_9580(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+ 			ar9580_1p0_wo_xlna_rx_gain_table);
+-- 
+2.34.1
+
diff --git a/package/feeds/base/mac80211/patches/ath9k/008-wifi-ath9k-implement-QCN550x-rx.patch b/package/feeds/base/mac80211/patches/ath9k/008-wifi-ath9k-implement-QCN550x-rx.patch
new file mode 100644
index 0000000000..0d170541d2
--- /dev/null
+++ b/package/feeds/base/mac80211/patches/ath9k/008-wifi-ath9k-implement-QCN550x-rx.patch
@@ -0,0 +1,159 @@
+From 3a9ecda22db047b93ffe53574ca66b26c00a1a19 Mon Sep 17 00:00:00 2001
+From: Wenli Looi <wlooi@ucalgary.ca>
+Date: Mon, 18 Apr 2022 05:15:54 +0000
+Subject: [PATCH v3 08/11] wifi: ath9k: implement QCN550x rx
+
+The rx status for this device has 2 additional status values.
+
+Signed-off-by: Wenli Looi <wlooi@ucalgary.ca>
+---
+ drivers/net/wireless/ath/ath9k/ar9003_mac.c | 47 +++++++++++++--------
+ drivers/net/wireless/ath/ath9k/ar9003_mac.h |  6 +++
+ drivers/net/wireless/ath/ath9k/hw.c         |  4 +-
+ 3 files changed, 38 insertions(+), 19 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_mac.c b/drivers/net/wireless/ath/ath9k/ar9003_mac.c
+index a8bc003077..3d512916a2 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_mac.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_mac.c
+@@ -481,10 +481,21 @@ EXPORT_SYMBOL(ath9k_hw_addrxbuf_edma);
+ int ath9k_hw_process_rxdesc_edma(struct ath_hw *ah, struct ath_rx_status *rxs,
+ 				 void *buf_addr)
+ {
+-	struct ar9003_rxs *rxsp = buf_addr;
++	const struct qcn5502_rxs *qcn5502_rxsp = NULL;
++	const struct ar9003_rxs *rxsp = NULL;
+ 	unsigned int phyerr;
++	u32 last_status;
+ 
+-	if ((rxsp->status11 & AR_RxDone) == 0)
++	if (AR_SREV_5502(ah)) {
++		qcn5502_rxsp = buf_addr;
++		rxsp = &qcn5502_rxsp->ar9003_rxs;
++		last_status = qcn5502_rxsp->status13;
++	} else {
++		rxsp = buf_addr;
++		last_status = rxsp->status11;
++	}
++
++	if ((last_status & AR_RxDone) == 0)
+ 		return -EINPROGRESS;
+ 
+ 	if (MS(rxsp->ds_info, AR_DescId) != 0x168c)
+@@ -510,17 +521,17 @@ int ath9k_hw_process_rxdesc_edma(struct ath_hw *ah, struct ath_rx_status *rxs,
+ 	rxs->rs_rssi_ext[1] = MS(rxsp->status5, AR_RxRSSIAnt11);
+ 	rxs->rs_rssi_ext[2] = MS(rxsp->status5, AR_RxRSSIAnt12);
+ 
+-	if (rxsp->status11 & AR_RxKeyIdxValid)
+-		rxs->rs_keyix = MS(rxsp->status11, AR_KeyIdx);
++	if (last_status & AR_RxKeyIdxValid)
++		rxs->rs_keyix = MS(last_status, AR_KeyIdx);
+ 	else
+ 		rxs->rs_keyix = ATH9K_RXKEYIX_INVALID;
+ 
+ 	rxs->rs_rate = MS(rxsp->status1, AR_RxRate);
+ 	rxs->rs_more = (rxsp->status2 & AR_RxMore) ? 1 : 0;
+ 
+-	rxs->rs_firstaggr = (rxsp->status11 & AR_RxFirstAggr) ? 1 : 0;
+-	rxs->rs_isaggr = (rxsp->status11 & AR_RxAggr) ? 1 : 0;
+-	rxs->rs_moreaggr = (rxsp->status11 & AR_RxMoreAggr) ? 1 : 0;
++	rxs->rs_firstaggr = (last_status & AR_RxFirstAggr) ? 1 : 0;
++	rxs->rs_isaggr = (last_status & AR_RxAggr) ? 1 : 0;
++	rxs->rs_moreaggr = (last_status & AR_RxMoreAggr) ? 1 : 0;
+ 	rxs->rs_antenna = (MS(rxsp->status4, AR_RxAntenna) & 0x7);
+ 	rxs->enc_flags |= (rxsp->status4 & AR_GI) ? RX_ENC_FLAG_SHORT_GI : 0;
+ 	rxs->enc_flags |=
+@@ -533,16 +544,16 @@ int ath9k_hw_process_rxdesc_edma(struct ath_hw *ah, struct ath_rx_status *rxs,
+ 	rxs->evm3 = rxsp->status9;
+ 	rxs->evm4 = (rxsp->status10 & 0xffff);
+ 
+-	if (rxsp->status11 & AR_PreDelimCRCErr)
++	if (last_status & AR_PreDelimCRCErr)
+ 		rxs->rs_flags |= ATH9K_RX_DELIM_CRC_PRE;
+ 
+-	if (rxsp->status11 & AR_PostDelimCRCErr)
++	if (last_status & AR_PostDelimCRCErr)
+ 		rxs->rs_flags |= ATH9K_RX_DELIM_CRC_POST;
+ 
+-	if (rxsp->status11 & AR_DecryptBusyErr)
++	if (last_status & AR_DecryptBusyErr)
+ 		rxs->rs_flags |= ATH9K_RX_DECRYPT_BUSY;
+ 
+-	if ((rxsp->status11 & AR_RxFrameOK) == 0) {
++	if ((last_status & AR_RxFrameOK) == 0) {
+ 		/*
+ 		 * AR_CRCErr will bet set to true if we're on the last
+ 		 * subframe and the AR_PostDelimCRCErr is caught.
+@@ -551,14 +562,14 @@ int ath9k_hw_process_rxdesc_edma(struct ath_hw *ah, struct ath_rx_status *rxs,
+ 		 * possibly be reviewing the last subframe. AR_CRCErr
+ 		 * is the CRC of the actual data.
+ 		 */
+-		if (rxsp->status11 & AR_CRCErr)
++		if (last_status & AR_CRCErr)
+ 			rxs->rs_status |= ATH9K_RXERR_CRC;
+-		else if (rxsp->status11 & AR_DecryptCRCErr)
++		else if (last_status & AR_DecryptCRCErr)
+ 			rxs->rs_status |= ATH9K_RXERR_DECRYPT;
+-		else if (rxsp->status11 & AR_MichaelErr)
++		else if (last_status & AR_MichaelErr)
+ 			rxs->rs_status |= ATH9K_RXERR_MIC;
+-		if (rxsp->status11 & AR_PHYErr) {
+-			phyerr = MS(rxsp->status11, AR_PHYErrCode);
++		if (last_status & AR_PHYErr) {
++			phyerr = MS(last_status, AR_PHYErrCode);
+ 			/*
+ 			 * If we reach a point here where AR_PostDelimCRCErr is
+ 			 * true it implies we're *not* on the last subframe. In
+@@ -573,7 +584,7 @@ int ath9k_hw_process_rxdesc_edma(struct ath_hw *ah, struct ath_rx_status *rxs,
+ 			 * delimiter for an A-MPDU subframe (0x4E = 'N' ASCII).
+ 			 */
+ 			if ((phyerr == ATH9K_PHYERR_OFDM_RESTART) &&
+-			    (rxsp->status11 & AR_PostDelimCRCErr)) {
++			    (last_status & AR_PostDelimCRCErr)) {
+ 				rxs->rs_phyerr = 0;
+ 			} else {
+ 				rxs->rs_status |= ATH9K_RXERR_PHY;
+@@ -582,7 +593,7 @@ int ath9k_hw_process_rxdesc_edma(struct ath_hw *ah, struct ath_rx_status *rxs,
+ 		}
+ 	}
+ 
+-	if (rxsp->status11 & AR_KeyMiss)
++	if (last_status & AR_KeyMiss)
+ 		rxs->rs_status |= ATH9K_RXERR_KEYMISS;
+ 
+ 	return 0;
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_mac.h b/drivers/net/wireless/ath/ath9k/ar9003_mac.h
+index cbf60b090b..ec8f3fac67 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_mac.h
++++ b/drivers/net/wireless/ath/ath9k/ar9003_mac.h
+@@ -67,6 +67,12 @@ struct ar9003_rxs {
+ 	u32 status11;
+ } __packed __aligned(4);
+ 
++struct qcn5502_rxs {
++	struct ar9003_rxs ar9003_rxs;
++	u32 status12;
++	u32 status13;
++} __packed __aligned(4);
++
+ /* Transmit Control Descriptor */
+ struct ar9003_txc {
+ 	u32 info;   /* descriptor information */
+diff --git a/drivers/net/wireless/ath/ath9k/hw.c b/drivers/net/wireless/ath/ath9k/hw.c
+index f572fca3e6..8d1dc77da0 100644
+--- a/drivers/net/wireless/ath/ath9k/hw.c
++++ b/drivers/net/wireless/ath/ath9k/hw.c
+@@ -2622,7 +2622,9 @@ int ath9k_hw_fill_cap_info(struct ath_hw *ah)
+ 
+ 		pCap->rx_hp_qdepth = ATH9K_HW_RX_HP_QDEPTH;
+ 		pCap->rx_lp_qdepth = ATH9K_HW_RX_LP_QDEPTH;
+-		pCap->rx_status_len = sizeof(struct ar9003_rxs);
++		pCap->rx_status_len = AR_SREV_5502(ah) ?
++					      sizeof(struct qcn5502_rxs) :
++					      sizeof(struct ar9003_rxs);
+ 		pCap->tx_desc_len = sizeof(struct ar9003_txc);
+ 		pCap->txs_len = sizeof(struct ar9003_txs);
+ 	} else {
+-- 
+2.34.1
+
diff --git a/package/feeds/base/mac80211/patches/ath9k/009-wifi-ath9k-implement-QCN550x-tx.patch b/package/feeds/base/mac80211/patches/ath9k/009-wifi-ath9k-implement-QCN550x-tx.patch
new file mode 100644
index 0000000000..af2de6f031
--- /dev/null
+++ b/package/feeds/base/mac80211/patches/ath9k/009-wifi-ath9k-implement-QCN550x-tx.patch
@@ -0,0 +1,162 @@
+From 51a9d11bffbc135a9f1d557933845b9144d0d685 Mon Sep 17 00:00:00 2001
+From: Wenli Looi <wlooi@ucalgary.ca>
+Date: Mon, 18 Apr 2022 05:16:53 +0000
+Subject: [PATCH v3 09/11] wifi: ath9k: implement QCN550x tx
+
+Certain fields in ar9003_txc are slightly different, but overall this
+device can be treated similar to other AR9003 devices.
+
+Signed-off-by: Wenli Looi <wlooi@ucalgary.ca>
+---
+ drivers/net/wireless/ath/ath9k/ar9003_mac.c | 45 +++++++++++++++------
+ drivers/net/wireless/ath/ath9k/ar9003_mac.h |  4 ++
+ drivers/net/wireless/ath/ath9k/mac.h        | 13 ++++++
+ 3 files changed, 50 insertions(+), 12 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_mac.c b/drivers/net/wireless/ath/ath9k/ar9003_mac.c
+index 3d512916a2..be80fd9263 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_mac.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_mac.c
+@@ -26,9 +26,9 @@ static void ar9003_hw_rx_enable(struct ath_hw *hw)
+ static void
+ ar9003_set_txdesc(struct ath_hw *ah, void *ds, struct ath_tx_info *i)
+ {
++	u32 val, ctl12, ctl17, ctl18;
+ 	struct ar9003_txc *ads = ds;
+ 	int checksum = 0;
+-	u32 val, ctl12, ctl17;
+ 	u8 desc_len;
+ 
+ 	desc_len = ((AR_SREV_9462(ah) || AR_SREV_9565(ah)) ? 0x18 : 0x17);
+@@ -132,8 +132,21 @@ ar9003_set_txdesc(struct ath_hw *ah, void *ds, struct ath_tx_info *i)
+ 		break;
+ 	}
+ 
++	ctl18 = set11nRateFlags(i->rates, 0) |
++		set11nRateFlags(i->rates, 1) |
++		set11nRateFlags(i->rates, 2) |
++		set11nRateFlags(i->rates, 3) |
++		SM(i->rtscts_rate, AR_RTSCTSRate);
++
+ 	val = (i->flags & ATH9K_TXDESC_PAPRD) >> ATH9K_TXDESC_PAPRD_S;
+-	ctl12 |= SM(val, AR_PAPRDChainMask);
++
++	if (!AR_SREV_5502(ah)) {
++		ctl12 |= SM(val, AR_PAPRDChainMask);
++		ctl18 |= set11nChainSel(i->rates, 0) |
++			 set11nChainSel(i->rates, 1) |
++			 set11nChainSel(i->rates, 2) |
++			 set11nChainSel(i->rates, 3);
++	}
+ 
+ 	WRITE_ONCE(ads->ctl12, ctl12);
+ 	WRITE_ONCE(ads->ctl17, ctl17);
+@@ -144,18 +157,22 @@ ar9003_set_txdesc(struct ath_hw *ah, void *ds, struct ath_tx_info *i)
+ 	WRITE_ONCE(ads->ctl16, set11nPktDurRTSCTS(i->rates, 2)
+ 		| set11nPktDurRTSCTS(i->rates, 3));
+ 
+-	WRITE_ONCE(ads->ctl18,
+-		  set11nRateFlags(i->rates, 0) | set11nChainSel(i->rates, 0)
+-		| set11nRateFlags(i->rates, 1) | set11nChainSel(i->rates, 1)
+-		| set11nRateFlags(i->rates, 2) | set11nChainSel(i->rates, 2)
+-		| set11nRateFlags(i->rates, 3) | set11nChainSel(i->rates, 3)
+-		| SM(i->rtscts_rate, AR_RTSCTSRate));
++	WRITE_ONCE(ads->ctl18, ctl18);
+ 
+ 	WRITE_ONCE(ads->ctl19, AR_Not_Sounding);
+ 
+ 	WRITE_ONCE(ads->ctl20, SM(i->txpower[1], AR_XmitPower1));
+ 	WRITE_ONCE(ads->ctl21, SM(i->txpower[2], AR_XmitPower2));
+ 	WRITE_ONCE(ads->ctl22, SM(i->txpower[3], AR_XmitPower3));
++
++	if (AR_SREV_5502(ah)) {
++		WRITE_ONCE(ads->ctl23,
++			   set11nChainSelQCN5502(i->rates, 0) |
++			   set11nChainSelQCN5502(i->rates, 1) |
++			   set11nChainSelQCN5502(i->rates, 2) |
++			   set11nChainSelQCN5502(i->rates, 3) |
++			   SM(val, QCN5502_PAPRDChainMask));
++	}
+ }
+ 
+ static u16 ar9003_calc_ptr_chksum(struct ar9003_txc *ads)
+@@ -355,8 +372,8 @@ static bool ar9003_hw_get_isr(struct ath_hw *ah, enum ath9k_int *masked,
+ static int ar9003_hw_proc_txdesc(struct ath_hw *ah, void *ds,
+ 				 struct ath_tx_status *ts)
+ {
++	u32 status, tx_ba_status;
+ 	struct ar9003_txs *ads;
+-	u32 status;
+ 
+ 	ads = &ah->ts_ring[ah->ts_tail];
+ 
+@@ -390,13 +407,17 @@ static int ar9003_hw_proc_txdesc(struct ath_hw *ah, void *ds,
+ 	ts->ts_rssi_ctl0 = MS(status, AR_TxRSSIAnt00);
+ 	ts->ts_rssi_ctl1 = MS(status, AR_TxRSSIAnt01);
+ 	ts->ts_rssi_ctl2 = MS(status, AR_TxRSSIAnt02);
+-	if (status & AR_TxBaStatus) {
++	if (!AR_SREV_5502(ah))
++		tx_ba_status = status & AR_TxBaStatus;
++
++	status = READ_ONCE(ads->status3);
++	if (AR_SREV_5502(ah))
++		tx_ba_status = status & QCN5502_TxBaStatus;
++	if (tx_ba_status) {
+ 		ts->ts_flags |= ATH9K_TX_BA;
+ 		ts->ba_low = ads->status5;
+ 		ts->ba_high = ads->status6;
+ 	}
+-
+-	status = READ_ONCE(ads->status3);
+ 	if (status & AR_ExcessiveRetries)
+ 		ts->ts_status |= ATH9K_TXERR_XRETRY;
+ 	if (status & AR_Filtered)
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_mac.h b/drivers/net/wireless/ath/ath9k/ar9003_mac.h
+index ec8f3fac67..11a67822fa 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_mac.h
++++ b/drivers/net/wireless/ath/ath9k/ar9003_mac.h
+@@ -41,6 +41,10 @@
+ #define AR_PAPRDChainMask	0x00000e00
+ #define AR_PAPRDChainMask_S	9
+ 
++/* ctl 23 */
++#define QCN5502_PAPRDChainMask		0x0000f000
++#define QCN5502_PAPRDChainMask_S	16
++
+ #define MAP_ISR_S2_CST          6
+ #define MAP_ISR_S2_GTT          6
+ #define MAP_ISR_S2_TIM          3
+diff --git a/drivers/net/wireless/ath/ath9k/mac.h b/drivers/net/wireless/ath/ath9k/mac.h
+index af44b33814..81e1918ad4 100644
+--- a/drivers/net/wireless/ath/ath9k/mac.h
++++ b/drivers/net/wireless/ath/ath9k/mac.h
+@@ -40,6 +40,9 @@
+ #define set11nChainSel(_series, _index)					\
+ 	(SM((_series)[_index].ChSel, AR_ChainSel##_index))
+ 
++#define set11nChainSelQCN5502(_series, _index)				\
++	(SM((_series)[_index].ChSel, QCN5502_ChainSel_##_index))
++
+ #define CCK_SIFS_TIME        10
+ #define CCK_PREAMBLE_BITS   144
+ #define CCK_PLCP_BITS        48
+@@ -458,6 +461,16 @@ struct ar5416_desc {
+ #define AR_TxBaStatus       0x40000000
+ #define AR_TxStatusRsvd01   0x80000000
+ 
++#define QCN5502_ChainSel_0   0x0000000f
++#define QCN5502_ChainSel_0_S 0
++#define QCN5502_ChainSel_1   0x000000f0
++#define QCN5502_ChainSel_1_S 4
++#define QCN5502_ChainSel_2   0x00000f00
++#define QCN5502_ChainSel_2_S 8
++#define QCN5502_ChainSel_3   0x0000f000
++#define QCN5502_ChainSel_3_S 12
++#define QCN5502_TxBaStatus   0x00200000
++
+ /*
+  * AR_FrmXmitOK - Frame transmission success flag. If set, the frame was
+  * transmitted successfully. If clear, no ACK or BA was received to indicate
+-- 
+2.34.1
+
diff --git a/package/feeds/base/mac80211/patches/ath9k/010-wifi-ath9k-add-abstractions-over-ar9300-eeprom.patch b/package/feeds/base/mac80211/patches/ath9k/010-wifi-ath9k-add-abstractions-over-ar9300-eeprom.patch
new file mode 100644
index 0000000000..31c21e1208
--- /dev/null
+++ b/package/feeds/base/mac80211/patches/ath9k/010-wifi-ath9k-add-abstractions-over-ar9300-eeprom.patch
@@ -0,0 +1,1156 @@
+From a3002f69ee091ef4100289b7621d1a342656dcde Mon Sep 17 00:00:00 2001
+From: Wenli Looi <wlooi@ucalgary.ca>
+Date: Mon, 18 Apr 2022 05:17:13 +0000
+Subject: [PATCH v3 10/11] wifi: ath9k: add abstractions over ar9300 eeprom
+
+This will allow the code to handle both old and new AR9300 eeprom
+formats.
+
+Signed-off-by: Wenli Looi <wlooi@ucalgary.ca>
+---
+ .../net/wireless/ath/ath9k/ar9003_eeprom.c    | 635 +++++++++++-------
+ 1 file changed, 410 insertions(+), 225 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+index 810d75f553..669506884b 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+@@ -2982,6 +2982,16 @@ static int ath9k_hw_ar9300_get_eeprom_rev(struct ath_hw *ah)
+ 	return 0;
+ }
+ 
++static struct ar9300_base_eep_hdr *ar9003_base_header(struct ath_hw *ah)
++{
++	return &ah->eeprom.ar9300_eep.baseEepHeader;
++}
++
++static struct ar9300_BaseExtension_1 *ar9003_base_ext1(struct ath_hw *ah)
++{
++	return &ah->eeprom.ar9300_eep.base_ext1;
++}
++
+ static struct ar9300_modal_eep_header *ar9003_modal_header(struct ath_hw *ah,
+ 							   bool is2ghz)
+ {
+@@ -2993,6 +3003,105 @@ static struct ar9300_modal_eep_header *ar9003_modal_header(struct ath_hw *ah,
+ 		return &eep->modalHeader5G;
+ }
+ 
++static int8_t ar9003_ant_gain(struct ath_hw *ah, bool is2ghz)
++{
++	return ar9003_modal_header(ah, is2ghz)->antennaGain;
++}
++
++static u8 ar9003_cal_freq_pier(struct ath_hw *ah, int idx, bool is2ghz)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	return is2ghz ? eep->calFreqPier2G[idx] : eep->calFreqPier5G[idx];
++}
++
++static struct ar9300_cal_data_per_freq_op_loop *
++ar9003_cal_pier_data(struct ath_hw *ah, int chain, int idx, bool is2ghz)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	return is2ghz ? &eep->calPierData2G[chain][idx] :
++			      &eep->calPierData5G[chain][idx];
++}
++
++static u8 ar9003_cal_target_freqbin(struct ath_hw *ah, int idx, bool is2ghz)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	return is2ghz ? eep->calTarget_freqbin_2G[idx] :
++			      eep->calTarget_freqbin_5G[idx];
++}
++
++static u8 ar9003_cal_target_freqbin_cck(struct ath_hw *ah, int idx)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	return eep->calTarget_freqbin_Cck[idx];
++}
++
++static u8 ar9003_cal_target_freqbin_ht20(struct ath_hw *ah, int idx,
++					 bool is2ghz)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	return is2ghz ? eep->calTarget_freqbin_2GHT20[idx] :
++			      eep->calTarget_freqbin_5GHT20[idx];
++}
++
++static u8 ar9003_cal_target_freqbin_ht40(struct ath_hw *ah, int idx,
++					 bool is2ghz)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	return is2ghz ? eep->calTarget_freqbin_2GHT40[idx] :
++			      eep->calTarget_freqbin_5GHT40[idx];
++}
++
++static u8 ar9003_cal_target_power(struct ath_hw *ah, int idx, int rateIndex,
++				  bool is2ghz)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	return is2ghz ? eep->calTargetPower2G[idx].tPow2x[rateIndex] :
++			      eep->calTargetPower5G[idx].tPow2x[rateIndex];
++}
++
++static u8 ar9003_cal_target_power_cck(struct ath_hw *ah, int idx, int rateIndex)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	return eep->calTargetPowerCck[idx].tPow2x[rateIndex];
++}
++
++static u8 ar9003_cal_target_power_ht20(struct ath_hw *ah, int idx,
++				       int rateIndex, bool is2ghz)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	return is2ghz ? eep->calTargetPower2GHT20[idx].tPow2x[rateIndex] :
++			      eep->calTargetPower5GHT20[idx].tPow2x[rateIndex];
++}
++
++static u8 ar9003_cal_target_power_ht40(struct ath_hw *ah, int idx,
++				       int rateIndex, bool is2ghz)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	return is2ghz ? eep->calTargetPower2GHT40[idx].tPow2x[rateIndex] :
++			      eep->calTargetPower5GHT40[idx].tPow2x[rateIndex];
++}
++
++static u8 ar9003_ctl_freqbin(struct ath_hw *ah, int idx, int edge, bool is2ghz)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	return is2ghz ? eep->ctl_freqbin_2G[idx][edge] :
++			      eep->ctl_freqbin_5G[idx][edge];
++}
++
++static u8 ar9003_ctl_index(struct ath_hw *ah, int idx, bool is2ghz)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	return is2ghz ? eep->ctlIndex_2G[idx] : eep->ctlIndex_5G[idx];
++}
++
++static u8 ar9003_ctl_power_data(struct ath_hw *ah, int idx, int edge,
++				bool is2ghz)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	return is2ghz ? eep->ctlPowerData_2G[idx].ctlEdges[edge] :
++			      eep->ctlPowerData_5G[idx].ctlEdges[edge];
++}
++
+ static u16 ar9003_hw_ant_ctrl_chain_get(struct ath_hw *ah, int chain,
+ 					bool is2ghz)
+ {
+@@ -3010,6 +3119,87 @@ u32 ar9003_hw_ant_ctrl_common_2_get(struct ath_hw *ah, bool is2ghz)
+ 	return le32_to_cpu(ar9003_modal_header(ah, is2ghz)->antCtrlCommon2);
+ }
+ 
++static int8_t ar9003_noise_floor_thres(struct ath_hw *ah, int chain,
++				       bool is2ghz)
++{
++	return ar9003_modal_header(ah, is2ghz)->noiseFloorThreshCh[chain];
++}
++
++static int8_t ar9003_quick_drop(struct ath_hw *ah, bool is2ghz)
++{
++	return ar9003_modal_header(ah, is2ghz)->quick_drop;
++}
++
++static int8_t ar9003_temp_slope(struct ath_hw *ah, bool is2ghz)
++{
++	return ar9003_modal_header(ah, is2ghz)->tempSlope;
++}
++
++static int8_t ar9003_temp_slope_high(struct ath_hw *ah)
++{
++	return ah->eeprom.ar9300_eep.base_ext2.tempSlopeHigh;
++}
++
++static int8_t ar9003_temp_slope_low(struct ath_hw *ah)
++{
++	return ah->eeprom.ar9300_eep.base_ext2.tempSlopeLow;
++}
++
++static u8 ar9003_tx_end_to_xpa_off(struct ath_hw *ah, bool is2ghz)
++{
++	return ar9003_modal_header(ah, is2ghz)->txEndToXpaOff;
++}
++
++static u8 ar9003_tx_frame_to_xpa_on(struct ath_hw *ah, bool is2ghz)
++{
++	return ar9003_modal_header(ah, is2ghz)->txFrameToXpaOn;
++}
++
++static u8 ar9003_xatten1_db_high(struct ath_hw *ah, int chain)
++{
++	return ah->eeprom.ar9300_eep.base_ext2.xatten1DBHigh[chain];
++}
++
++static u8 ar9003_xatten1_db_low(struct ath_hw *ah, int chain)
++{
++	return ah->eeprom.ar9300_eep.base_ext2.xatten1DBLow[chain];
++}
++
++static u8 ar9003_xatten1_db_margin_high(struct ath_hw *ah, int chain)
++{
++	return ah->eeprom.ar9300_eep.base_ext2.xatten1MarginHigh[chain];
++}
++
++static u8 ar9003_xatten1_db_margin_low(struct ath_hw *ah, int chain)
++{
++	return ah->eeprom.ar9300_eep.base_ext2.xatten1MarginLow[chain];
++}
++
++static u8 ar9003_xatten1_db(struct ath_hw *ah, int chain, bool is2ghz)
++{
++	return ar9003_modal_header(ah, is2ghz)->xatten1DB[chain];
++}
++
++static u8 ar9003_xatten1_margin(struct ath_hw *ah, int chain, bool is2ghz)
++{
++	return ar9003_modal_header(ah, is2ghz)->xatten1Margin[chain];
++}
++
++static u8 ar9003_xlna_bias_strength(struct ath_hw *ah, bool is2ghz)
++{
++	return ar9003_modal_header(ah, is2ghz)->xlna_bias_strength;
++}
++
++static u8 ar9003_xpa_bias_lvl(struct ath_hw *ah, bool is2ghz)
++{
++	return ar9003_modal_header(ah, is2ghz)->xpaBiasLvl;
++}
++
++static u8 *ar9003_mac_addr(struct ath_hw *ah)
++{
++	return ah->eeprom.ar9300_eep.macAddr;
++}
++
+ static u16 ar9003_switch_com_spdt_get(struct ath_hw *ah, bool is2ghz)
+ {
+ 	return le16_to_cpu(ar9003_modal_header(ah, is2ghz)->switchcomspdt);
+@@ -3018,16 +3208,17 @@ static u16 ar9003_switch_com_spdt_get(struct ath_hw *ah, bool is2ghz)
+ static u32 ath9k_hw_ar9300_get_eeprom(struct ath_hw *ah,
+ 				      enum eeprom_param param)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	struct ar9300_base_eep_hdr *pBase = &eep->baseEepHeader;
++	struct ar9300_base_eep_hdr *pBase = ar9003_base_header(ah);
++	struct ar9300_BaseExtension_1 *base_ext1 = ar9003_base_ext1(ah);
++	u8 *mac_addr = ar9003_mac_addr(ah);
+ 
+ 	switch (param) {
+ 	case EEP_MAC_LSW:
+-		return get_unaligned_be16(eep->macAddr);
++		return get_unaligned_be16(mac_addr);
+ 	case EEP_MAC_MID:
+-		return get_unaligned_be16(eep->macAddr + 2);
++		return get_unaligned_be16(mac_addr + 2);
+ 	case EEP_MAC_MSW:
+-		return get_unaligned_be16(eep->macAddr + 4);
++		return get_unaligned_be16(mac_addr + 4);
+ 	case EEP_REG_0:
+ 		return le16_to_cpu(pBase->regDmn[0]);
+ 	case EEP_OP_CAP:
+@@ -3048,11 +3239,11 @@ static u32 ath9k_hw_ar9300_get_eeprom(struct ath_hw *ah,
+ 		if (AR_SREV_9565(ah))
+ 			return AR9300_EEP_ANTDIV_CONTROL_DEFAULT_VALUE;
+ 		else
+-			return eep->base_ext1.ant_div_control;
++			return base_ext1->ant_div_control;
+ 	case EEP_ANTENNA_GAIN_5G:
+-		return eep->modalHeader5G.antennaGain;
++		return ar9003_ant_gain(ah, /*is2ghz=*/false);
+ 	case EEP_ANTENNA_GAIN_2G:
+-		return eep->modalHeader2G.antennaGain;
++		return ar9003_ant_gain(ah, /*is2ghz=*/true);
+ 	default:
+ 		return 0;
+ 	}
+@@ -3433,40 +3624,79 @@ static bool ath9k_hw_ar9300_fill_eeprom(struct ath_hw *ah)
+ }
+ 
+ #if defined(CPTCFG_ATH9K_DEBUGFS) || defined(CPTCFG_ATH9K_HTC_DEBUGFS)
+-static u32 ar9003_dump_modal_eeprom(char *buf, u32 len, u32 size,
+-				    struct ar9300_modal_eep_header *modal_hdr)
++
++static int8_t ar9003_adc_desired_size(struct ath_hw *ah, bool is2ghz)
+ {
+-	PR_EEP("Chain0 Ant. Control", le16_to_cpu(modal_hdr->antCtrlChain[0]));
+-	PR_EEP("Chain1 Ant. Control", le16_to_cpu(modal_hdr->antCtrlChain[1]));
+-	PR_EEP("Chain2 Ant. Control", le16_to_cpu(modal_hdr->antCtrlChain[2]));
+-	PR_EEP("Ant. Common Control", le32_to_cpu(modal_hdr->antCtrlCommon));
+-	PR_EEP("Ant. Common Control2", le32_to_cpu(modal_hdr->antCtrlCommon2));
+-	PR_EEP("Ant. Gain", modal_hdr->antennaGain);
+-	PR_EEP("Switch Settle", modal_hdr->switchSettling);
+-	PR_EEP("Chain0 xatten1DB", modal_hdr->xatten1DB[0]);
+-	PR_EEP("Chain1 xatten1DB", modal_hdr->xatten1DB[1]);
+-	PR_EEP("Chain2 xatten1DB", modal_hdr->xatten1DB[2]);
+-	PR_EEP("Chain0 xatten1Margin", modal_hdr->xatten1Margin[0]);
+-	PR_EEP("Chain1 xatten1Margin", modal_hdr->xatten1Margin[1]);
+-	PR_EEP("Chain2 xatten1Margin", modal_hdr->xatten1Margin[2]);
+-	PR_EEP("Temp Slope", modal_hdr->tempSlope);
+-	PR_EEP("Volt Slope", modal_hdr->voltSlope);
+-	PR_EEP("spur Channels0", modal_hdr->spurChans[0]);
+-	PR_EEP("spur Channels1", modal_hdr->spurChans[1]);
+-	PR_EEP("spur Channels2", modal_hdr->spurChans[2]);
+-	PR_EEP("spur Channels3", modal_hdr->spurChans[3]);
+-	PR_EEP("spur Channels4", modal_hdr->spurChans[4]);
+-	PR_EEP("Chain0 NF Threshold", modal_hdr->noiseFloorThreshCh[0]);
+-	PR_EEP("Chain1 NF Threshold", modal_hdr->noiseFloorThreshCh[1]);
+-	PR_EEP("Chain2 NF Threshold", modal_hdr->noiseFloorThreshCh[2]);
+-	PR_EEP("Quick Drop", modal_hdr->quick_drop);
+-	PR_EEP("txEndToXpaOff", modal_hdr->txEndToXpaOff);
+-	PR_EEP("xPA Bias Level", modal_hdr->xpaBiasLvl);
+-	PR_EEP("txFrameToDataStart", modal_hdr->txFrameToDataStart);
+-	PR_EEP("txFrameToPaOn", modal_hdr->txFrameToPaOn);
+-	PR_EEP("txFrameToXpaOn", modal_hdr->txFrameToXpaOn);
+-	PR_EEP("txClip", modal_hdr->txClip);
+-	PR_EEP("ADC Desired size", modal_hdr->adcDesiredSize);
++	return ar9003_modal_header(ah, is2ghz)->adcDesiredSize;
++}
++
++static u8 ar9003_switch_settling(struct ath_hw *ah, bool is2ghz)
++{
++	return ar9003_modal_header(ah, is2ghz)->switchSettling;
++}
++
++static u8 ar9003_tx_clip(struct ath_hw *ah, bool is2ghz)
++{
++	return ar9003_modal_header(ah, is2ghz)->txClip;
++}
++
++static u8 ar9003_tx_frame_to_data_start(struct ath_hw *ah, bool is2ghz)
++{
++	return ar9003_modal_header(ah, is2ghz)->txFrameToDataStart;
++}
++
++static u8 ar9003_tx_frame_to_pa_on(struct ath_hw *ah, bool is2ghz)
++{
++	return ar9003_modal_header(ah, is2ghz)->txFrameToPaOn;
++}
++
++static int8_t ar9003_volt_slope(struct ath_hw *ah, bool is2ghz)
++{
++	return ar9003_modal_header(ah, is2ghz)->voltSlope;
++}
++
++static u32 ar9003_dump_modal_eeprom(struct ath_hw *ah, char *buf, u32 len,
++				    u32 size, bool is_2g)
++{
++	PR_EEP("Chain0 Ant. Control",
++	       ar9003_hw_ant_ctrl_chain_get(ah, 0, is_2g));
++	PR_EEP("Chain1 Ant. Control",
++	       ar9003_hw_ant_ctrl_chain_get(ah, 1, is_2g));
++	PR_EEP("Chain2 Ant. Control",
++	       ar9003_hw_ant_ctrl_chain_get(ah, 2, is_2g));
++	PR_EEP("Ant. Common Control", ar9003_hw_ant_ctrl_common_get(ah, is_2g));
++	PR_EEP("Ant. Common Control2",
++	       ar9003_hw_ant_ctrl_common_2_get(ah, is_2g));
++	PR_EEP("Ant. Gain", ar9003_ant_gain(ah, is_2g));
++	PR_EEP("Switch Settle", ar9003_switch_settling(ah, is_2g));
++	PR_EEP("Chain0 xatten1DB", ar9003_xatten1_db(ah, 0, is_2g));
++	PR_EEP("Chain1 xatten1DB", ar9003_xatten1_db(ah, 1, is_2g));
++	PR_EEP("Chain2 xatten1DB", ar9003_xatten1_db(ah, 2, is_2g));
++	PR_EEP("Chain0 xatten1Margin", ar9003_xatten1_margin(ah, 0, is_2g));
++	PR_EEP("Chain1 xatten1Margin", ar9003_xatten1_margin(ah, 1, is_2g));
++	PR_EEP("Chain2 xatten1Margin", ar9003_xatten1_margin(ah, 2, is_2g));
++	PR_EEP("Temp Slope", ar9003_temp_slope(ah, is_2g));
++	PR_EEP("Volt Slope", ar9003_volt_slope(ah, is_2g));
++	PR_EEP("spur Channels0", ar9003_get_spur_chan_ptr(ah, is_2g)[0]);
++	PR_EEP("spur Channels1", ar9003_get_spur_chan_ptr(ah, is_2g)[1]);
++	PR_EEP("spur Channels2", ar9003_get_spur_chan_ptr(ah, is_2g)[2]);
++	PR_EEP("spur Channels3", ar9003_get_spur_chan_ptr(ah, is_2g)[3]);
++	PR_EEP("spur Channels4", ar9003_get_spur_chan_ptr(ah, is_2g)[4]);
++	PR_EEP("Chain0 NF Threshold",
++	       ar9003_noise_floor_thres(ah, 0, is_2g));
++	PR_EEP("Chain1 NF Threshold",
++	       ar9003_noise_floor_thres(ah, 1, is_2g));
++	PR_EEP("Chain2 NF Threshold",
++	       ar9003_noise_floor_thres(ah, 2, is_2g));
++	PR_EEP("Quick Drop", ar9003_quick_drop(ah, is_2g));
++	PR_EEP("txEndToXpaOff", ar9003_tx_end_to_xpa_off(ah, is_2g));
++	PR_EEP("xPA Bias Level", ar9003_xpa_bias_lvl(ah, is_2g));
++	PR_EEP("txFrameToDataStart",
++	       ar9003_tx_frame_to_data_start(ah, is_2g));
++	PR_EEP("txFrameToPaOn", ar9003_tx_frame_to_pa_on(ah, is_2g));
++	PR_EEP("txFrameToXpaOn", ar9003_tx_frame_to_xpa_on(ah, is_2g));
++	PR_EEP("txClip", ar9003_tx_clip(ah, is_2g));
++	PR_EEP("ADC Desired size", ar9003_adc_desired_size(ah, is_2g));
+ 
+ 	return len;
+ }
+@@ -3474,15 +3704,12 @@ static u32 ar9003_dump_modal_eeprom(char *buf, u32 len, u32 size,
+ static u32 ar9003_dump_cal_data(struct ath_hw *ah, char *buf, u32 len, u32 size,
+ 				bool is_2g)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	struct ar9300_base_eep_hdr *pBase;
++	struct ar9300_base_eep_hdr *pBase = ar9003_base_header(ah);
+ 	struct ar9300_cal_data_per_freq_op_loop *cal_pier;
+ 	int cal_pier_nr;
+ 	int freq;
+ 	int i, j;
+ 
+-	pBase = &eep->baseEepHeader;
+-
+ 	if (is_2g)
+ 		cal_pier_nr = AR9300_NUM_2G_CAL_PIERS;
+ 	else
+@@ -3498,12 +3725,11 @@ static u32 ar9003_dump_cal_data(struct ath_hw *ah, char *buf, u32 len, u32 size,
+ 			"Freq\t ref\tvolt\ttemp\tnf_cal\tnf_pow\trx_temp\n");
+ 
+ 		for (j = 0; j < cal_pier_nr; j++) {
++			cal_pier = ar9003_cal_pier_data(ah, i, j, is_2g);
+ 			if (is_2g) {
+-				cal_pier = &eep->calPierData2G[i][j];
+-				freq = 2300 + eep->calFreqPier2G[j];
++				freq = 2300 + ar9003_cal_freq_pier(ah, j, is_2g);
+ 			} else {
+-				cal_pier = &eep->calPierData5G[i][j];
+-				freq = 4800 + eep->calFreqPier5G[j] * 5;
++				freq = 4800 + ar9003_cal_freq_pier(ah, j, is_2g) * 5;
+ 			}
+ 
+ 			len += scnprintf(buf + len, size - len,
+@@ -3528,22 +3754,19 @@ static u32 ar9003_dump_cal_data(struct ath_hw *ah, char *buf, u32 len, u32 size,
+ static u32 ath9k_hw_ar9003_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,
+ 				       u8 *buf, u32 len, u32 size)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	struct ar9300_base_eep_hdr *pBase;
++	struct ar9300_base_eep_hdr *pBase = ar9003_base_header(ah);
+ 
+ 	if (!dump_base_hdr) {
+ 		len += scnprintf(buf + len, size - len,
+ 				 "%20s :\n", "2GHz modal Header");
+-		len = ar9003_dump_modal_eeprom(buf, len, size,
+-						&eep->modalHeader2G);
++		len = ar9003_dump_modal_eeprom(ah, buf, len, size, true);
+ 
+ 		len += scnprintf(buf + len, size - len, "Calibration data\n");
+ 		len = ar9003_dump_cal_data(ah, buf, len, size, true);
+ 
+ 		len += scnprintf(buf + len, size - len,
+ 				 "%20s :\n", "5GHz modal Header");
+-		len = ar9003_dump_modal_eeprom(buf, len, size,
+-						&eep->modalHeader5G);
++		len = ar9003_dump_modal_eeprom(ah, buf, len, size, false);
+ 
+ 		len += scnprintf(buf + len, size - len, "Calibration data\n");
+ 		len = ar9003_dump_cal_data(ah, buf, len, size, false);
+@@ -3551,9 +3774,7 @@ static u32 ath9k_hw_ar9003_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,
+ 		goto out;
+ 	}
+ 
+-	pBase = &eep->baseEepHeader;
+-
+-	PR_EEP("EEPROM Version", ah->eeprom.ar9300_eep.eepromVersion);
++	PR_EEP("EEPROM Version", ath9k_hw_ar9300_get_eeprom_ver(ah));
+ 	PR_EEP("RegDomain1", le16_to_cpu(pBase->regDmn[0]));
+ 	PR_EEP("RegDomain2", le16_to_cpu(pBase->regDmn[1]));
+ 	PR_EEP("TX Mask", (pBase->txrxMask >> 4));
+@@ -3597,7 +3818,7 @@ static u32 ath9k_hw_ar9003_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,
+ 	PR_EEP("SW Reg", le32_to_cpu(pBase->swreg));
+ 
+ 	len += scnprintf(buf + len, size - len, "%20s : %pM\n", "MacAddress",
+-			 ah->eeprom.ar9300_eep.macAddr);
++			 ar9003_mac_addr(ah));
+ out:
+ 	if (len > size)
+ 		len = size;
+@@ -3614,7 +3835,7 @@ static u32 ath9k_hw_ar9003_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,
+ 
+ static void ar9003_hw_xpa_bias_level_apply(struct ath_hw *ah, bool is2ghz)
+ {
+-	int bias = ar9003_modal_header(ah, is2ghz)->xpaBiasLvl;
++	int bias = ar9003_xpa_bias_lvl(ah, is2ghz);
+ 
+ 	if (AR_SREV_9485(ah) || AR_SREV_9330(ah) || AR_SREV_9340(ah) ||
+ 	    AR_SREV_9531(ah) || AR_SREV_9561(ah))
+@@ -3787,8 +4008,7 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
+ 
+ static void ar9003_hw_drive_strength_apply(struct ath_hw *ah)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	struct ar9300_base_eep_hdr *pBase = &eep->baseEepHeader;
++	struct ar9300_base_eep_hdr *pBase = ar9003_base_header(ah);
+ 	int drive_strength;
+ 	unsigned long reg;
+ 
+@@ -3832,23 +4052,23 @@ static u16 ar9003_hw_atten_chain_get(struct ath_hw *ah, int chain,
+ {
+ 	int f[3], t[3];
+ 	u16 value;
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	bool is2ghz = IS_CHAN_2GHZ(chan);
+ 
+ 	if (chain >= 0 && chain < 3) {
+-		if (IS_CHAN_2GHZ(chan))
+-			return eep->modalHeader2G.xatten1DB[chain];
+-		else if (eep->base_ext2.xatten1DBLow[chain] != 0) {
+-			t[0] = eep->base_ext2.xatten1DBLow[chain];
++		if (is2ghz)
++			return ar9003_xatten1_db(ah, chain, is2ghz);
++		else if (ar9003_xatten1_db_low(ah, chain) != 0) {
++			t[0] = ar9003_xatten1_db_low(ah, chain);
+ 			f[0] = 5180;
+-			t[1] = eep->modalHeader5G.xatten1DB[chain];
++			t[1] = ar9003_xatten1_db(ah, chain, is2ghz);
+ 			f[1] = 5500;
+-			t[2] = eep->base_ext2.xatten1DBHigh[chain];
++			t[2] = ar9003_xatten1_db_high(ah, chain);
+ 			f[2] = 5785;
+ 			value = ar9003_hw_power_interpolate((s32) chan->channel,
+ 							    f, t, 3);
+ 			return value;
+ 		} else
+-			return eep->modalHeader5G.xatten1DB[chain];
++			return ar9003_xatten1_db(ah, chain, is2ghz);
+ 	}
+ 
+ 	return 0;
+@@ -3860,23 +4080,23 @@ static u16 ar9003_hw_atten_chain_get_margin(struct ath_hw *ah, int chain,
+ {
+ 	int f[3], t[3];
+ 	u16 value;
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	bool is2ghz = IS_CHAN_2GHZ(chan);
+ 
+ 	if (chain >= 0 && chain < 3) {
+-		if (IS_CHAN_2GHZ(chan))
+-			return eep->modalHeader2G.xatten1Margin[chain];
+-		else if (eep->base_ext2.xatten1MarginLow[chain] != 0) {
+-			t[0] = eep->base_ext2.xatten1MarginLow[chain];
++		if (is2ghz)
++			return ar9003_xatten1_margin(ah, chain, is2ghz);
++		else if (ar9003_xatten1_db_margin_low(ah, chain) != 0) {
++			t[0] = ar9003_xatten1_db_margin_low(ah, chain);
+ 			f[0] = 5180;
+-			t[1] = eep->modalHeader5G.xatten1Margin[chain];
++			t[1] = ar9003_xatten1_margin(ah, chain, is2ghz);
+ 			f[1] = 5500;
+-			t[2] = eep->base_ext2.xatten1MarginHigh[chain];
++			t[2] = ar9003_xatten1_db_margin_high(ah, chain);
+ 			f[2] = 5785;
+ 			value = ar9003_hw_power_interpolate((s32) chan->channel,
+ 							    f, t, 3);
+ 			return value;
+ 		} else
+-			return eep->modalHeader5G.xatten1Margin[chain];
++			return ar9003_xatten1_margin(ah, chain, is2ghz);
+ 	}
+ 
+ 	return 0;
+@@ -3944,8 +4164,7 @@ static bool is_pmu_set(struct ath_hw *ah, u32 pmu_reg, int pmu_set)
+ 
+ void ar9003_hw_internal_regulator_apply(struct ath_hw *ah)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	struct ar9300_base_eep_hdr *pBase = &eep->baseEepHeader;
++	struct ar9300_base_eep_hdr *pBase = ar9003_base_header(ah);
+ 	u32 reg_val;
+ 
+ 	if (pBase->featureEnable & BIT(4)) {
+@@ -4039,16 +4258,16 @@ void ar9003_hw_internal_regulator_apply(struct ath_hw *ah)
+ 
+ static void ar9003_hw_apply_tuning_caps(struct ath_hw *ah)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	struct ar9300_base_eep_hdr *pBase = ar9003_base_header(ah);
+ 	u8 param_0, param_1;
+ 
+ 	if (AR_SREV_9340(ah) || AR_SREV_9531(ah))
+ 		return;
+ 
+-	if (eep->baseEepHeader.featureEnable & 0x40) {
+-		param_0 = eep->baseEepHeader.params_for_tuning_caps[0];
++	if (pBase->featureEnable & 0x40) {
++		param_0 = pBase->params_for_tuning_caps[0];
+ 		if (AR_SREV_5502(ah)) {
+-			param_1 = eep->baseEepHeader.params_for_tuning_caps[1];
++			param_1 = pBase->params_for_tuning_caps[1];
+ 		} else {
+ 			param_0 &= 0x7f;
+ 			param_1 = param_0;
+@@ -4062,21 +4281,22 @@ static void ar9003_hw_apply_tuning_caps(struct ath_hw *ah)
+ 
+ static void ar9003_hw_quick_drop_apply(struct ath_hw *ah, u16 freq)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	struct ar9300_base_eep_hdr *pBase = &eep->baseEepHeader;
++	struct ar9300_base_eep_hdr *pBase = ar9003_base_header(ah);
++	struct ar9300_BaseExtension_1 *base_ext1 = ar9003_base_ext1(ah);
+ 	int quick_drop;
+ 	s32 t[3], f[3] = {5180, 5500, 5785};
++	bool is2ghz = freq < 4000;
+ 
+ 	if (!(pBase->miscConfiguration & BIT(4)))
+ 		return;
+ 
+ 	if (AR_SREV_9300(ah) || AR_SREV_9580(ah) || AR_SREV_9340(ah)) {
+-		if (freq < 4000) {
+-			quick_drop = eep->modalHeader2G.quick_drop;
++		if (is2ghz) {
++			quick_drop = ar9003_quick_drop(ah, is2ghz);
+ 		} else {
+-			t[0] = eep->base_ext1.quick_drop_low;
+-			t[1] = eep->modalHeader5G.quick_drop;
+-			t[2] = eep->base_ext1.quick_drop_high;
++			t[0] = base_ext1->quick_drop_low;
++			t[1] = ar9003_quick_drop(ah, is2ghz);
++			t[2] = base_ext1->quick_drop_high;
+ 			quick_drop = ar9003_hw_power_interpolate(freq, f, t, 3);
+ 		}
+ 		REG_RMW_FIELD(ah, AR_PHY_AGC(ah), AR_PHY_AGC_QUICK_DROP, quick_drop);
+@@ -4087,7 +4307,7 @@ static void ar9003_hw_txend_to_xpa_off_apply(struct ath_hw *ah, bool is2ghz)
+ {
+ 	u32 value;
+ 
+-	value = ar9003_modal_header(ah, is2ghz)->txEndToXpaOff;
++	value = ar9003_tx_end_to_xpa_off(ah, is2ghz);
+ 
+ 	REG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL(ah),
+ 		      AR_PHY_XPA_TIMING_CTL_TX_END_XPAB_OFF, value);
+@@ -4097,10 +4317,10 @@ static void ar9003_hw_txend_to_xpa_off_apply(struct ath_hw *ah, bool is2ghz)
+ 
+ static void ar9003_hw_xpa_timing_control_apply(struct ath_hw *ah, bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	struct ar9300_base_eep_hdr *pBase = ar9003_base_header(ah);
+ 	u8 xpa_ctl;
+ 
+-	if (!(eep->baseEepHeader.featureEnable & 0x80))
++	if (!(pBase->featureEnable & 0x80))
+ 		return;
+ 
+ 	if (!AR_SREV_9300(ah) &&
+@@ -4111,7 +4331,7 @@ static void ar9003_hw_xpa_timing_control_apply(struct ath_hw *ah, bool is2ghz)
+ 	    !AR_SREV_5502(ah))
+ 		return;
+ 
+-	xpa_ctl = ar9003_modal_header(ah, is2ghz)->txFrameToXpaOn;
++	xpa_ctl = ar9003_tx_frame_to_xpa_on(ah, is2ghz);
+ 	if (is2ghz)
+ 		REG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL(ah),
+ 			      AR_PHY_XPA_TIMING_CTL_FRAME_XPAB_ON, xpa_ctl);
+@@ -4122,16 +4342,16 @@ static void ar9003_hw_xpa_timing_control_apply(struct ath_hw *ah, bool is2ghz)
+ 
+ static void ar9003_hw_xlna_bias_strength_apply(struct ath_hw *ah, bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	struct ar9300_base_eep_hdr *pBase = ar9003_base_header(ah);
+ 	u8 bias;
+ 
+-	if (!(eep->baseEepHeader.miscConfiguration & 0x40))
++	if (!(pBase->miscConfiguration & 0x40))
+ 		return;
+ 
+ 	if (!AR_SREV_9300(ah))
+ 		return;
+ 
+-	bias = ar9003_modal_header(ah, is2ghz)->xlna_bias_strength;
++	bias = ar9003_xlna_bias_strength(ah, is2ghz);
+ 	REG_RMW_FIELD(ah, AR_PHY_65NM_CH0_RXTX4, AR_PHY_65NM_RXTX4_XLNA_BIAS,
+ 		      bias & 0x3);
+ 	bias >>= 2;
+@@ -4144,8 +4364,7 @@ static void ar9003_hw_xlna_bias_strength_apply(struct ath_hw *ah, bool is2ghz)
+ 
+ static int ar9003_hw_get_thermometer(struct ath_hw *ah)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	struct ar9300_base_eep_hdr *pBase = &eep->baseEepHeader;
++	struct ar9300_base_eep_hdr *pBase = ar9003_base_header(ah);
+ 	int thermometer =  (pBase->miscConfiguration >> 1) & 0x3;
+ 
+ 	return --thermometer;
+@@ -4203,7 +4422,7 @@ static void ar9003_hw_thermo_cal_apply(struct ath_hw *ah)
+ static void ar9003_hw_apply_minccapwr_thresh(struct ath_hw *ah,
+ 					     bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	struct ar9300_BaseExtension_1 *base_ext1 = ar9003_base_ext1(ah);
+ 	const u_int32_t cca_ctrl[AR9300_MAX_CHAINS] = {
+ 		AR_PHY_CCA_CTRL_0(ah),
+ 		AR_PHY_CCA_CTRL_1(ah),
+@@ -4213,10 +4432,10 @@ static void ar9003_hw_apply_minccapwr_thresh(struct ath_hw *ah,
+ 	u32 val;
+ 
+ 	if (is2ghz) {
+-		if (!(eep->base_ext1.misc_enable & BIT(2)))
++		if (!(base_ext1->misc_enable & BIT(2)))
+ 			return;
+ 	} else {
+-		if (!(eep->base_ext1.misc_enable & BIT(3)))
++		if (!(base_ext1->misc_enable & BIT(3)))
+ 			return;
+ 	}
+ 
+@@ -4224,7 +4443,7 @@ static void ar9003_hw_apply_minccapwr_thresh(struct ath_hw *ah,
+ 		if (!(ah->caps.tx_chainmask & BIT(chain)))
+ 			continue;
+ 
+-		val = ar9003_modal_header(ah, is2ghz)->noiseFloorThreshCh[chain];
++		val = ar9003_noise_floor_thres(ah, chain, is2ghz);
+ 		REG_RMW_FIELD(ah, cca_ctrl[chain],
+ 			      AR_PHY_EXT_CCA0_THRESH62_1, val);
+ 	}
+@@ -4325,18 +4544,11 @@ static u8 ar9003_hw_eeprom_get_tgt_pwr(struct ath_hw *ah,
+ 	u16 numPiers, i;
+ 	s32 targetPowerArray[AR9300_NUM_5G_20_TARGET_POWERS];
+ 	s32 freqArray[AR9300_NUM_5G_20_TARGET_POWERS];
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	struct cal_tgt_pow_legacy *pEepromTargetPwr;
+-	u8 *pFreqBin;
+ 
+ 	if (is2GHz) {
+ 		numPiers = AR9300_NUM_2G_20_TARGET_POWERS;
+-		pEepromTargetPwr = eep->calTargetPower2G;
+-		pFreqBin = eep->calTarget_freqbin_2G;
+ 	} else {
+ 		numPiers = AR9300_NUM_5G_20_TARGET_POWERS;
+-		pEepromTargetPwr = eep->calTargetPower5G;
+-		pFreqBin = eep->calTarget_freqbin_5G;
+ 	}
+ 
+ 	/*
+@@ -4344,8 +4556,10 @@ static u8 ar9003_hw_eeprom_get_tgt_pwr(struct ath_hw *ah,
+ 	 * targetpower piers stored on eeprom
+ 	 */
+ 	for (i = 0; i < numPiers; i++) {
+-		freqArray[i] = ath9k_hw_fbin2freq(pFreqBin[i], is2GHz);
+-		targetPowerArray[i] = pEepromTargetPwr[i].tPow2x[rateIndex];
++		freqArray[i] = ath9k_hw_fbin2freq(
++			ar9003_cal_target_freqbin(ah, i, is2GHz), is2GHz);
++		targetPowerArray[i] =
++			ar9003_cal_target_power(ah, i, rateIndex, is2GHz);
+ 	}
+ 
+ 	/* interpolate to get target power for given frequency */
+@@ -4361,18 +4575,11 @@ static u8 ar9003_hw_eeprom_get_ht20_tgt_pwr(struct ath_hw *ah,
+ 	u16 numPiers, i;
+ 	s32 targetPowerArray[AR9300_NUM_5G_20_TARGET_POWERS];
+ 	s32 freqArray[AR9300_NUM_5G_20_TARGET_POWERS];
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	struct cal_tgt_pow_ht *pEepromTargetPwr;
+-	u8 *pFreqBin;
+ 
+ 	if (is2GHz) {
+ 		numPiers = AR9300_NUM_2G_20_TARGET_POWERS;
+-		pEepromTargetPwr = eep->calTargetPower2GHT20;
+-		pFreqBin = eep->calTarget_freqbin_2GHT20;
+ 	} else {
+ 		numPiers = AR9300_NUM_5G_20_TARGET_POWERS;
+-		pEepromTargetPwr = eep->calTargetPower5GHT20;
+-		pFreqBin = eep->calTarget_freqbin_5GHT20;
+ 	}
+ 
+ 	/*
+@@ -4380,8 +4587,11 @@ static u8 ar9003_hw_eeprom_get_ht20_tgt_pwr(struct ath_hw *ah,
+ 	 * from targetpower piers stored on eeprom
+ 	 */
+ 	for (i = 0; i < numPiers; i++) {
+-		freqArray[i] = ath9k_hw_fbin2freq(pFreqBin[i], is2GHz);
+-		targetPowerArray[i] = pEepromTargetPwr[i].tPow2x[rateIndex];
++		freqArray[i] = ath9k_hw_fbin2freq(
++			ar9003_cal_target_freqbin_ht20(ah, i, is2GHz),
++			is2GHz);
++		targetPowerArray[i] = ar9003_cal_target_power_ht20(
++			ah, i, rateIndex, is2GHz);
+ 	}
+ 
+ 	/* interpolate to get target power for given frequency */
+@@ -4397,18 +4607,11 @@ static u8 ar9003_hw_eeprom_get_ht40_tgt_pwr(struct ath_hw *ah,
+ 	u16 numPiers, i;
+ 	s32 targetPowerArray[AR9300_NUM_5G_40_TARGET_POWERS];
+ 	s32 freqArray[AR9300_NUM_5G_40_TARGET_POWERS];
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	struct cal_tgt_pow_ht *pEepromTargetPwr;
+-	u8 *pFreqBin;
+ 
+ 	if (is2GHz) {
+ 		numPiers = AR9300_NUM_2G_40_TARGET_POWERS;
+-		pEepromTargetPwr = eep->calTargetPower2GHT40;
+-		pFreqBin = eep->calTarget_freqbin_2GHT40;
+ 	} else {
+ 		numPiers = AR9300_NUM_5G_40_TARGET_POWERS;
+-		pEepromTargetPwr = eep->calTargetPower5GHT40;
+-		pFreqBin = eep->calTarget_freqbin_5GHT40;
+ 	}
+ 
+ 	/*
+@@ -4416,8 +4619,11 @@ static u8 ar9003_hw_eeprom_get_ht40_tgt_pwr(struct ath_hw *ah,
+ 	 * targetpower piers stored on eeprom
+ 	 */
+ 	for (i = 0; i < numPiers; i++) {
+-		freqArray[i] = ath9k_hw_fbin2freq(pFreqBin[i], is2GHz);
+-		targetPowerArray[i] = pEepromTargetPwr[i].tPow2x[rateIndex];
++		freqArray[i] = ath9k_hw_fbin2freq(
++			ar9003_cal_target_freqbin_ht40(ah, i, is2GHz),
++			is2GHz);
++		targetPowerArray[i] = ar9003_cal_target_power_ht40(
++			ah, i, rateIndex, is2GHz);
+ 	}
+ 
+ 	/* interpolate to get target power for given frequency */
+@@ -4432,17 +4638,16 @@ static u8 ar9003_hw_eeprom_get_cck_tgt_pwr(struct ath_hw *ah,
+ 	u16 numPiers = AR9300_NUM_2G_CCK_TARGET_POWERS, i;
+ 	s32 targetPowerArray[AR9300_NUM_2G_CCK_TARGET_POWERS];
+ 	s32 freqArray[AR9300_NUM_2G_CCK_TARGET_POWERS];
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	struct cal_tgt_pow_legacy *pEepromTargetPwr = eep->calTargetPowerCck;
+-	u8 *pFreqBin = eep->calTarget_freqbin_Cck;
+ 
+ 	/*
+ 	 * create array of channels and targetpower from
+ 	 * targetpower piers stored on eeprom
+ 	 */
+ 	for (i = 0; i < numPiers; i++) {
+-		freqArray[i] = ath9k_hw_fbin2freq(pFreqBin[i], 1);
+-		targetPowerArray[i] = pEepromTargetPwr[i].tPow2x[rateIndex];
++		freqArray[i] = ath9k_hw_fbin2freq(
++			ar9003_cal_target_freqbin_cck(ah, i), 1);
++		targetPowerArray[i] =
++			ar9003_cal_target_power_cck(ah, i, rateIndex);
+ 	}
+ 
+ 	/* interpolate to get target power for given frequency */
+@@ -4754,9 +4959,8 @@ static int ar9003_hw_cal_pier_get(struct ath_hw *ah,
+ 				  int *ptemperature, int *pvoltage,
+ 				  int *pnf_cal, int *pnf_power)
+ {
+-	u8 *pCalPier;
++	u8 calPier;
+ 	struct ar9300_cal_data_per_freq_op_loop *pCalPierStruct;
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+ 	struct ath_common *common = ath9k_hw_common(ah);
+ 
+ 	if (ichain >= AR9300_MAX_CHAINS) {
+@@ -4773,9 +4977,8 @@ static int ar9003_hw_cal_pier_get(struct ath_hw *ah,
+ 				AR9300_NUM_2G_CAL_PIERS);
+ 			return -1;
+ 		}
+-
+-		pCalPier = &(eep->calFreqPier2G[ipier]);
+-		pCalPierStruct = &(eep->calPierData2G[ichain][ipier]);
++		calPier = ar9003_cal_freq_pier(ah, ipier, is2ghz);
++		pCalPierStruct = ar9003_cal_pier_data(ah, ichain, ipier, is2ghz);
+ 	} else {
+ 		if (ipier >= AR9300_NUM_5G_CAL_PIERS) {
+ 			ath_dbg(common, EEPROM,
+@@ -4783,11 +4986,11 @@ static int ar9003_hw_cal_pier_get(struct ath_hw *ah,
+ 				AR9300_NUM_5G_CAL_PIERS);
+ 			return -1;
+ 		}
+-		pCalPier = &(eep->calFreqPier5G[ipier]);
+-		pCalPierStruct = &(eep->calPierData5G[ichain][ipier]);
++		calPier = ar9003_cal_freq_pier(ah, ipier, is2ghz);
++		pCalPierStruct = ar9003_cal_pier_data(ah, ichain, ipier, is2ghz);
+ 	}
+ 
+-	*pfrequency = ath9k_hw_fbin2freq(*pCalPier, is2ghz);
++	*pfrequency = ath9k_hw_fbin2freq(calPier, is2ghz);
+ 	*pcorrection = pCalPierStruct->refPower;
+ 	*ptemperature = pCalPierStruct->tempMeas;
+ 	*pvoltage = pCalPierStruct->voltMeas;
+@@ -4805,7 +5008,12 @@ static void ar9003_hw_power_control_override(struct ath_hw *ah,
+ 					     int *voltage, int *temperature)
+ {
+ 	int temp_slope = 0, temp_slope1 = 0, temp_slope2 = 0;
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	struct ar9300_base_eep_hdr *pBase = ar9003_base_header(ah);
++	struct ar9300_BaseExtension_1 *base_ext1 = ar9003_base_ext1(ah);
++	bool is2ghz = frequency < 4000;
++	int8_t eep_temp_slope = ar9003_temp_slope(ah, is2ghz);
++	int8_t eep_temp_slope_low = ar9003_temp_slope_low(ah);
++	int8_t eep_temp_slope_high = ar9003_temp_slope_high(ah);
+ 	int f[8], t[8], t1[3], t2[3], i;
+ 
+ 	REG_RMW(ah, AR_PHY_TPC_11_B0(ah),
+@@ -4837,23 +5045,23 @@ static void ar9003_hw_power_control_override(struct ath_hw *ah,
+ 	 * enable temperature compensation
+ 	 * Need to use register names
+ 	 */
+-	if (frequency < 4000) {
+-		temp_slope = eep->modalHeader2G.tempSlope;
++	if (is2ghz) {
++		temp_slope = eep_temp_slope;
+ 	} else {
+ 		if (AR_SREV_9550(ah)) {
+-			t[0] = eep->base_ext1.tempslopextension[2];
+-			t1[0] = eep->base_ext1.tempslopextension[3];
+-			t2[0] = eep->base_ext1.tempslopextension[4];
++			t[0] = base_ext1->tempslopextension[2];
++			t1[0] = base_ext1->tempslopextension[3];
++			t2[0] = base_ext1->tempslopextension[4];
+ 			f[0] = 5180;
+ 
+-			t[1] = eep->modalHeader5G.tempSlope;
+-			t1[1] = eep->base_ext1.tempslopextension[0];
+-			t2[1] = eep->base_ext1.tempslopextension[1];
++			t[1] = eep_temp_slope;
++			t1[1] = base_ext1->tempslopextension[0];
++			t2[1] = base_ext1->tempslopextension[1];
+ 			f[1] = 5500;
+ 
+-			t[2] = eep->base_ext1.tempslopextension[5];
+-			t1[2] = eep->base_ext1.tempslopextension[6];
+-			t2[2] = eep->base_ext1.tempslopextension[7];
++			t[2] = base_ext1->tempslopextension[5];
++			t1[2] = base_ext1->tempslopextension[6];
++			t2[2] = base_ext1->tempslopextension[7];
+ 			f[2] = 5785;
+ 
+ 			temp_slope = ar9003_hw_power_interpolate(frequency,
+@@ -4866,42 +5074,44 @@ static void ar9003_hw_power_control_override(struct ath_hw *ah,
+ 			goto tempslope;
+ 		}
+ 
+-		if ((eep->baseEepHeader.miscConfiguration & 0x20) != 0) {
++		if ((pBase->miscConfiguration & 0x20) != 0) {
+ 			for (i = 0; i < 8; i++) {
+-				t[i] = eep->base_ext1.tempslopextension[i];
+-				f[i] = FBIN2FREQ(eep->calFreqPier5G[i], 0);
++				t[i] = base_ext1->tempslopextension[i];
++				f[i] = FBIN2FREQ(
++					ar9003_cal_freq_pier(ah, i, is2ghz),
++					0);
+ 			}
+ 			temp_slope = ar9003_hw_power_interpolate((s32) frequency,
+ 								 f, t, 8);
+-		} else if (eep->base_ext2.tempSlopeLow != 0) {
+-			t[0] = eep->base_ext2.tempSlopeLow;
++		} else if (eep_temp_slope_low != 0) {
++			t[0] = eep_temp_slope_low;
+ 			f[0] = 5180;
+-			t[1] = eep->modalHeader5G.tempSlope;
++			t[1] = eep_temp_slope;
+ 			f[1] = 5500;
+-			t[2] = eep->base_ext2.tempSlopeHigh;
++			t[2] = eep_temp_slope_high;
+ 			f[2] = 5785;
+ 			temp_slope = ar9003_hw_power_interpolate((s32) frequency,
+ 								 f, t, 3);
+ 		} else {
+-			temp_slope = eep->modalHeader5G.tempSlope;
++			temp_slope = eep_temp_slope;
+ 		}
+ 	}
+ 
+ tempslope:
+ 	if (AR_SREV_9550(ah) || AR_SREV_9531(ah) || AR_SREV_9561(ah) ||
+ 	    AR_SREV_5502(ah)) {
+-		u8 txmask = (eep->baseEepHeader.txrxMask & 0xf0) >> 4;
++		u8 txmask = (pBase->txrxMask & 0xf0) >> 4;
+ 
+ 		/*
+ 		 * AR955x has tempSlope register for each chain.
+ 		 * Check whether temp_compensation feature is enabled or not.
+ 		 */
+-		if (eep->baseEepHeader.featureEnable & 0x1) {
+-			if (frequency < 4000) {
++		if (pBase->featureEnable & 0x1) {
++			if (is2ghz) {
+ 				if (txmask & BIT(0))
+ 					REG_RMW_FIELD(ah, AR_PHY_TPC_19(ah),
+ 						      AR_PHY_TPC_19_ALPHA_THERM,
+-						      eep->base_ext2.tempSlopeLow);
++						      eep_temp_slope_low);
+ 				if (txmask & BIT(1))
+ 					REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1(ah),
+ 						      AR_PHY_TPC_19_ALPHA_THERM,
+@@ -4909,7 +5119,7 @@ static void ar9003_hw_power_control_override(struct ath_hw *ah,
+ 				if (txmask & BIT(2))
+ 					REG_RMW_FIELD(ah, AR_PHY_TPC_19_B2(ah),
+ 						      AR_PHY_TPC_19_ALPHA_THERM,
+-						      eep->base_ext2.tempSlopeHigh);
++						      eep_temp_slope_high);
+ 			} else {
+ 				if (txmask & BIT(0))
+ 					REG_RMW_FIELD(ah, AR_PHY_TPC_19(ah),
+@@ -5140,42 +5350,25 @@ static int ar9003_hw_calibration_apply(struct ath_hw *ah, int frequency)
+ 	return 0;
+ }
+ 
+-static u16 ar9003_hw_get_direct_edge_power(struct ar9300_eeprom *eep,
++static u16 ar9003_hw_get_direct_edge_power(struct ath_hw *ah,
+ 					   int idx,
+ 					   int edge,
+ 					   bool is2GHz)
+ {
+-	struct cal_ctl_data_2g *ctl_2g = eep->ctlPowerData_2G;
+-	struct cal_ctl_data_5g *ctl_5g = eep->ctlPowerData_5G;
+-
+-	if (is2GHz)
+-		return CTL_EDGE_TPOWER(ctl_2g[idx].ctlEdges[edge]);
+-	else
+-		return CTL_EDGE_TPOWER(ctl_5g[idx].ctlEdges[edge]);
++	return CTL_EDGE_TPOWER(ar9003_ctl_power_data(ah, idx, edge, is2GHz));
+ }
+ 
+-static u16 ar9003_hw_get_indirect_edge_power(struct ar9300_eeprom *eep,
++static u16 ar9003_hw_get_indirect_edge_power(struct ath_hw *ah,
+ 					     int idx,
+ 					     unsigned int edge,
+ 					     u16 freq,
+ 					     bool is2GHz)
+ {
+-	struct cal_ctl_data_2g *ctl_2g = eep->ctlPowerData_2G;
+-	struct cal_ctl_data_5g *ctl_5g = eep->ctlPowerData_5G;
+-
+-	u8 *ctl_freqbin = is2GHz ?
+-		&eep->ctl_freqbin_2G[idx][0] :
+-		&eep->ctl_freqbin_5G[idx][0];
+-
+-	if (is2GHz) {
+-		if (ath9k_hw_fbin2freq(ctl_freqbin[edge - 1], 1) < freq &&
+-		    CTL_EDGE_FLAGS(ctl_2g[idx].ctlEdges[edge - 1]))
+-			return CTL_EDGE_TPOWER(ctl_2g[idx].ctlEdges[edge - 1]);
+-	} else {
+-		if (ath9k_hw_fbin2freq(ctl_freqbin[edge - 1], 0) < freq &&
+-		    CTL_EDGE_FLAGS(ctl_5g[idx].ctlEdges[edge - 1]))
+-			return CTL_EDGE_TPOWER(ctl_5g[idx].ctlEdges[edge - 1]);
+-	}
++	if (ath9k_hw_fbin2freq(ar9003_ctl_freqbin(ah, idx, edge - 1, is2GHz),
++			       is2GHz) < freq &&
++	    CTL_EDGE_FLAGS(ar9003_ctl_power_data(ah, idx, edge - 1, is2GHz)))
++		return CTL_EDGE_TPOWER(
++			ar9003_ctl_power_data(ah, idx, edge - 1, is2GHz));
+ 
+ 	return MAX_RATE_POWER;
+ }
+@@ -5183,37 +5376,36 @@ static u16 ar9003_hw_get_indirect_edge_power(struct ar9300_eeprom *eep,
+ /*
+  * Find the maximum conformance test limit for the given channel and CTL info
+  */
+-static u16 ar9003_hw_get_max_edge_power(struct ar9300_eeprom *eep,
++static u16 ar9003_hw_get_max_edge_power(struct ath_hw *ah,
+ 					u16 freq, int idx, bool is2GHz)
+ {
+ 	u16 twiceMaxEdgePower = MAX_RATE_POWER;
+-	u8 *ctl_freqbin = is2GHz ?
+-		&eep->ctl_freqbin_2G[idx][0] :
+-		&eep->ctl_freqbin_5G[idx][0];
+ 	u16 num_edges = is2GHz ?
+ 		AR9300_NUM_BAND_EDGES_2G : AR9300_NUM_BAND_EDGES_5G;
+ 	unsigned int edge;
+ 
+ 	/* Get the edge power */
+ 	for (edge = 0;
+-	     (edge < num_edges) && (ctl_freqbin[edge] != AR5416_BCHAN_UNUSED);
++	     (edge < num_edges) &&
++	     (ar9003_ctl_freqbin(ah, idx, edge, is2GHz) != AR5416_BCHAN_UNUSED);
+ 	     edge++) {
+ 		/*
+ 		 * If there's an exact channel match or an inband flag set
+ 		 * on the lower channel use the given rdEdgePower
+ 		 */
+-		if (freq == ath9k_hw_fbin2freq(ctl_freqbin[edge], is2GHz)) {
+-			twiceMaxEdgePower =
+-				ar9003_hw_get_direct_edge_power(eep, idx,
+-								edge, is2GHz);
++		if (freq == ath9k_hw_fbin2freq(ar9003_ctl_freqbin(ah, idx, edge,
++								  is2GHz),
++					       is2GHz)) {
++			twiceMaxEdgePower = ar9003_hw_get_direct_edge_power(
++				ah, idx, edge, is2GHz);
+ 			break;
+ 		} else if ((edge > 0) &&
+-			   (freq < ath9k_hw_fbin2freq(ctl_freqbin[edge],
+-						      is2GHz))) {
+-			twiceMaxEdgePower =
+-				ar9003_hw_get_indirect_edge_power(eep, idx,
+-								  edge, freq,
+-								  is2GHz);
++			   (freq <
++			    ath9k_hw_fbin2freq(ar9003_ctl_freqbin(ah, idx, edge,
++								  is2GHz),
++					       is2GHz))) {
++			twiceMaxEdgePower = ar9003_hw_get_indirect_edge_power(
++				ah, idx, edge, freq, is2GHz);
+ 			/*
+ 			 * Leave loop - no more affecting edges possible in
+ 			 * this monotonic increasing list
+@@ -5235,7 +5427,6 @@ static void ar9003_hw_set_power_per_rate_table(struct ath_hw *ah,
+ 					       u16 powerLimit)
+ {
+ 	struct ath_common *common = ath9k_hw_common(ah);
+-	struct ar9300_eeprom *pEepData = &ah->eeprom.ar9300_eep;
+ 	u16 twiceMaxEdgePower;
+ 	int i;
+ 	u16 scaledPower = 0, minCtlPower;
+@@ -5250,7 +5441,6 @@ static void ar9003_hw_set_power_per_rate_table(struct ath_hw *ah,
+ 	const u16 *pCtlMode;
+ 	u16 ctlMode, freq;
+ 	struct chan_centers centers;
+-	u8 *ctlIndex;
+ 	u8 ctlNum;
+ 	u16 twiceMinEdgePower;
+ 	bool is2ghz = IS_CHAN_2GHZ(chan);
+@@ -5305,18 +5495,17 @@ static void ar9003_hw_set_power_per_rate_table(struct ath_hw *ah,
+ 
+ 		/* walk through each CTL index stored in EEPROM */
+ 		if (is2ghz) {
+-			ctlIndex = pEepData->ctlIndex_2G;
+ 			ctlNum = AR9300_NUM_CTLS_2G;
+ 		} else {
+-			ctlIndex = pEepData->ctlIndex_5G;
+ 			ctlNum = AR9300_NUM_CTLS_5G;
+ 		}
+ 
+ 		twiceMaxEdgePower = MAX_RATE_POWER;
+-		for (i = 0; (i < ctlNum) && ctlIndex[i]; i++) {
++		for (i = 0; (i < ctlNum) && ar9003_ctl_index(ah, i, is2ghz);
++		     i++) {
+ 			ath_dbg(common, REGULATORY,
+ 				"LOOP-Ctlidx %d: cfgCtl 0x%2.2x pCtlMode 0x%2.2x ctlIndex 0x%2.2x chan %d\n",
+-				i, cfgCtl, pCtlMode[ctlMode], ctlIndex[i],
++				i, cfgCtl, pCtlMode[ctlMode], ar9003_ctl_index(ah, i, is2ghz),
+ 				chan->channel);
+ 
+ 			/*
+@@ -5326,13 +5515,13 @@ static void ar9003_hw_set_power_per_rate_table(struct ath_hw *ah,
+ 			 */
+ 			if ((((cfgCtl & ~CTL_MODE_M) |
+ 			       (pCtlMode[ctlMode] & CTL_MODE_M)) ==
+-				ctlIndex[i]) ||
++				ar9003_ctl_index(ah, i, is2ghz)) ||
+ 			    (((cfgCtl & ~CTL_MODE_M) |
+ 			       (pCtlMode[ctlMode] & CTL_MODE_M)) ==
+-			     ((ctlIndex[i] & CTL_MODE_M) |
++			     ((ar9003_ctl_index(ah, i, is2ghz) & CTL_MODE_M) |
+ 			       SD_NO_CTL))) {
+ 				twiceMinEdgePower =
+-				  ar9003_hw_get_max_edge_power(pEepData,
++				  ar9003_hw_get_max_edge_power(ah,
+ 							       freq, i,
+ 							       is2ghz);
+ 
+@@ -5570,16 +5759,12 @@ static u16 ath9k_hw_ar9300_get_spur_channel(struct ath_hw *ah,
+ 
+ s32 ar9003_hw_get_tx_gain_idx(struct ath_hw *ah)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-
+-	return (eep->baseEepHeader.txrxgain >> 4) & 0xf; /* bits 7:4 */
++	return (ar9003_base_header(ah)->txrxgain >> 4) & 0xf; /* bits 7:4 */
+ }
+ 
+ s32 ar9003_hw_get_rx_gain_idx(struct ath_hw *ah)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-
+-	return (eep->baseEepHeader.txrxgain) & 0xf; /* bits 3:0 */
++	return (ar9003_base_header(ah)->txrxgain) & 0xf; /* bits 3:0 */
+ }
+ 
+ u8 *ar9003_get_spur_chan_ptr(struct ath_hw *ah, bool is2ghz)
+@@ -5620,7 +5805,7 @@ unsigned int ar9003_get_paprd_scale_factor(struct ath_hw *ah,
+ 
+ static u8 ar9003_get_eepmisc(struct ath_hw *ah)
+ {
+-	return ah->eeprom.ar9300_eep.baseEepHeader.opCapFlags.eepMisc;
++	return ar9003_base_header(ah)->opCapFlags.eepMisc;
+ }
+ 
+ const struct eeprom_ops eep_ar9300_ops = {
+-- 
+2.34.1
+
diff --git a/package/feeds/base/mac80211/patches/ath9k/011-wifi-ath9k-add-QCN550x-eeprom.patch b/package/feeds/base/mac80211/patches/ath9k/011-wifi-ath9k-add-QCN550x-eeprom.patch
new file mode 100644
index 0000000000..ea881b7eb0
--- /dev/null
+++ b/package/feeds/base/mac80211/patches/ath9k/011-wifi-ath9k-add-QCN550x-eeprom.patch
@@ -0,0 +1,690 @@
+From 7eae1f00c8c1fcac65cd806834a39fe8627269cf Mon Sep 17 00:00:00 2001
+From: Wenli Looi <wlooi@ucalgary.ca>
+Date: Tue, 11 Apr 2023 07:09:55 +0000
+Subject: [PATCH v3 11/11] wifi: ath9k: add QCN550x eeprom
+
+This adds support for the 4-chain eeprom used by QCN550x.
+
+Signed-off-by: Wenli Looi <wlooi@ucalgary.ca>
+---
+ .../net/wireless/ath/ath9k/ar9003_eeprom.c    | 294 +++++++++++++-----
+ .../net/wireless/ath/ath9k/ar9003_eeprom.h    | 112 +++++++
+ drivers/net/wireless/ath/ath9k/hw.h           |   1 +
+ 3 files changed, 337 insertions(+), 70 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+index 669506884b..f28ebc9953 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+@@ -2984,12 +2984,14 @@ static int ath9k_hw_ar9300_get_eeprom_rev(struct ath_hw *ah)
+ 
+ static struct ar9300_base_eep_hdr *ar9003_base_header(struct ath_hw *ah)
+ {
+-	return &ah->eeprom.ar9300_eep.baseEepHeader;
++	return AR_SREV_5502(ah) ? &ah->eeprom.qcn5502.baseEepHeader :
++				  &ah->eeprom.ar9300_eep.baseEepHeader;
+ }
+ 
+ static struct ar9300_BaseExtension_1 *ar9003_base_ext1(struct ath_hw *ah)
+ {
+-	return &ah->eeprom.ar9300_eep.base_ext1;
++	return AR_SREV_5502(ah) ? &ah->eeprom.qcn5502.base_ext1 :
++				  &ah->eeprom.ar9300_eep.base_ext1;
+ }
+ 
+ static struct ar9300_modal_eep_header *ar9003_modal_header(struct ath_hw *ah,
+@@ -3003,206 +3005,338 @@ static struct ar9300_modal_eep_header *ar9003_modal_header(struct ath_hw *ah,
+ 		return &eep->modalHeader5G;
+ }
+ 
++static struct qcn5502_modal_eep_header *qcn5502_modal_header(struct ath_hw *ah,
++							     bool is2ghz)
++{
++	struct qcn5502_eeprom *eep = &ah->eeprom.qcn5502;
++
++	if (is2ghz)
++		return &eep->modalHeader2G;
++	else
++		return &eep->modalHeader5G;
++}
++
+ static int8_t ar9003_ant_gain(struct ath_hw *ah, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->antennaGain;
++	return AR_SREV_5502(ah) ?
++		       qcn5502_modal_header(ah, is2ghz)->antennaGain :
++		       ar9003_modal_header(ah, is2ghz)->antennaGain;
+ }
+ 
+ static u8 ar9003_cal_freq_pier(struct ath_hw *ah, int idx, bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	return is2ghz ? eep->calFreqPier2G[idx] : eep->calFreqPier5G[idx];
++	if (AR_SREV_5502(ah)) {
++		struct qcn5502_eeprom *eep = &ah->eeprom.qcn5502;
++		return is2ghz ? eep->calFreqPier2G[idx] :
++				eep->calFreqPier5G[idx];
++	} else {
++		struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++		return is2ghz ? eep->calFreqPier2G[idx] :
++				eep->calFreqPier5G[idx];
++	}
+ }
+ 
+ static struct ar9300_cal_data_per_freq_op_loop *
+ ar9003_cal_pier_data(struct ath_hw *ah, int chain, int idx, bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	return is2ghz ? &eep->calPierData2G[chain][idx] :
+-			      &eep->calPierData5G[chain][idx];
++	if (AR_SREV_5502(ah)) {
++		struct qcn5502_eeprom *eep = &ah->eeprom.qcn5502;
++		return is2ghz ? &eep->calPierData2G[chain][idx] :
++				&eep->calPierData5G[chain][idx];
++	} else {
++		struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++		return is2ghz ? &eep->calPierData2G[chain][idx] :
++				&eep->calPierData5G[chain][idx];
++	}
+ }
+ 
+ static u8 ar9003_cal_target_freqbin(struct ath_hw *ah, int idx, bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	return is2ghz ? eep->calTarget_freqbin_2G[idx] :
+-			      eep->calTarget_freqbin_5G[idx];
++	if (AR_SREV_5502(ah)) {
++		struct qcn5502_eeprom *eep = &ah->eeprom.qcn5502;
++		return is2ghz ? eep->calTarget_freqbin_2G[idx] :
++				eep->calTarget_freqbin_5G[idx];
++	} else {
++		struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++		return is2ghz ? eep->calTarget_freqbin_2G[idx] :
++				eep->calTarget_freqbin_5G[idx];
++	}
+ }
+ 
+ static u8 ar9003_cal_target_freqbin_cck(struct ath_hw *ah, int idx)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	return eep->calTarget_freqbin_Cck[idx];
++	if (AR_SREV_5502(ah)) {
++		struct qcn5502_eeprom *eep = &ah->eeprom.qcn5502;
++		return eep->calTarget_freqbin_Cck[idx];
++	} else {
++		struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++		return eep->calTarget_freqbin_Cck[idx];
++	}
+ }
+ 
+ static u8 ar9003_cal_target_freqbin_ht20(struct ath_hw *ah, int idx,
+ 					 bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	return is2ghz ? eep->calTarget_freqbin_2GHT20[idx] :
+-			      eep->calTarget_freqbin_5GHT20[idx];
++	if (AR_SREV_5502(ah)) {
++		struct qcn5502_eeprom *eep = &ah->eeprom.qcn5502;
++		return is2ghz ? eep->calTarget_freqbin_2GHT20[idx] :
++				eep->calTarget_freqbin_5GHT20[idx];
++	} else {
++		struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++		return is2ghz ? eep->calTarget_freqbin_2GHT20[idx] :
++				eep->calTarget_freqbin_5GHT20[idx];
++	}
+ }
+ 
+ static u8 ar9003_cal_target_freqbin_ht40(struct ath_hw *ah, int idx,
+ 					 bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	return is2ghz ? eep->calTarget_freqbin_2GHT40[idx] :
+-			      eep->calTarget_freqbin_5GHT40[idx];
++	if (AR_SREV_5502(ah)) {
++		struct qcn5502_eeprom *eep = &ah->eeprom.qcn5502;
++		return is2ghz ? eep->calTarget_freqbin_2GHT40[idx] :
++				eep->calTarget_freqbin_5GHT40[idx];
++	} else {
++		struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++		return is2ghz ? eep->calTarget_freqbin_2GHT40[idx] :
++				eep->calTarget_freqbin_5GHT40[idx];
++	}
+ }
+ 
+ static u8 ar9003_cal_target_power(struct ath_hw *ah, int idx, int rateIndex,
+ 				  bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	return is2ghz ? eep->calTargetPower2G[idx].tPow2x[rateIndex] :
+-			      eep->calTargetPower5G[idx].tPow2x[rateIndex];
++	if (AR_SREV_5502(ah)) {
++		struct qcn5502_eeprom *eep = &ah->eeprom.qcn5502;
++		return is2ghz ? eep->calTargetPower2G[idx].tPow2x[rateIndex] :
++				eep->calTargetPower5G[idx].tPow2x[rateIndex];
++	} else {
++		struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++		return is2ghz ? eep->calTargetPower2G[idx].tPow2x[rateIndex] :
++				eep->calTargetPower5G[idx].tPow2x[rateIndex];
++	}
+ }
+ 
+ static u8 ar9003_cal_target_power_cck(struct ath_hw *ah, int idx, int rateIndex)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	return eep->calTargetPowerCck[idx].tPow2x[rateIndex];
++	if (AR_SREV_5502(ah)) {
++		struct qcn5502_eeprom *eep = &ah->eeprom.qcn5502;
++		return eep->calTargetPowerCck[idx].tPow2x[rateIndex];
++	} else {
++		struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++		return eep->calTargetPowerCck[idx].tPow2x[rateIndex];
++	}
+ }
+ 
+ static u8 ar9003_cal_target_power_ht20(struct ath_hw *ah, int idx,
+ 				       int rateIndex, bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	return is2ghz ? eep->calTargetPower2GHT20[idx].tPow2x[rateIndex] :
+-			      eep->calTargetPower5GHT20[idx].tPow2x[rateIndex];
++	if (AR_SREV_5502(ah)) {
++		struct qcn5502_eeprom *eep = &ah->eeprom.qcn5502;
++		return is2ghz ?
++			       eep->calTargetPower2GHT20[idx].tPow2x[rateIndex] :
++			       eep->calTargetPower5GHT20[idx].tPow2x[rateIndex];
++	} else {
++		struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++		return is2ghz ?
++			       eep->calTargetPower2GHT20[idx].tPow2x[rateIndex] :
++			       eep->calTargetPower5GHT20[idx].tPow2x[rateIndex];
++	}
+ }
+ 
+ static u8 ar9003_cal_target_power_ht40(struct ath_hw *ah, int idx,
+ 				       int rateIndex, bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	return is2ghz ? eep->calTargetPower2GHT40[idx].tPow2x[rateIndex] :
+-			      eep->calTargetPower5GHT40[idx].tPow2x[rateIndex];
++	if (AR_SREV_5502(ah)) {
++		struct qcn5502_eeprom *eep = &ah->eeprom.qcn5502;
++		return is2ghz ?
++			       eep->calTargetPower2GHT40[idx].tPow2x[rateIndex] :
++			       eep->calTargetPower5GHT40[idx].tPow2x[rateIndex];
++	} else {
++		struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++		return is2ghz ?
++			       eep->calTargetPower2GHT40[idx].tPow2x[rateIndex] :
++			       eep->calTargetPower5GHT40[idx].tPow2x[rateIndex];
++	}
+ }
+ 
+ static u8 ar9003_ctl_freqbin(struct ath_hw *ah, int idx, int edge, bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	return is2ghz ? eep->ctl_freqbin_2G[idx][edge] :
+-			      eep->ctl_freqbin_5G[idx][edge];
++	if (AR_SREV_5502(ah)) {
++		struct qcn5502_eeprom *eep = &ah->eeprom.qcn5502;
++		return is2ghz ? eep->ctl_freqbin_2G[idx][edge] :
++				eep->ctl_freqbin_5G[idx][edge];
++	} else {
++		struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++		return is2ghz ? eep->ctl_freqbin_2G[idx][edge] :
++				eep->ctl_freqbin_5G[idx][edge];
++	}
+ }
+ 
+ static u8 ar9003_ctl_index(struct ath_hw *ah, int idx, bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	return is2ghz ? eep->ctlIndex_2G[idx] : eep->ctlIndex_5G[idx];
++	if (AR_SREV_5502(ah)) {
++		struct qcn5502_eeprom *eep = &ah->eeprom.qcn5502;
++		return is2ghz ? eep->ctlIndex_2G[idx] : eep->ctlIndex_5G[idx];
++	} else {
++		struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++		return is2ghz ? eep->ctlIndex_2G[idx] : eep->ctlIndex_5G[idx];
++	}
+ }
+ 
+ static u8 ar9003_ctl_power_data(struct ath_hw *ah, int idx, int edge,
+ 				bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	return is2ghz ? eep->ctlPowerData_2G[idx].ctlEdges[edge] :
+-			      eep->ctlPowerData_5G[idx].ctlEdges[edge];
++	if (AR_SREV_5502(ah)) {
++		struct qcn5502_eeprom *eep = &ah->eeprom.qcn5502;
++		return is2ghz ? eep->ctlPowerData_2G[idx].ctlEdges[edge] :
++				eep->ctlPowerData_5G[idx].ctlEdges[edge];
++	} else {
++		struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++		return is2ghz ? eep->ctlPowerData_2G[idx].ctlEdges[edge] :
++				eep->ctlPowerData_5G[idx].ctlEdges[edge];
++	}
+ }
+ 
+ static u16 ar9003_hw_ant_ctrl_chain_get(struct ath_hw *ah, int chain,
+ 					bool is2ghz)
+ {
+-	__le16 val = ar9003_modal_header(ah, is2ghz)->antCtrlChain[chain];
++	__le16 val =
++		AR_SREV_5502(ah) ?
++			qcn5502_modal_header(ah, is2ghz)->antCtrlChain[chain] :
++			ar9003_modal_header(ah, is2ghz)->antCtrlChain[chain];
+ 	return le16_to_cpu(val);
+ }
+ 
+ u32 ar9003_hw_ant_ctrl_common_get(struct ath_hw *ah, bool is2ghz)
+ {
+-	return le32_to_cpu(ar9003_modal_header(ah, is2ghz)->antCtrlCommon);
++	__le32 val = AR_SREV_5502(ah) ?
++			     qcn5502_modal_header(ah, is2ghz)->antCtrlCommon :
++			     ar9003_modal_header(ah, is2ghz)->antCtrlCommon;
++	return le32_to_cpu(val);
+ }
+ 
+ u32 ar9003_hw_ant_ctrl_common_2_get(struct ath_hw *ah, bool is2ghz)
+ {
+-	return le32_to_cpu(ar9003_modal_header(ah, is2ghz)->antCtrlCommon2);
++	__le32 val = AR_SREV_5502(ah) ?
++			     qcn5502_modal_header(ah, is2ghz)->antCtrlCommon2 :
++			     ar9003_modal_header(ah, is2ghz)->antCtrlCommon2;
++	return le32_to_cpu(val);
+ }
+ 
+ static int8_t ar9003_noise_floor_thres(struct ath_hw *ah, int chain,
+ 				       bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->noiseFloorThreshCh[chain];
++	return AR_SREV_5502(ah) ? qcn5502_modal_header(ah, is2ghz)
++					  ->noiseFloorThreshCh[chain] :
++				  ar9003_modal_header(ah, is2ghz)
++					  ->noiseFloorThreshCh[chain];
+ }
+ 
+ static int8_t ar9003_quick_drop(struct ath_hw *ah, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->quick_drop;
++	return AR_SREV_5502(ah) ? qcn5502_modal_header(ah, is2ghz)->quick_drop :
++				  ar9003_modal_header(ah, is2ghz)->quick_drop;
+ }
+ 
+ static int8_t ar9003_temp_slope(struct ath_hw *ah, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->tempSlope;
++	return AR_SREV_5502(ah) ? qcn5502_modal_header(ah, is2ghz)->tempSlope :
++				  ar9003_modal_header(ah, is2ghz)->tempSlope;
+ }
+ 
+ static int8_t ar9003_temp_slope_high(struct ath_hw *ah)
+ {
+-	return ah->eeprom.ar9300_eep.base_ext2.tempSlopeHigh;
++	return AR_SREV_5502(ah) ? ah->eeprom.qcn5502.base_ext2.tempSlopeHigh :
++				  ah->eeprom.ar9300_eep.base_ext2.tempSlopeHigh;
+ }
+ 
+ static int8_t ar9003_temp_slope_low(struct ath_hw *ah)
+ {
+-	return ah->eeprom.ar9300_eep.base_ext2.tempSlopeLow;
++	return AR_SREV_5502(ah) ? ah->eeprom.qcn5502.base_ext2.tempSlopeLow :
++				  ah->eeprom.ar9300_eep.base_ext2.tempSlopeLow;
+ }
+ 
+ static u8 ar9003_tx_end_to_xpa_off(struct ath_hw *ah, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->txEndToXpaOff;
++	return AR_SREV_5502(ah) ?
++		       qcn5502_modal_header(ah, is2ghz)->txEndToXpaOff :
++		       ar9003_modal_header(ah, is2ghz)->txEndToXpaOff;
+ }
+ 
+ static u8 ar9003_tx_frame_to_xpa_on(struct ath_hw *ah, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->txFrameToXpaOn;
++	return AR_SREV_5502(ah) ?
++		       qcn5502_modal_header(ah, is2ghz)->txFrameToXpaOn :
++		       ar9003_modal_header(ah, is2ghz)->txFrameToXpaOn;
+ }
+ 
+ static u8 ar9003_xatten1_db_high(struct ath_hw *ah, int chain)
+ {
+-	return ah->eeprom.ar9300_eep.base_ext2.xatten1DBHigh[chain];
++	return AR_SREV_5502(ah) ?
++		       ah->eeprom.qcn5502.base_ext2.xatten1DBHigh[chain] :
++		       ah->eeprom.ar9300_eep.base_ext2.xatten1DBHigh[chain];
+ }
+ 
+ static u8 ar9003_xatten1_db_low(struct ath_hw *ah, int chain)
+ {
+-	return ah->eeprom.ar9300_eep.base_ext2.xatten1DBLow[chain];
++	return AR_SREV_5502(ah) ?
++		       ah->eeprom.qcn5502.base_ext2.xatten1DBLow[chain] :
++		       ah->eeprom.ar9300_eep.base_ext2.xatten1DBLow[chain];
+ }
+ 
+ static u8 ar9003_xatten1_db_margin_high(struct ath_hw *ah, int chain)
+ {
+-	return ah->eeprom.ar9300_eep.base_ext2.xatten1MarginHigh[chain];
++	return AR_SREV_5502(ah) ?
++		       ah->eeprom.qcn5502.base_ext2.xatten1MarginHigh[chain] :
++		       ah->eeprom.ar9300_eep.base_ext2.xatten1MarginHigh[chain];
+ }
+ 
+ static u8 ar9003_xatten1_db_margin_low(struct ath_hw *ah, int chain)
+ {
+-	return ah->eeprom.ar9300_eep.base_ext2.xatten1MarginLow[chain];
++	return AR_SREV_5502(ah) ?
++		       ah->eeprom.qcn5502.base_ext2.xatten1MarginLow[chain] :
++		       ah->eeprom.ar9300_eep.base_ext2.xatten1MarginLow[chain];
+ }
+ 
+ static u8 ar9003_xatten1_db(struct ath_hw *ah, int chain, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->xatten1DB[chain];
++	return AR_SREV_5502(ah) ?
++		       qcn5502_modal_header(ah, is2ghz)->xatten1DB[chain] :
++		       ar9003_modal_header(ah, is2ghz)->xatten1DB[chain];
+ }
+ 
+ static u8 ar9003_xatten1_margin(struct ath_hw *ah, int chain, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->xatten1Margin[chain];
++	return AR_SREV_5502(ah) ?
++		       qcn5502_modal_header(ah, is2ghz)->xatten1Margin[chain] :
++		       ar9003_modal_header(ah, is2ghz)->xatten1Margin[chain];
+ }
+ 
+ static u8 ar9003_xlna_bias_strength(struct ath_hw *ah, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->xlna_bias_strength;
++	return AR_SREV_5502(ah) ?
++		       qcn5502_modal_header(ah, is2ghz)->xlna_bias_strength :
++		       ar9003_modal_header(ah, is2ghz)->xlna_bias_strength;
+ }
+ 
+ static u8 ar9003_xpa_bias_lvl(struct ath_hw *ah, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->xpaBiasLvl;
++	return AR_SREV_5502(ah) ? qcn5502_modal_header(ah, is2ghz)->xpaBiasLvl :
++				  ar9003_modal_header(ah, is2ghz)->xpaBiasLvl;
+ }
+ 
+ static u8 *ar9003_mac_addr(struct ath_hw *ah)
+ {
+-	return ah->eeprom.ar9300_eep.macAddr;
++	return AR_SREV_5502(ah) ? ah->eeprom.qcn5502.macAddr :
++				  ah->eeprom.ar9300_eep.macAddr;
+ }
+ 
+ static u16 ar9003_switch_com_spdt_get(struct ath_hw *ah, bool is2ghz)
+ {
+-	return le16_to_cpu(ar9003_modal_header(ah, is2ghz)->switchcomspdt);
++	__le16 val = AR_SREV_5502(ah) ?
++			     qcn5502_modal_header(ah, is2ghz)->switchcomspdt :
++			     ar9003_modal_header(ah, is2ghz)->switchcomspdt;
++	return le16_to_cpu(val);
+ }
+ 
+ static u32 ath9k_hw_ar9300_get_eeprom(struct ath_hw *ah,
+@@ -3614,10 +3748,11 @@ static int ar9300_eeprom_restore_internal(struct ath_hw *ah,
+  */
+ static bool ath9k_hw_ar9300_fill_eeprom(struct ath_hw *ah)
+ {
+-	u8 *mptr = (u8 *) &ah->eeprom.ar9300_eep;
++	u8 *mptr = (u8 *)&ah->eeprom;
++	int mdata_size = AR_SREV_5502(ah) ? sizeof(struct qcn5502_eeprom) :
++					    sizeof(struct ar9300_eeprom);
+ 
+-	if (ar9300_eeprom_restore_internal(ah, mptr,
+-			sizeof(struct ar9300_eeprom)) < 0)
++	if (ar9300_eeprom_restore_internal(ah, mptr, mdata_size) < 0)
+ 		return false;
+ 
+ 	return true;
+@@ -3627,32 +3762,42 @@ static bool ath9k_hw_ar9300_fill_eeprom(struct ath_hw *ah)
+ 
+ static int8_t ar9003_adc_desired_size(struct ath_hw *ah, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->adcDesiredSize;
++	return AR_SREV_5502(ah) ?
++		       qcn5502_modal_header(ah, is2ghz)->adcDesiredSize :
++		       ar9003_modal_header(ah, is2ghz)->adcDesiredSize;
+ }
+ 
+ static u8 ar9003_switch_settling(struct ath_hw *ah, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->switchSettling;
++	return AR_SREV_5502(ah) ?
++		       qcn5502_modal_header(ah, is2ghz)->switchSettling :
++		       ar9003_modal_header(ah, is2ghz)->switchSettling;
+ }
+ 
+ static u8 ar9003_tx_clip(struct ath_hw *ah, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->txClip;
++	return AR_SREV_5502(ah) ? qcn5502_modal_header(ah, is2ghz)->txClip :
++				  ar9003_modal_header(ah, is2ghz)->txClip;
+ }
+ 
+ static u8 ar9003_tx_frame_to_data_start(struct ath_hw *ah, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->txFrameToDataStart;
++	return AR_SREV_5502(ah) ?
++		       qcn5502_modal_header(ah, is2ghz)->txFrameToDataStart :
++		       ar9003_modal_header(ah, is2ghz)->txFrameToDataStart;
+ }
+ 
+ static u8 ar9003_tx_frame_to_pa_on(struct ath_hw *ah, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->txFrameToPaOn;
++	return AR_SREV_5502(ah) ?
++		       qcn5502_modal_header(ah, is2ghz)->txFrameToPaOn :
++		       ar9003_modal_header(ah, is2ghz)->txFrameToPaOn;
+ }
+ 
+ static int8_t ar9003_volt_slope(struct ath_hw *ah, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->voltSlope;
++	return AR_SREV_5502(ah) ? qcn5502_modal_header(ah, is2ghz)->voltSlope :
++				  ar9003_modal_header(ah, is2ghz)->voltSlope;
+ }
+ 
+ static u32 ar9003_dump_modal_eeprom(struct ath_hw *ah, char *buf, u32 len,
+@@ -5769,17 +5914,26 @@ s32 ar9003_hw_get_rx_gain_idx(struct ath_hw *ah)
+ 
+ u8 *ar9003_get_spur_chan_ptr(struct ath_hw *ah, bool is2ghz)
+ {
+-	return ar9003_modal_header(ah, is2ghz)->spurChans;
++	return AR_SREV_5502(ah) ? qcn5502_modal_header(ah, is2ghz)->spurChans :
++				  ar9003_modal_header(ah, is2ghz)->spurChans;
+ }
+ 
+ u32 ar9003_get_paprd_rate_mask_ht20(struct ath_hw *ah, bool is2ghz)
+ {
+-	return le32_to_cpu(ar9003_modal_header(ah, is2ghz)->papdRateMaskHt20);
++	__le32 val =
++		AR_SREV_5502(ah) ?
++			qcn5502_modal_header(ah, is2ghz)->papdRateMaskHt20 :
++			ar9003_modal_header(ah, is2ghz)->papdRateMaskHt20;
++	return le32_to_cpu(val);
+ }
+ 
+ u32 ar9003_get_paprd_rate_mask_ht40(struct ath_hw *ah, bool is2ghz)
+ {
+-	return le32_to_cpu(ar9003_modal_header(ah, is2ghz)->papdRateMaskHt40);
++	__le32 val =
++		AR_SREV_5502(ah) ?
++			qcn5502_modal_header(ah, is2ghz)->papdRateMaskHt40 :
++			ar9003_modal_header(ah, is2ghz)->papdRateMaskHt40;
++	return le32_to_cpu(val);
+ }
+ 
+ unsigned int ar9003_get_paprd_scale_factor(struct ath_hw *ah,
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h
+index b91ef1250b..dad67eefba 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h
++++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h
+@@ -42,6 +42,7 @@
+ #define AR9300_CUSTOMER_DATA_SIZE    20
+ 
+ #define AR9300_MAX_CHAINS            3
++#define QCN5502_MAX_CHAINS           4
+ #define AR9300_ANT_16S               25
+ #define AR9300_FUTURE_MODAL_SZ       6
+ 
+@@ -252,6 +253,51 @@ struct ar9300_modal_eep_header {
+ 	u8 futureModal[7];
+ } __packed;
+ 
++struct qcn5502_modal_eep_header {
++	/* 4 idle, t1, t2, b (4 bits per setting) */
++	__le32 antCtrlCommon;
++	/* 4 ra1l1, ra2l1, ra1l2, ra2l2, ra12 */
++	__le32 antCtrlCommon2;
++	/* 6 idle, t, r, rx1, rx12, b (2 bits each) */
++	__le16 antCtrlChain[QCN5502_MAX_CHAINS];
++	/* 3 xatten1_db for AR9280 (0xa20c/b20c 5:0) */
++	u8 xatten1DB[QCN5502_MAX_CHAINS];
++	/* 3  xatten1_margin for merlin (0xa20c/b20c 16:12 */
++	u8 xatten1Margin[QCN5502_MAX_CHAINS];
++	int8_t tempSlope;
++	int8_t voltSlope;
++	/* spur channels in usual fbin coding format */
++	u8 spurChans[AR_EEPROM_MODAL_SPURS];
++	/* 3  Check if the register is per chain */
++	int8_t noiseFloorThreshCh[QCN5502_MAX_CHAINS];
++	u8 reserved[13];
++	int8_t quick_drop;
++	u8 xpaBiasLvl;
++	u8 txFrameToDataStart;
++	u8 txFrameToPaOn;
++	u8 txClip;
++	int8_t antennaGain;
++	u8 switchSettling;
++	int8_t adcDesiredSize;
++	u8 txEndToXpaOff;
++	u8 txEndToRxOn;
++	u8 txFrameToXpaOn;
++	u8 thresh62;
++	__le32 papdRateMaskHt20;
++	__le32 papdRateMask4ssHt20;
++	__le32 papdRateMaskHt40;
++	__le32 papdRateMask4ssHt40;
++	__le16 switchcomspdt;
++	u8 xlna_bias_strength;
++	u8 rf_gain_cap;
++	u8 tx_gain_cap;
++	u8 futureModal[1];
++	int8_t xtal_ppm_target;
++	int8_t xtal_ppm_tolerance;
++	int8_t temp_slope_high_3;
++	int8_t eep_iqmask;
++} __packed;
++
+ struct ar9300_cal_data_per_freq_op_loop {
+ 	int8_t refPower;
+ 	/* pdadc voltage at power measurement */
+@@ -274,6 +320,10 @@ struct cal_tgt_pow_ht {
+ 	u8 tPow2x[14];
+ } __packed;
+ 
++struct qcn5502_cal_tgt_pow_ht {
++	u8 tPow2x[18];
++} __packed;
++
+ struct cal_ctl_data_2g {
+ 	u8 ctlEdges[AR9300_NUM_BAND_EDGES_2G];
+ } __packed;
+@@ -309,6 +359,15 @@ struct ar9300_BaseExtension_2 {
+ 	u8   xatten1MarginHigh[AR9300_MAX_CHAINS];
+ } __packed;
+ 
++struct qcn5502_BaseExtension_2 {
++	int8_t    tempSlopeLow;
++	int8_t    tempSlopeHigh;
++	u8   xatten1DBLow[QCN5502_MAX_CHAINS];
++	u8   xatten1MarginLow[QCN5502_MAX_CHAINS];
++	u8   xatten1DBHigh[QCN5502_MAX_CHAINS];
++	u8   xatten1MarginHigh[QCN5502_MAX_CHAINS];
++} __packed;
++
+ struct ar9300_eeprom {
+ 	u8 eepromVersion;
+ 	u8 templateVersion;
+@@ -356,6 +415,59 @@ struct ar9300_eeprom {
+ 	struct cal_ctl_data_5g ctlPowerData_5G[AR9300_NUM_CTLS_5G];
+ } __packed;
+ 
++static_assert(sizeof(struct ar9300_eeprom) == 0x440);
++
++struct qcn5502_eeprom {
++	u8 eepromVersion;
++	u8 templateVersion;
++	u8 macAddr[6];
++	u8 custData[AR9300_CUSTOMER_DATA_SIZE];
++
++	struct ar9300_base_eep_hdr baseEepHeader;
++
++	struct qcn5502_modal_eep_header modalHeader2G;
++	struct ar9300_BaseExtension_1 base_ext1;
++	u8 calFreqPier2G[AR9300_NUM_2G_CAL_PIERS];
++	struct ar9300_cal_data_per_freq_op_loop
++	 calPierData2G[QCN5502_MAX_CHAINS][AR9300_NUM_2G_CAL_PIERS];
++	u8 calTarget_freqbin_Cck[AR9300_NUM_2G_CCK_TARGET_POWERS];
++	u8 calTarget_freqbin_2G[AR9300_NUM_2G_20_TARGET_POWERS];
++	u8 calTarget_freqbin_2GHT20[AR9300_NUM_2G_20_TARGET_POWERS];
++	u8 calTarget_freqbin_2GHT40[AR9300_NUM_2G_40_TARGET_POWERS];
++	struct cal_tgt_pow_legacy
++	 calTargetPowerCck[AR9300_NUM_2G_CCK_TARGET_POWERS];
++	struct cal_tgt_pow_legacy
++	 calTargetPower2G[AR9300_NUM_2G_20_TARGET_POWERS];
++	struct qcn5502_cal_tgt_pow_ht
++	 calTargetPower2GHT20[AR9300_NUM_2G_20_TARGET_POWERS];
++	struct qcn5502_cal_tgt_pow_ht
++	 calTargetPower2GHT40[AR9300_NUM_2G_40_TARGET_POWERS];
++	u8 ctlIndex_2G[AR9300_NUM_CTLS_2G];
++	u8 ctl_freqbin_2G[AR9300_NUM_CTLS_2G][AR9300_NUM_BAND_EDGES_2G];
++	struct cal_ctl_data_2g ctlPowerData_2G[AR9300_NUM_CTLS_2G];
++	struct qcn5502_modal_eep_header modalHeader5G;
++	struct qcn5502_BaseExtension_2 base_ext2;
++	u8 calFreqPier5G[AR9300_NUM_5G_CAL_PIERS];
++	struct ar9300_cal_data_per_freq_op_loop
++	 calPierData5G[QCN5502_MAX_CHAINS][AR9300_NUM_5G_CAL_PIERS];
++	u8 calTarget_freqbin_5G[AR9300_NUM_5G_20_TARGET_POWERS];
++	u8 calTarget_freqbin_5GHT20[AR9300_NUM_5G_20_TARGET_POWERS];
++	u8 calTarget_freqbin_5GHT40[AR9300_NUM_5G_40_TARGET_POWERS];
++	struct cal_tgt_pow_legacy
++	 calTargetPower5G[AR9300_NUM_5G_20_TARGET_POWERS];
++	struct qcn5502_cal_tgt_pow_ht
++	 calTargetPower5GHT20[AR9300_NUM_5G_20_TARGET_POWERS];
++	struct qcn5502_cal_tgt_pow_ht
++	 calTargetPower5GHT40[AR9300_NUM_5G_40_TARGET_POWERS];
++	u8 ctlIndex_5G[AR9300_NUM_CTLS_5G];
++	u8 ctl_freqbin_5G[AR9300_NUM_CTLS_5G][AR9300_NUM_BAND_EDGES_5G];
++	struct cal_ctl_data_5g ctlPowerData_5G[AR9300_NUM_CTLS_5G];
++
++	u8 unknown[68];
++} __packed;
++
++static_assert(sizeof(struct qcn5502_eeprom) == 0x540);
++
+ s32 ar9003_hw_get_tx_gain_idx(struct ath_hw *ah);
+ s32 ar9003_hw_get_rx_gain_idx(struct ath_hw *ah);
+ u32 ar9003_hw_ant_ctrl_common_get(struct ath_hw *ah, bool is2ghz);
+diff --git a/drivers/net/wireless/ath/ath9k/hw.h b/drivers/net/wireless/ath/ath9k/hw.h
+index 2349d0e93c..20ece9eb9a 100644
+--- a/drivers/net/wireless/ath/ath9k/hw.h
++++ b/drivers/net/wireless/ath/ath9k/hw.h
+@@ -790,6 +790,7 @@ struct ath_hw {
+ 		struct ar5416_eeprom_4k map4k;
+ 		struct ar9287_eeprom map9287;
+ 		struct ar9300_eeprom ar9300_eep;
++		struct qcn5502_eeprom qcn5502;
+ 	} eeprom;
+ 	const struct eeprom_ops *eep_ops;
+ 
+-- 
+2.34.1
+
diff --git a/package/feeds/base/mac80211/patches/ath9k/543-ath9k_entropy_from_adc.patch b/package/feeds/base/mac80211/patches/ath9k/543-ath9k_entropy_from_adc.patch
index 6acc864d1e..ed6d7b216c 100644
--- a/package/feeds/base/mac80211/patches/ath9k/543-ath9k_entropy_from_adc.patch
+++ b/package/feeds/base/mac80211/patches/ath9k/543-ath9k_entropy_from_adc.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/hw.h
 +++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -723,6 +723,7 @@ struct ath_spec_scan {
+@@ -724,6 +724,7 @@ struct ath_spec_scan {
   * @config_pci_powersave:
   * @calibrate: periodic calibration for NF, ANI, IQ, ADC gain, ADC-DC
   *
@@ -8,7 +8,7 @@
   * @spectral_scan_config: set parameters for spectral scan and enable/disable it
   * @spectral_scan_trigger: trigger a spectral scan run
   * @spectral_scan_wait: wait for a spectral scan run to finish
-@@ -745,6 +746,7 @@ struct ath_hw_ops {
+@@ -746,6 +747,7 @@ struct ath_hw_ops {
  			struct ath_hw_antcomb_conf *antconf);
  	void (*antdiv_comb_conf_set)(struct ath_hw *ah,
  			struct ath_hw_antcomb_conf *antconf);
@@ -18,7 +18,7 @@
  	void (*spectral_scan_trigger)(struct ath_hw *ah);
 --- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
 +++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
-@@ -1915,6 +1915,26 @@ void ar9003_hw_init_rate_txpower(struct
+@@ -1917,6 +1917,26 @@ void ar9003_hw_init_rate_txpower(struct
  	}
  }
  
@@ -33,7 +33,7 @@
 +	memset(buf, 0, len);
 +	for (i = 0; i < len; i++) {
 +		for (j = 0; j < 4; j++) {
-+			u32 regval = REG_READ(ah, AR_PHY_TST_ADC);
++			u32 regval = REG_READ(ah, AR_PHY_TST_ADC(ah));
 +
 +			buf[i] <<= 2;
 +			buf[i] |= (regval & 1) | ((regval & BIT(10)) >> 9);
@@ -45,7 +45,7 @@
  void ar9003_hw_attach_phy_ops(struct ath_hw *ah)
  {
  	struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
-@@ -1951,6 +1971,7 @@ void ar9003_hw_attach_phy_ops(struct ath
+@@ -1953,6 +1973,7 @@ void ar9003_hw_attach_phy_ops(struct ath
  	priv_ops->set_radar_params = ar9003_hw_set_radar_params;
  	priv_ops->fast_chan_change = ar9003_hw_fast_chan_change;
  
diff --git a/package/feeds/base/mac80211/patches/ath9k/545-ath9k_ani_ws_detect.patch b/package/feeds/base/mac80211/patches/ath9k/545-ath9k_ani_ws_detect.patch
index d3bf07ff92..56d0355ade 100644
--- a/package/feeds/base/mac80211/patches/ath9k/545-ath9k_ani_ws_detect.patch
+++ b/package/feeds/base/mac80211/patches/ath9k/545-ath9k_ani_ws_detect.patch
@@ -79,7 +79,7 @@
  static const u8 ofdm2pwr[] = {
  	ALL_TARGET_LEGACY_6_24,
  	ALL_TARGET_LEGACY_6_24,
-@@ -1065,11 +1051,6 @@ static bool ar9003_hw_ani_control(struct
+@@ -1067,11 +1053,6 @@ static bool ar9003_hw_ani_control(struct
  	struct ath_common *common = ath9k_hw_common(ah);
  	struct ath9k_channel *chan = ah->curchan;
  	struct ar5416AniState *aniState = &ah->ani;
@@ -91,7 +91,7 @@
  	s32 value, value2;
  
  	switch (cmd & ah->ani_function) {
-@@ -1083,61 +1064,6 @@ static bool ar9003_hw_ani_control(struct
+@@ -1085,61 +1066,6 @@ static bool ar9003_hw_ani_control(struct
  		 */
  		u32 on = param ? 1 : 0;
  
@@ -119,37 +119,37 @@
 -		m2ThreshExt = on ?
 -			aniState->iniDef.m2ThreshExt : m2ThreshExt_off;
 -
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW(ah),
 -			      AR_PHY_SFCORR_LOW_M1_THRESH_LOW,
 -			      m1ThreshLow);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW(ah),
 -			      AR_PHY_SFCORR_LOW_M2_THRESH_LOW,
 -			      m2ThreshLow);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR(ah),
 -			      AR_PHY_SFCORR_M1_THRESH,
 -			      m1Thresh);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR(ah),
 -			      AR_PHY_SFCORR_M2_THRESH,
 -			      m2Thresh);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR(ah),
 -			      AR_PHY_SFCORR_M2COUNT_THR,
 -			      m2CountThr);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW(ah),
 -			      AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW,
 -			      m2CountThrLow);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT(ah),
 -			      AR_PHY_SFCORR_EXT_M1_THRESH_LOW,
 -			      m1ThreshLowExt);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT(ah),
 -			      AR_PHY_SFCORR_EXT_M2_THRESH_LOW,
 -			      m2ThreshLowExt);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT(ah),
 -			      AR_PHY_SFCORR_EXT_M1_THRESH,
 -			      m1ThreshExt);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
+-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT(ah),
 -			      AR_PHY_SFCORR_EXT_M2_THRESH,
 -			      m2ThreshExt);
 -skip_ws_det:
  		if (on)
- 			REG_SET_BIT(ah, AR_PHY_SFCORR_LOW,
+ 			REG_SET_BIT(ah, AR_PHY_SFCORR_LOW(ah),
  				    AR_PHY_SFCORR_LOW_USE_SELF_CORR_LOW);
-- 
2.51.1

